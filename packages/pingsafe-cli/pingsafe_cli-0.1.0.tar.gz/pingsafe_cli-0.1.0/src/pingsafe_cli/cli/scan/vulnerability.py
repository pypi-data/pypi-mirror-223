import json
import logging
import os
import sys

from tabulate import tabulate
import tempfile
import subprocess
import uuid
from pingsafe_cli.cli.registry import MissingRequiredFlags, CodeTypeSubParser, LogColors, MissingDependencies
from pingsafe_cli.cli.utils import read_from_file, print_output_on_file, get_config_path, get_severity_color, \
    get_version, get_exit_code_on_crash, get_os_and_architecture, get_wrapping_length, wrap_text

LOGGER = logging.getLogger("cli")


def vulnerability_parser(args, cache_directory):
    vulnerability_pre_evaluation(args)

    global_config_path = get_config_path(cache_directory)
    global_config_data = read_from_file(global_config_path)

    vulnerability_config_path = get_config_path(cache_directory, CodeTypeSubParser.VULN)
    vulnerability_config_data = read_from_file(vulnerability_config_path)

    issues = call_vulnerability_scanner(args, cache_directory)

    # means error occurred during vulnerability scanning
    if issues is None:
        return get_exit_code_on_crash(cache_directory)
    if len(issues) > 0:
        return vulnerability_post_evaluation(args, issues, global_config_data, vulnerability_config_data)
    else:
        print(LogColors.OKGREEN + "RESULT\tScan completed. No issue found!" + LogColors.ENDC)
    return 0


def vulnerability_pre_evaluation(args):
    operating_sys, arch = get_os_and_architecture()
    runtime = f"{operating_sys}/{arch}"
    not_supported_runtimes = ["windows/386", "windows/arm"]
    if runtime in not_supported_runtimes:
        LOGGER.info(f"{runtime} runtime not supported for vulnerability scanning")
        sys.exit(0)
    if args.directory == "" and args.docker_image == "":
        raise MissingRequiredFlags("Either --d/--directory or --docker-image is required with vuln")


def vulnerability_post_evaluation(args, issues, global_config_data, vulnerability_config_data):
    exit_code = 0

    for issue in issues:
        if exit_code == 0 and evaluate_exit_strategy(issue, vulnerability_config_data) == 1:
            exit_code = 1

    if len(issues) > 0:
        print_issue_on_console(issues, args.quiet, args.verbose)
        print_output_on_file(args, issues, global_config_data)
        print("RESULT\tScan completed. Found " + str(len(issues)) + " issues.")
    else:
        print(LogColors.OKGREEN + "RESULT\tScan completed. No issue found!" + LogColors.ENDC)

    return exit_code


def call_vulnerability_scanner(args, cache_directory):
    output_file = ""
    try:
        output_file = os.path.join(tempfile.gettempdir(), f"{uuid.uuid4()}.json")
        command = generate_command(args, cache_directory, output_file)
        subprocess.run(command)

        if os.path.exists(output_file):
            if os.path.getsize(output_file) > 0:
                return read_from_file(output_file)
            else:
                return []
        else:
            return None
    except Exception as e:
        raise e
    finally:
        if os.path.exists(output_file):
            os.remove(output_file)


def generate_command(args, cache_directory, output_path):
    version = get_version()
    binary_path = os.path.join(cache_directory, "bin", version, "bin_vulnerability_scanner")
    if not os.path.exists(binary_path):
        raise MissingDependencies(f"Missing Vulnerability Scanner Binary: {version}")

    scan_path = args.directory
    if args.docker_image:
        scan_path = args.docker_image

    command = [binary_path, "-p", scan_path, "--output-path", output_path]

    if args.debug:
        command.append("--debug")

    if args.only_fixed:
        command.append("--only-fixed")

    if args.docker_image:
        command.extend(["--scan-image", "--platform", args.platform,  "--registry", args.registry])

        if args.username != "":
            command.extend(["--username", args.username])
        if args.password != "":
            command.extend(["--password", args.password])
            command.extend(["--auth-token", args.password])

    return command


def evaluate_exit_strategy(issue, vulnerability_config_data):
    whitelisted_severity = vulnerability_config_data["exitStrategy"]["severity"]

    if issue["severity"].upper() in whitelisted_severity:
        return 1

    return 0


def print_issue_on_console(issues, quiet, verbose):
    if verbose:
        print(json.dumps(issues, indent=4))
        return

    table_data = []
    for issue in issues:
        if quiet:
            print(LogColors.FAIL + f'[ISSUE]\tFound {issue["id"]} inside package {issue["package"]} for version {issue["version"]}' + LogColors.ENDC)
        else:
            table_data.append(generate_table_row(issue))

    if len(table_data) > 0:
        print(tabulate(table_data, headers="keys", tablefmt="psql"))


def generate_table_row(issue):
    severity_color = get_severity_color(issue["severity"].upper())
    fixed_version = "-"
    if issue["fixedVersions"] != "":
        fixed_version = issue["fixedVersions"]

    required_length = get_wrapping_length(7)
    return {
        "Id": wrap_text(str(issue["id"]), required_length),
        "Severity": wrap_text(severity_color + issue["severity"] + LogColors.ENDC, required_length),
        "Package": wrap_text(str(issue["package"]), required_length),
        "Version": wrap_text(str(issue["version"]), required_length),
        "Fixed In": wrap_text(str(fixed_version), required_length),
        "CVSSScore": wrap_text(str(issue["CVSSScore"]), required_length),
        "Link": wrap_text(issue["link"], required_length)
    }
