"""
The posbus package implements the custom protocol for communication between the backend and frontends.

Originally it implemented messaging for position updates of objects in a 3D space, hence the PosBus name.
But has been expanded to include more types of information.

Messages are in a compact binary format and usually send through a websocket connection.


"""
# python wrapper for package github.com/momentum-xyz/ubercontroller/pkg/posbus within overall package pbc
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -name=pbc -rename -dynamic-link=true -output=odyssey_posbus_client github.com/momentum-xyz/posbus-client/pbc/compat github.com/momentum-xyz/ubercontroller/pkg/posbus github.com/momentum-xyz/ubercontroller/pkg/cmath

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _pbc
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from pbc import posbus
# and then refer to everything using posbus. prefix
# packages imported by this package listed below:

from . import cmath



# ---- Types ---

# Python type for slice []posbus.MsgType
class Slice_posbus_MsgType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_posbus_MsgType_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_posbus_MsgType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_posbus_MsgType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_posbus_MsgType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_posbus_MsgType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_posbus_MsgType_len(self.handle)
				return Slice_posbus_MsgType(handle=_pbc.Slice_posbus_MsgType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _pbc.Slice_posbus_MsgType_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_posbus_MsgType_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_posbus_MsgType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_posbus_MsgType_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_posbus_MsgType_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []posbus.ObjectDefinition
class Slice_posbus_ObjectDefinition(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_posbus_ObjectDefinition_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_posbus_ObjectDefinition.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_posbus_ObjectDefinition len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_posbus_ObjectDefinition([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_posbus_ObjectDefinition_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_posbus_ObjectDefinition_len(self.handle)
				return Slice_posbus_ObjectDefinition(handle=_pbc.Slice_posbus_ObjectDefinition_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ObjectDefinition(handle=_pbc.Slice_posbus_ObjectDefinition_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_posbus_ObjectDefinition_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_posbus_ObjectDefinition.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_posbus_ObjectDefinition_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_posbus_ObjectDefinition_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []posbus.UserData
class Slice_posbus_UserData(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_posbus_UserData_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_posbus_UserData.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_posbus_UserData len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_posbus_UserData([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_posbus_UserData_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_posbus_UserData_len(self.handle)
				return Slice_posbus_UserData(handle=_pbc.Slice_posbus_UserData_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return UserData(handle=_pbc.Slice_posbus_UserData_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_posbus_UserData_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_posbus_UserData.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_posbus_UserData_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_posbus_UserData_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []posbus.UserTransform
class Slice_posbus_UserTransform(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_posbus_UserTransform_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_posbus_UserTransform.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_posbus_UserTransform len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_posbus_UserTransform([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_posbus_UserTransform_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_posbus_UserTransform_len(self.handle)
				return Slice_posbus_UserTransform(handle=_pbc.Slice_posbus_UserTransform_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return UserTransform(handle=_pbc.Slice_posbus_UserTransform_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_posbus_UserTransform_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_posbus_UserTransform.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_posbus_UserTransform_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_posbus_UserTransform_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []posbus.VisualEffect
class Slice_posbus_VisualEffect(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_posbus_VisualEffect_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_posbus_VisualEffect.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_posbus_VisualEffect len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_posbus_VisualEffect([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_posbus_VisualEffect_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_posbus_VisualEffect_len(self.handle)
				return Slice_posbus_VisualEffect(handle=_pbc.Slice_posbus_VisualEffect_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return VisualEffect(handle=_pbc.Slice_posbus_VisualEffect_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_posbus_VisualEffect_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_posbus_VisualEffect.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_posbus_VisualEffect_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_posbus_VisualEffect_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []entry.SlotType
class Slice_entry_SlotType(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_entry_SlotType_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_entry_SlotType.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_entry_SlotType len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_entry_SlotType([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_entry_SlotType_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_entry_SlotType_len(self.handle)
				return Slice_entry_SlotType(handle=_pbc.Slice_entry_SlotType_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _pbc.Slice_entry_SlotType_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_entry_SlotType_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_entry_SlotType.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_entry_SlotType_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_entry_SlotType_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []umid.UMID
class Slice_umid_UMID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_umid_UMID_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_umid_UMID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_umid_UMID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_umid_UMID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_umid_UMID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_umid_UMID_len(self.handle)
				return Slice_umid_UMID(handle=_pbc.Slice_umid_UMID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.umid_UMID(handle=_pbc.Slice_umid_UMID_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_umid_UMID_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_umid_UMID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_umid_UMID_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_umid_UMID_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []reflect.Type
class Slice_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Slice_reflect_Type_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_reflect_Type.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.Slice_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.Slice_reflect_Type([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.Slice_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _pbc.Slice_reflect_Type_len(self.handle)
				return Slice_reflect_Type(handle=_pbc.Slice_reflect_Type_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.reflect_Type(handle=_pbc.Slice_reflect_Type_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.Slice_reflect_Type_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_reflect_Type.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.Slice_reflect_Type_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_pbc.Slice_reflect_Type_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice posbus.PBEthAddress
class PBEthAddress(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.posbus_PBEthAddress len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.posbus_PBEthAddress([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.posbus_PBEthAddress_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _pbc.posbus_PBEthAddress_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.posbus_PBEthAddress_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.posbus_PBEthAddress_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice posbus.PBUint256
class PBUint256(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'posbus.posbus_PBUint256 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'posbus.posbus_PBUint256([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _pbc.posbus_PBUint256_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _pbc.posbus_PBUint256_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_pbc.posbus_PBUint256_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _pbc.posbus_PBUint256_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for map map[entry.SlotType]*posbus.StringAnyMap
class Map_entry_SlotType_Ptr_posbus_StringAnyMap(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_entry_SlotType_Ptr_posbus_StringAnyMap.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_set(self.handle, k, v)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_len(self.handle)
	def __getitem__(self, key):
		return StringAnyMap(handle=_pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_elem(self.handle, key))
	def __setitem__(self, key, value):
		_pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_delete(self.handle, key)
	def keys(self):
		return Slice_entry_SlotType(handle=_pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _pbc.Map_entry_SlotType_Ptr_posbus_StringAnyMap_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class NotificationType(Enum):
	NotificationNone = 0
	NotificationWow = 1
	NotificationHighFive = 2
	NotificationStageModeAccept = 10
	NotificationStageModeInvitation = 11
	NotificationStageModeSet = 12
	NotificationStageModeStageJoin = 13
	NotificationStageModeStageRequest = 14
	NotificationStageModeStageDeclined = 15
	NotificationGatheringStart = 20
	NotificationTextMessage = 500
	NotificationRelay = 501
	NotificationGeneric = 999
	NotificationLegacy = 1000

NotificationNone = 0
NotificationWow = 1
NotificationHighFive = 2
NotificationStageModeAccept = 10
NotificationStageModeInvitation = 11
NotificationStageModeSet = 12
NotificationStageModeStageJoin = 13
NotificationStageModeStageRequest = 14
NotificationStageModeStageDeclined = 15
NotificationGatheringStart = 20
NotificationTextMessage = 500
NotificationRelay = 501
NotificationGeneric = 999
NotificationLegacy = 1000

class SignalType(Enum):
	SignalNone = 0
	SignalDualConnection = 1
	SignalReady = 2
	SignalInvalidToken = 3
	SignalSpawn = 4
	SignalLeaveWorld = 5
	SignalConnectionFailed = 6
	SignalConnected = 7
	SignalConnectionClosed = 8
	SignalWorldDoesNotExist = 9

SignalNone = 0
SignalDualConnection = 1
SignalReady = 2
SignalInvalidToken = 3
SignalSpawn = 4
SignalLeaveWorld = 5
SignalConnectionFailed = 6
SignalConnected = 7
SignalConnectionClosed = 8
SignalWorldDoesNotExist = 9

class MsgType(Enum):
	TypeLockObjectResponse = 153380492
	TypeUserStakedToOdyssey = 282774204
	TypeAttributeValueChanged = 282774967
	TypeAddObjects = 609397185
	TypeUsersTransformList = 676943032
	TypeUserTransform = 1003060923
	TypeHighFive = 1028658226
	TypeRemoveObjects = 1811450916
	TypeTeleportRequest = 2027574745
	TypeHandShake = 2084672538
	TypeUnlockObject = 2773409465
	TypeFlyToMe = 2800447686
	TypeLockObject = 2816384857
	TypeEventStart = 2860862764
	TypeSignal = 2915145293
	TypeNotification = 3254469079
	TypeActivityUpdate = 3394726237
	TypeObjectData = 3402504572
	TypeSetWorld = 3437178441
	TypeObjectDefinition = 3611473198
	TypeTriggerVisualEffects = 3646982598
	TypeObjectTransform = 3933054132
	TypeUserAction = 4011470453
	TypeAddPendingStake = 4028683906
	TypeGenericMessage = 4111000739
	TypeAddUsers = 4112460543
	TypeRemoveUsers = 4120988592
	TypeUserData = 4144164703
	TypeMyTransform = 4168664255

TypeLockObjectResponse = 153380492
TypeUserStakedToOdyssey = 282774204
TypeAttributeValueChanged = 282774967
TypeAddObjects = 609397185
TypeUsersTransformList = 676943032
TypeUserTransform = 1003060923
TypeHighFive = 1028658226
TypeRemoveObjects = 1811450916
TypeTeleportRequest = 2027574745
TypeHandShake = 2084672538
TypeUnlockObject = 2773409465
TypeFlyToMe = 2800447686
TypeLockObject = 2816384857
TypeEventStart = 2860862764
TypeSignal = 2915145293
TypeNotification = 3254469079
TypeActivityUpdate = 3394726237
TypeObjectData = 3402504572
TypeSetWorld = 3437178441
TypeObjectDefinition = 3611473198
TypeTriggerVisualEffects = 3646982598
TypeObjectTransform = 3933054132
TypeUserAction = 4011470453
TypeAddPendingStake = 4028683906
TypeGenericMessage = 4111000739
TypeAddUsers = 4112460543
TypeRemoveUsers = 4120988592
TypeUserData = 4144164703
TypeMyTransform = 4168664255



#---- Constants from Go: Python can only ask that you please don't change these! ---
ActivityUpdateChangeType = ""
ChangedActivityUpdateType = "changed"
ChangedAttributeChangeType = "attribute_changed"
InvalidAttributeChangeType = ""
MsgArrTypeSize = 4
MsgLockStateSize = 4
MsgTypeSize = 4
MsgUUIDTypeSize = 16
NewActivityUpdateType = "new"
RemovedActivityUpdateType = "removed"
RemovedAttributeChangeType = "attribute_removed"
TriggerEnteredObject = 3
TriggerHighFive = 2
TriggerLeftObject = 4
TriggerNone = 0
TriggerStake = 5
TriggerWow = 1
UserTransformMessageSize = 40


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface posbus.Message
class Message(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = 0
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_Message_GetType(self.handle)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int"""
		return _pbc.posbus_Message_MarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int"""
		return _pbc.posbus_Message_SizeMUS(self.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str"""
		return _pbc.posbus_Message_UnmarshalMUS(self.handle, buf.handle)


# ---- Structs ---

# Python type for struct posbus.UserData
class UserData(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_UserData_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  2 < len(args):
				self.Avatar = args[2]
			if "Avatar" in kwargs:
				self.Avatar = kwargs["Avatar"]
			if  3 < len(args):
				self.Transform = args[3]
			if "Transform" in kwargs:
				self.Transform = kwargs["Transform"]
			if  4 < len(args):
				self.IsGuest = args[4]
			if "IsGuest" in kwargs:
				self.IsGuest = kwargs["IsGuest"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserData{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserData ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_UserData_ID_Get(self.handle))
	@property
	def name(self):
		return _pbc.posbus_UserData_Name_Get(self.handle)
	@name.setter
	def name(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserData_Name_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserData_Name_Set(self.handle, value)
	@property
	def avatar(self):
		return _pbc.posbus_UserData_Avatar_Get(self.handle)
	@avatar.setter
	def avatar(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserData_Avatar_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserData_Avatar_Set(self.handle, value)
	@property
	def transform(self):
		return cmath.TransformNoScale(handle=_pbc.posbus_UserData_Transform_Get(self.handle))
	@transform.setter
	def transform(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserData_Transform_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def is_guest(self):
		return _pbc.posbus_UserData_IsGuest_Get(self.handle)
	@is_guest.setter
	def is_guest(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserData_IsGuest_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserData_IsGuest_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_UserData_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_UserData_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_UserData_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_UserData_GetType(self.handle)

# Python type for struct posbus.AddUsers
class AddUsers(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_AddUsers_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Users = args[0]
			if "Users" in kwargs:
				self.Users = kwargs["Users"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AddUsers{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AddUsers ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def users(self):
		return Slice_posbus_UserData(handle=_pbc.posbus_AddUsers_Users_Get(self.handle))
	@users.setter
	def users(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AddUsers_Users_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_AddUsers_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_AddUsers_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_AddUsers_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_AddUsers_GetType(self.handle)

# Python type for struct posbus.LockObjectResponse
class LockObjectResponse(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_LockObjectResponse_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Result = args[1]
			if "Result" in kwargs:
				self.Result = kwargs["Result"]
			if  2 < len(args):
				self.LockOwner = args[2]
			if "LockOwner" in kwargs:
				self.LockOwner = kwargs["LockOwner"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.LockObjectResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.LockObjectResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_LockObjectResponse_ID_Get(self.handle))
	@property
	def result(self):
		return _pbc.posbus_LockObjectResponse_Result_Get(self.handle)
	@result.setter
	def result(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_LockObjectResponse_Result_Set(self.handle, value.handle)
		else:
			_pbc.posbus_LockObjectResponse_Result_Set(self.handle, value)
	@property
	def lock_owner(self):
		return go.umid_UMID(handle=_pbc.posbus_LockObjectResponse_LockOwner_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_LockObjectResponse_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_LockObjectResponse_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_LockObjectResponse_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_LockObjectResponse_GetType(self.handle)

# Python type for struct posbus.ObjectDefinition
class ObjectDefinition(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_ObjectDefinition_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.ParentID = args[1]
			if "ParentID" in kwargs:
				self.ParentID = kwargs["ParentID"]
			if  2 < len(args):
				self.AssetType = args[2]
			if "AssetType" in kwargs:
				self.AssetType = kwargs["AssetType"]
			if  3 < len(args):
				self.AssetFormat = args[3]
			if "AssetFormat" in kwargs:
				self.AssetFormat = kwargs["AssetFormat"]
			if  4 < len(args):
				self.Name = args[4]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  5 < len(args):
				self.Transform = args[5]
			if "Transform" in kwargs:
				self.Transform = kwargs["Transform"]
			if  6 < len(args):
				self.IsEditable = args[6]
			if "IsEditable" in kwargs:
				self.IsEditable = kwargs["IsEditable"]
			if  7 < len(args):
				self.TetheredToParent = args[7]
			if "TetheredToParent" in kwargs:
				self.TetheredToParent = kwargs["TetheredToParent"]
			if  8 < len(args):
				self.ShowOnMiniMap = args[8]
			if "ShowOnMiniMap" in kwargs:
				self.ShowOnMiniMap = kwargs["ShowOnMiniMap"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ObjectDefinition{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ObjectDefinition ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_ObjectDefinition_ID_Get(self.handle))
	@property
	def parent_id(self):
		return go.umid_UMID(handle=_pbc.posbus_ObjectDefinition_ParentID_Get(self.handle))
	@property
	def asset_type(self):
		return go.umid_UMID(handle=_pbc.posbus_ObjectDefinition_AssetType_Get(self.handle))
	@property
	def asset_format(self):
		return _pbc.posbus_ObjectDefinition_AssetFormat_Get(self.handle)
	@asset_format.setter
	def asset_format(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectDefinition_AssetFormat_Set(self.handle, value.handle)
		else:
			_pbc.posbus_ObjectDefinition_AssetFormat_Set(self.handle, value)
	@property
	def name(self):
		return _pbc.posbus_ObjectDefinition_Name_Get(self.handle)
	@name.setter
	def name(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectDefinition_Name_Set(self.handle, value.handle)
		else:
			_pbc.posbus_ObjectDefinition_Name_Set(self.handle, value)
	@property
	def transform(self):
		return cmath.Transform(handle=_pbc.posbus_ObjectDefinition_Transform_Get(self.handle))
	@transform.setter
	def transform(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectDefinition_Transform_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def is_editable(self):
		return _pbc.posbus_ObjectDefinition_IsEditable_Get(self.handle)
	@is_editable.setter
	def is_editable(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectDefinition_IsEditable_Set(self.handle, value.handle)
		else:
			_pbc.posbus_ObjectDefinition_IsEditable_Set(self.handle, value)
	@property
	def tethered_to_parent(self):
		return _pbc.posbus_ObjectDefinition_TetheredToParent_Get(self.handle)
	@tethered_to_parent.setter
	def tethered_to_parent(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectDefinition_TetheredToParent_Set(self.handle, value.handle)
		else:
			_pbc.posbus_ObjectDefinition_TetheredToParent_Set(self.handle, value)
	@property
	def show_on_mini_map(self):
		return _pbc.posbus_ObjectDefinition_ShowOnMiniMap_Get(self.handle)
	@show_on_mini_map.setter
	def show_on_mini_map(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectDefinition_ShowOnMiniMap_Set(self.handle, value.handle)
		else:
			_pbc.posbus_ObjectDefinition_ShowOnMiniMap_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_ObjectDefinition_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_ObjectDefinition_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_ObjectDefinition_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_ObjectDefinition_GetType(self.handle)

# Python type for struct posbus.TeleportRequest
class TeleportRequest(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_TeleportRequest_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Target = args[0]
			if "Target" in kwargs:
				self.Target = kwargs["Target"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.TeleportRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.TeleportRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def target(self):
		return go.umid_UMID(handle=_pbc.posbus_TeleportRequest_Target_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_TeleportRequest_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_TeleportRequest_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_TeleportRequest_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_TeleportRequest_GetType(self.handle)

# Python type for struct posbus.MyTransform
class MyTransform(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_MyTransform_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Position = args[0]
			if "Position" in kwargs:
				self.Position = kwargs["Position"]
			if  1 < len(args):
				self.Rotation = args[1]
			if "Rotation" in kwargs:
				self.Rotation = kwargs["Rotation"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.MyTransform{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.MyTransform ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def position(self):
		return cmath.Vec3(handle=_pbc.posbus_MyTransform_Position_Get(self.handle))
	@position.setter
	def position(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_MyTransform_Position_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def rotation(self):
		return cmath.Vec3(handle=_pbc.posbus_MyTransform_Rotation_Get(self.handle))
	@rotation.setter
	def rotation(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_MyTransform_Rotation_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_MyTransform_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_MyTransform_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_MyTransform_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_MyTransform_GetType(self.handle)

# Python type for struct posbus.GenericMessage
class GenericMessage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_GenericMessage_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Topic = args[0]
			if "Topic" in kwargs:
				self.Topic = kwargs["Topic"]
			if  1 < len(args):
				self.Data = args[1]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.GenericMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.GenericMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def topic(self):
		return _pbc.posbus_GenericMessage_Topic_Get(self.handle)
	@topic.setter
	def topic(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_GenericMessage_Topic_Set(self.handle, value.handle)
		else:
			_pbc.posbus_GenericMessage_Topic_Set(self.handle, value)
	@property
	def data(self):
		return go.Slice_byte(handle=_pbc.posbus_GenericMessage_Data_Get(self.handle))
	@data.setter
	def data(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_GenericMessage_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_GenericMessage_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_GenericMessage_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_GenericMessage_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_GenericMessage_GetType(self.handle)

# Python type for struct posbus.UnlockObject
class UnlockObject(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_UnlockObject_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UnlockObject{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UnlockObject ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_UnlockObject_ID_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_UnlockObject_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_UnlockObject_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_UnlockObject_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_UnlockObject_GetType(self.handle)

# Python type for struct posbus.UserTransform
class UserTransform(go.GoClass):
	"""UserTransform is a transform to apply to a specific user.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_UserTransform_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Transform = args[1]
			if "Transform" in kwargs:
				self.Transform = kwargs["Transform"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserTransform{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserTransform ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_UserTransform_ID_Get(self.handle))
	@property
	def transform(self):
		return cmath.TransformNoScale(handle=_pbc.posbus_UserTransform_Transform_Get(self.handle))
	@transform.setter
	def transform(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserTransform_Transform_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_UserTransform_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_UserTransform_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_UserTransform_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_UserTransform_GetType(self.handle)

# Python type for struct posbus.RemoveUsers
class RemoveUsers(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_RemoveUsers_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Users = args[0]
			if "Users" in kwargs:
				self.Users = kwargs["Users"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.RemoveUsers{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.RemoveUsers ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def users(self):
		return Slice_umid_UMID(handle=_pbc.posbus_RemoveUsers_Users_Get(self.handle))
	@users.setter
	def users(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_RemoveUsers_Users_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_RemoveUsers_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_RemoveUsers_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_RemoveUsers_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_RemoveUsers_GetType(self.handle)

# Python type for struct posbus.AddObjects
class AddObjects(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_AddObjects_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Objects = args[0]
			if "Objects" in kwargs:
				self.Objects = kwargs["Objects"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AddObjects{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AddObjects ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def objects(self):
		return Slice_posbus_ObjectDefinition(handle=_pbc.posbus_AddObjects_Objects_Get(self.handle))
	@objects.setter
	def objects(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AddObjects_Objects_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_AddObjects_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_AddObjects_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_AddObjects_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_AddObjects_GetType(self.handle)

# Python type for struct posbus.LockObject
class LockObject(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_LockObject_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.LockObject{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.LockObject ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_LockObject_ID_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_LockObject_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_LockObject_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_LockObject_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_LockObject_GetType(self.handle)

# Python type for struct posbus.Signal
class Signal(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_Signal_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.Signal{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.Signal ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def value(self):
		return _pbc.posbus_Signal_Value_Get(self.handle)
	@value.setter
	def value(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_Signal_Value_Set(self.handle, value.handle)
		else:
			_pbc.posbus_Signal_Value_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_Signal_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_Signal_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_Signal_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_Signal_GetType(self.handle)

# Python type for struct posbus.UserStakedToOdyssey
class UserStakedToOdyssey(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_UserStakedToOdyssey_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.TransactionHash = args[0]
			if "TransactionHash" in kwargs:
				self.TransactionHash = kwargs["TransactionHash"]
			if  1 < len(args):
				self.Wallet = args[1]
			if "Wallet" in kwargs:
				self.Wallet = kwargs["Wallet"]
			if  2 < len(args):
				self.ObjectID = args[2]
			if "ObjectID" in kwargs:
				self.ObjectID = kwargs["ObjectID"]
			if  3 < len(args):
				self.Amount = args[3]
			if "Amount" in kwargs:
				self.Amount = kwargs["Amount"]
			if  4 < len(args):
				self.Comment = args[4]
			if "Comment" in kwargs:
				self.Comment = kwargs["Comment"]
			if  5 < len(args):
				self.Kind = args[5]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserStakedToOdyssey{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserStakedToOdyssey ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def transaction_hash(self):
		return _pbc.posbus_UserStakedToOdyssey_TransactionHash_Get(self.handle)
	@transaction_hash.setter
	def transaction_hash(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserStakedToOdyssey_TransactionHash_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserStakedToOdyssey_TransactionHash_Set(self.handle, value)
	@property
	def wallet(self):
		return _pbc.posbus_UserStakedToOdyssey_Wallet_Get(self.handle)
	@wallet.setter
	def wallet(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserStakedToOdyssey_Wallet_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserStakedToOdyssey_Wallet_Set(self.handle, value)
	@property
	def object_id(self):
		return go.umid_UMID(handle=_pbc.posbus_UserStakedToOdyssey_ObjectID_Get(self.handle))
	@property
	def amount(self):
		return _pbc.posbus_UserStakedToOdyssey_Amount_Get(self.handle)
	@amount.setter
	def amount(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserStakedToOdyssey_Amount_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserStakedToOdyssey_Amount_Set(self.handle, value)
	@property
	def comment(self):
		return _pbc.posbus_UserStakedToOdyssey_Comment_Get(self.handle)
	@comment.setter
	def comment(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserStakedToOdyssey_Comment_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserStakedToOdyssey_Comment_Set(self.handle, value)
	@property
	def kind(self):
		return _pbc.posbus_UserStakedToOdyssey_Kind_Get(self.handle)
	@kind.setter
	def kind(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserStakedToOdyssey_Kind_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserStakedToOdyssey_Kind_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_UserStakedToOdyssey_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_UserStakedToOdyssey_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_UserStakedToOdyssey_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_UserStakedToOdyssey_GetType(self.handle)

# Python type for struct posbus.AddPendingStake
class AddPendingStake(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_AddPendingStake_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.TransactionID = args[0]
			if "TransactionID" in kwargs:
				self.TransactionID = kwargs["TransactionID"]
			if  1 < len(args):
				self.OdysseyId = args[1]
			if "OdysseyId" in kwargs:
				self.OdysseyId = kwargs["OdysseyId"]
			if  2 < len(args):
				self.Wallet = args[2]
			if "Wallet" in kwargs:
				self.Wallet = kwargs["Wallet"]
			if  3 < len(args):
				self.Amount = args[3]
			if "Amount" in kwargs:
				self.Amount = kwargs["Amount"]
			if  4 < len(args):
				self.Comment = args[4]
			if "Comment" in kwargs:
				self.Comment = kwargs["Comment"]
			if  5 < len(args):
				self.Kind = args[5]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AddPendingStake{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AddPendingStake ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def transaction_id(self):
		return go.umid_UMID(handle=_pbc.posbus_AddPendingStake_TransactionID_Get(self.handle))
	@property
	def odyssey_id(self):
		return go.umid_UMID(handle=_pbc.posbus_AddPendingStake_OdysseyId_Get(self.handle))
	@property
	def wallet(self):
		return PBEthAddress(handle=_pbc.posbus_AddPendingStake_Wallet_Get(self.handle))
	@property
	def amount(self):
		return PBUint256(handle=_pbc.posbus_AddPendingStake_Amount_Get(self.handle))
	@property
	def comment(self):
		return _pbc.posbus_AddPendingStake_Comment_Get(self.handle)
	@comment.setter
	def comment(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AddPendingStake_Comment_Set(self.handle, value.handle)
		else:
			_pbc.posbus_AddPendingStake_Comment_Set(self.handle, value)
	@property
	def kind(self):
		return _pbc.posbus_AddPendingStake_Kind_Get(self.handle)
	@kind.setter
	def kind(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AddPendingStake_Kind_Set(self.handle, value.handle)
		else:
			_pbc.posbus_AddPendingStake_Kind_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_AddPendingStake_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_AddPendingStake_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_AddPendingStake_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_AddPendingStake_GetType(self.handle)

# Python type for struct posbus.FlyToMe
class FlyToMe(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_FlyToMe_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Pilot = args[0]
			if "Pilot" in kwargs:
				self.Pilot = kwargs["Pilot"]
			if  1 < len(args):
				self.PilotName = args[1]
			if "PilotName" in kwargs:
				self.PilotName = kwargs["PilotName"]
			if  2 < len(args):
				self.ObjectID = args[2]
			if "ObjectID" in kwargs:
				self.ObjectID = kwargs["ObjectID"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.FlyToMe{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.FlyToMe ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def pilot(self):
		return go.umid_UMID(handle=_pbc.posbus_FlyToMe_Pilot_Get(self.handle))
	@property
	def pilot_name(self):
		return _pbc.posbus_FlyToMe_PilotName_Get(self.handle)
	@pilot_name.setter
	def pilot_name(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_FlyToMe_PilotName_Set(self.handle, value.handle)
		else:
			_pbc.posbus_FlyToMe_PilotName_Set(self.handle, value)
	@property
	def object_id(self):
		return go.umid_UMID(handle=_pbc.posbus_FlyToMe_ObjectID_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_FlyToMe_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_FlyToMe_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_FlyToMe_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_FlyToMe_GetType(self.handle)

# Python type for struct posbus.UsersTransformList
class UsersTransformList(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_UsersTransformList_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UsersTransformList{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UsersTransformList ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def value(self):
		return Slice_posbus_UserTransform(handle=_pbc.posbus_UsersTransformList_Value_Get(self.handle))
	@value.setter
	def value(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UsersTransformList_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_UsersTransformList_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_UsersTransformList_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_UsersTransformList_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_UsersTransformList_GetType(self.handle)

# Python type for struct posbus.VisualEffect
class VisualEffect(go.GoClass):
	"""FIXME: finalize VisualEffect type with all data\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_VisualEffect_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.VisualEffect{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.VisualEffect ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def name(self):
		return _pbc.posbus_VisualEffect_Name_Get(self.handle)
	@name.setter
	def name(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_VisualEffect_Name_Set(self.handle, value.handle)
		else:
			_pbc.posbus_VisualEffect_Name_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_VisualEffect_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_VisualEffect_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_VisualEffect_SizeMUS(self.handle)

# Python type for struct posbus.SetWorld
class SetWorld(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_SetWorld_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  2 < len(args):
				self.Avatar = args[2]
			if "Avatar" in kwargs:
				self.Avatar = kwargs["Avatar"]
			if  3 < len(args):
				self.Owner = args[3]
			if "Owner" in kwargs:
				self.Owner = kwargs["Owner"]
			if  4 < len(args):
				self.Avatar3DAssetID = args[4]
			if "Avatar3DAssetID" in kwargs:
				self.Avatar3DAssetID = kwargs["Avatar3DAssetID"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.SetWorld{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.SetWorld ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_SetWorld_ID_Get(self.handle))
	@property
	def name(self):
		return _pbc.posbus_SetWorld_Name_Get(self.handle)
	@name.setter
	def name(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_SetWorld_Name_Set(self.handle, value.handle)
		else:
			_pbc.posbus_SetWorld_Name_Set(self.handle, value)
	@property
	def avatar(self):
		return go.umid_UMID(handle=_pbc.posbus_SetWorld_Avatar_Get(self.handle))
	@property
	def owner(self):
		return go.umid_UMID(handle=_pbc.posbus_SetWorld_Owner_Get(self.handle))
	@property
	def avatar_3d_asset_id(self):
		return go.umid_UMID(handle=_pbc.posbus_SetWorld_Avatar3DAssetID_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_SetWorld_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_SetWorld_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_SetWorld_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_SetWorld_GetType(self.handle)

# Python type for struct posbus.TriggerVisualEffects
class TriggerVisualEffects(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_TriggerVisualEffects_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Effects = args[0]
			if "Effects" in kwargs:
				self.Effects = kwargs["Effects"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.TriggerVisualEffects{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.TriggerVisualEffects ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def effects(self):
		return Slice_posbus_VisualEffect(handle=_pbc.posbus_TriggerVisualEffects_Effects_Get(self.handle))
	@effects.setter
	def effects(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_TriggerVisualEffects_Effects_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_TriggerVisualEffects_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_TriggerVisualEffects_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_TriggerVisualEffects_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_TriggerVisualEffects_GetType(self.handle)

# Python type for struct posbus.ActivityUpdate
class ActivityUpdate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_ActivityUpdate_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ActivityId = args[0]
			if "ActivityId" in kwargs:
				self.ActivityId = kwargs["ActivityId"]
			if  1 < len(args):
				self.ChangeType = args[1]
			if "ChangeType" in kwargs:
				self.ChangeType = kwargs["ChangeType"]
			if  3 < len(args):
				self.Data = args[3]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  4 < len(args):
				self.UserId = args[4]
			if "UserId" in kwargs:
				self.UserId = kwargs["UserId"]
			if  5 < len(args):
				self.ObjectId = args[5]
			if "ObjectId" in kwargs:
				self.ObjectId = kwargs["ObjectId"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ActivityUpdate{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ActivityUpdate ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def activity_id(self):
		return go.umid_UMID(handle=_pbc.posbus_ActivityUpdate_ActivityId_Get(self.handle))
	@property
	def change_type(self):
		return _pbc.posbus_ActivityUpdate_ChangeType_Get(self.handle)
	@change_type.setter
	def change_type(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ActivityUpdate_ChangeType_Set(self.handle, value.handle)
		else:
			_pbc.posbus_ActivityUpdate_ChangeType_Set(self.handle, value)
	@property
	def data(self):
		return go.Ptr_entry_ActivityData(handle=_pbc.posbus_ActivityUpdate_Data_Get(self.handle))
	@data.setter
	def data(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ActivityUpdate_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def user_id(self):
		return go.umid_UMID(handle=_pbc.posbus_ActivityUpdate_UserId_Get(self.handle))
	@property
	def object_id(self):
		return go.umid_UMID(handle=_pbc.posbus_ActivityUpdate_ObjectId_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_ActivityUpdate_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_ActivityUpdate_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_ActivityUpdate_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_ActivityUpdate_GetType(self.handle)

# Python type for struct posbus.HighFive
class HighFive(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_HighFive_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.SenderID = args[0]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  1 < len(args):
				self.ReceiverID = args[1]
			if "ReceiverID" in kwargs:
				self.ReceiverID = kwargs["ReceiverID"]
			if  2 < len(args):
				self.Message = args[2]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.HighFive{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.HighFive ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def sender_id(self):
		return go.umid_UMID(handle=_pbc.posbus_HighFive_SenderID_Get(self.handle))
	@property
	def receiver_id(self):
		return go.umid_UMID(handle=_pbc.posbus_HighFive_ReceiverID_Get(self.handle))
	@property
	def message(self):
		return _pbc.posbus_HighFive_Message_Get(self.handle)
	@message.setter
	def message(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_HighFive_Message_Set(self.handle, value.handle)
		else:
			_pbc.posbus_HighFive_Message_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_HighFive_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_HighFive_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_HighFive_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_HighFive_GetType(self.handle)

# Python type for struct posbus.ObjectTransform
class ObjectTransform(go.GoClass):
	"""ObjectTransform is a transform to apply to a specific object.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_ObjectTransform_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Transform = args[1]
			if "Transform" in kwargs:
				self.Transform = kwargs["Transform"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ObjectTransform{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ObjectTransform ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_ObjectTransform_ID_Get(self.handle))
	@property
	def transform(self):
		return cmath.Transform(handle=_pbc.posbus_ObjectTransform_Transform_Get(self.handle))
	@transform.setter
	def transform(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectTransform_Transform_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_ObjectTransform_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_ObjectTransform_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_ObjectTransform_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_ObjectTransform_GetType(self.handle)

# Python type for struct posbus.RemoveObjects
class RemoveObjects(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_RemoveObjects_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Objects = args[0]
			if "Objects" in kwargs:
				self.Objects = kwargs["Objects"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.RemoveObjects{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.RemoveObjects ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def objects(self):
		return Slice_umid_UMID(handle=_pbc.posbus_RemoveObjects_Objects_Get(self.handle))
	@objects.setter
	def objects(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_RemoveObjects_Objects_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_RemoveObjects_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_RemoveObjects_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_RemoveObjects_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_RemoveObjects_GetType(self.handle)

# Python type for struct posbus.UserAction
class UserAction(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_UserAction_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserAction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.UserAction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def value(self):
		return _pbc.posbus_UserAction_Value_Get(self.handle)
	@value.setter
	def value(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_UserAction_Value_Set(self.handle, value.handle)
		else:
			_pbc.posbus_UserAction_Value_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_UserAction_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_UserAction_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_UserAction_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_UserAction_GetType(self.handle)

# Python type for struct posbus.AttributeValueChanged
class AttributeValueChanged(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_AttributeValueChanged_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.PluginID = args[0]
			if "PluginID" in kwargs:
				self.PluginID = kwargs["PluginID"]
			if  1 < len(args):
				self.AttributeName = args[1]
			if "AttributeName" in kwargs:
				self.AttributeName = kwargs["AttributeName"]
			if  2 < len(args):
				self.ChangeType = args[2]
			if "ChangeType" in kwargs:
				self.ChangeType = kwargs["ChangeType"]
			if  3 < len(args):
				self.Value = args[3]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  4 < len(args):
				self.TargetID = args[4]
			if "TargetID" in kwargs:
				self.TargetID = kwargs["TargetID"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AttributeValueChanged{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.AttributeValueChanged ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def plugin_id(self):
		"""The plugin that owns the attribute
		"""
		return go.umid_UMID(handle=_pbc.posbus_AttributeValueChanged_PluginID_Get(self.handle))
	@property
	def attribute_name(self):
		"""Name of attribute (scoped to plugin)
		"""
		return _pbc.posbus_AttributeValueChanged_AttributeName_Get(self.handle)
	@attribute_name.setter
	def attribute_name(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AttributeValueChanged_AttributeName_Set(self.handle, value.handle)
		else:
			_pbc.posbus_AttributeValueChanged_AttributeName_Set(self.handle, value)
	@property
	def change_type(self):
		"""Indicate what has changed (removed or value changed)
		"""
		return _pbc.posbus_AttributeValueChanged_ChangeType_Get(self.handle)
	@change_type.setter
	def change_type(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AttributeValueChanged_ChangeType_Set(self.handle, value.handle)
		else:
			_pbc.posbus_AttributeValueChanged_ChangeType_Set(self.handle, value)
	@property
	def value(self):
		"""The new value, in case of change/new.
		"""
		return StringAnyMap(handle=_pbc.posbus_AttributeValueChanged_Value_Get(self.handle))
	@value.setter
	def value(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_AttributeValueChanged_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def target_id(self):
		"""ID of the related object/user
		"""
		return go.umid_UMID(handle=_pbc.posbus_AttributeValueChanged_TargetID_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_AttributeValueChanged_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_AttributeValueChanged_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_AttributeValueChanged_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_AttributeValueChanged_GetType(self.handle)

# Python type for struct posbus.HandShake
class HandShake(go.GoClass):
	"""A HandShake is the first message a client sends after connecting.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_HandShake_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.HandshakeVersion = args[0]
			if "HandshakeVersion" in kwargs:
				self.HandshakeVersion = kwargs["HandshakeVersion"]
			if  1 < len(args):
				self.ProtocolVersion = args[1]
			if "ProtocolVersion" in kwargs:
				self.ProtocolVersion = kwargs["ProtocolVersion"]
			if  2 < len(args):
				self.Token = args[2]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  3 < len(args):
				self.UserId = args[3]
			if "UserId" in kwargs:
				self.UserId = kwargs["UserId"]
			if  4 < len(args):
				self.SessionId = args[4]
			if "SessionId" in kwargs:
				self.SessionId = kwargs["SessionId"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.HandShake{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.HandShake ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def handshake_version(self):
		"""Versioning for this message, for compatibility handling.
		"""
		return _pbc.posbus_HandShake_HandshakeVersion_Get(self.handle)
	@handshake_version.setter
	def handshake_version(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_HandShake_HandshakeVersion_Set(self.handle, value.handle)
		else:
			_pbc.posbus_HandShake_HandshakeVersion_Set(self.handle, value)
	@property
	def protocol_version(self):
		"""Versioning for the protocol to use after the handshake.
		"""
		return _pbc.posbus_HandShake_ProtocolVersion_Get(self.handle)
	@protocol_version.setter
	def protocol_version(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_HandShake_ProtocolVersion_Set(self.handle, value.handle)
		else:
			_pbc.posbus_HandShake_ProtocolVersion_Set(self.handle, value)
	@property
	def token(self):
		"""Authentication token (JWT).
		"""
		return _pbc.posbus_HandShake_Token_Get(self.handle)
	@token.setter
	def token(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_HandShake_Token_Set(self.handle, value.handle)
		else:
			_pbc.posbus_HandShake_Token_Set(self.handle, value)
	@property
	def user_id(self):
		"""User identifier (should match the token).
		"""
		return go.umid_UMID(handle=_pbc.posbus_HandShake_UserId_Get(self.handle))
	@property
	def session_id(self):
		"""Unique session identifier, for state/reconnection handling.
		"""
		return go.umid_UMID(handle=_pbc.posbus_HandShake_SessionId_Get(self.handle))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_HandShake_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_HandShake_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_HandShake_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_HandShake_GetType(self.handle)

# Python type for struct posbus.Notification
class Notification(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_Notification_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.NotifyType = args[0]
			if "NotifyType" in kwargs:
				self.NotifyType = kwargs["NotifyType"]
			if  1 < len(args):
				self.Value = args[1]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.Notification{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.Notification ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def notify_type(self):
		return _pbc.posbus_Notification_NotifyType_Get(self.handle)
	@notify_type.setter
	def notify_type(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_Notification_NotifyType_Set(self.handle, value.handle)
		else:
			_pbc.posbus_Notification_NotifyType_Set(self.handle, value)
	@property
	def value(self):
		return _pbc.posbus_Notification_Value_Get(self.handle)
	@value.setter
	def value(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_Notification_Value_Set(self.handle, value.handle)
		else:
			_pbc.posbus_Notification_Value_Set(self.handle, value)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_Notification_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_Notification_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_Notification_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_Notification_GetType(self.handle)

# Python type for struct posbus.ObjectData
class ObjectData(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_ObjectData_CTor()
			_pbc.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Entries = args[1]
			if "Entries" in kwargs:
				self.Entries = kwargs["Entries"]
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ObjectData{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'posbus.ObjectData ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return go.umid_UMID(handle=_pbc.posbus_ObjectData_ID_Get(self.handle))
	@property
	def entries(self):
		return Map_entry_SlotType_Ptr_posbus_StringAnyMap(handle=_pbc.posbus_ObjectData_Entries_Get(self.handle))
	@entries.setter
	def entries(self, value):
		if isinstance(value, go.GoClass):
			_pbc.posbus_ObjectData_Entries_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_ObjectData_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_ObjectData_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_ObjectData_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_ObjectData_GetType(self.handle)


# ---- Slices ---


# ---- Maps ---

# Python type for map posbus.EventStart
class EventStart(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_EventStart_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('posbus_EventStart.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_pbc.posbus_EventStart_set(self.handle, k, v)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'pbc.posbus_EventStart len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'pbc.posbus_EventStart({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _pbc.posbus_EventStart_len(self.handle)
	def __getitem__(self, key):
		return _pbc.posbus_EventStart_elem(self.handle, key)
	def __setitem__(self, key, value):
		_pbc.posbus_EventStart_set(self.handle, key, value)
	def __delitem__(self, key):
		return _pbc.posbus_EventStart_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_pbc.posbus_EventStart_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _pbc.posbus_EventStart_contains(self.handle, key)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int
		
		MarshalMUS fills buf with the MUS encoding of v.
		"""
		return _pbc.posbus_EventStart_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str
		
		UnmarshalMUS parses the MUS-encoded buf, and sets the result to *v.
		"""
		return _pbc.posbus_EventStart_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int
		
		SizeMUS returns the size of the MUS-encoded v.
		"""
		return _pbc.posbus_EventStart_SizeMUS(self.handle)
	def get_type(self):
		"""GetType() long"""
		return _pbc.posbus_EventStart_GetType(self.handle)

# Python type for map posbus.StringAnyMap
class StringAnyMap(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pbc.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pbc.IncRef(self.handle)
		else:
			self.handle = _pbc.posbus_StringAnyMap_CTor()
			_pbc.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('posbus_StringAnyMap.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_pbc.posbus_StringAnyMap_set(self.handle, k, v)
	def __del__(self):
		_pbc.DecRef(self.handle)
	def __str__(self):
		s = 'pbc.posbus_StringAnyMap len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'pbc.posbus_StringAnyMap({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _pbc.posbus_StringAnyMap_len(self.handle)
	def __getitem__(self, key):
		return any(handle=_pbc.posbus_StringAnyMap_elem(self.handle, key))
	def __setitem__(self, key, value):
		_pbc.posbus_StringAnyMap_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _pbc.posbus_StringAnyMap_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_pbc.posbus_StringAnyMap_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _pbc.posbus_StringAnyMap_contains(self.handle, key)
	def marshal_mus(self, buf):
		"""MarshalMUS([]int buf) int"""
		return _pbc.posbus_StringAnyMap_MarshalMUS(self.handle, buf.handle)
	def unmarshal_mus(self, buf):
		"""UnmarshalMUS([]int buf) int, str"""
		return _pbc.posbus_StringAnyMap_UnmarshalMUS(self.handle, buf.handle)
	def size_mus(self):
		"""SizeMUS() int"""
		return _pbc.posbus_StringAnyMap_SizeMUS(self.handle)


# ---- Constructors ---
def new_generic_message(topic, data):
	"""NewGenericMessage(str topic, str data) object"""
	return GenericMessage(handle=_pbc.posbus_NewGenericMessage(topic, data))


# ---- Functions ---
def message_name_by_id(id):
	"""MessageNameById(long id) str"""
	return _pbc.posbus_MessageNameById(id)
def message_data_type_by_id(id):
	"""MessageDataTypeById(long id) object"""
	return go.reflect_Type(handle=_pbc.posbus_MessageDataTypeById(id))
def message_id_by_name(name):
	"""MessageIdByName(str name) long"""
	return _pbc.posbus_MessageIdByName(name)
def bin_message(m):
	"""BinMessage(object m) []int"""
	return go.Slice_byte(handle=_pbc.posbus_BinMessage(m.handle))
def message_type_name_by_id(id):
	"""MessageTypeNameById(long id) str"""
	return _pbc.posbus_MessageTypeNameById(id)
def msg_type_id(m):
	"""MsgTypeId(object m) long"""
	return _pbc.posbus_MsgTypeId(m.handle)
def ws_message(m):
	"""WSMessage(object m) object"""
	return go.Ptr_websocket_PreparedMessage(handle=_pbc.posbus_WSMessage(m.handle))
def decode_to(buf, m):
	"""DecodeTo([]int buf, object m) str err"""
	return _pbc.posbus_DecodeTo(buf.handle, m.handle)
def extra_types():
	"""ExtraTypes() []object"""
	return Slice_reflect_Type(handle=_pbc.posbus_ExtraTypes())
def message_type(buf):
	"""MessageType([]int buf) long"""
	return _pbc.posbus_MessageType(buf.handle)
def msg_type_name(m):
	"""MsgTypeName(object m) str"""
	return _pbc.posbus_MsgTypeName(m.handle)
def new_message_of_type(msgType):
	"""NewMessageOfType(long msgType) object, str"""
	return Message(handle=_pbc.posbus_NewMessageOfType(msgType))
def decode(buf):
	"""Decode([]int buf) object, str"""
	return Message(handle=_pbc.posbus_Decode(buf.handle))
def get_message_ids():
	"""GetMessageIds() []long"""
	return Slice_posbus_MsgType(handle=_pbc.posbus_GetMessageIds())


