"""
Flow model
"""

from typing import TYPE_CHECKING, Dict, List, Union

from pydantic import BaseModel, Field

from fluidsdk.intents import *
from fluidsdk.message import *
from fluidsdk.status_webhook import *

if TYPE_CHECKING:
    from dataclasses import dataclass as _basemodel_decorator
else:
    def _basemodel_decorator(x):
        return x


flow_cache = {}


@_basemodel_decorator
class MessageConfig(BaseModel):
    message_delay: float = Field(
        0, title="Message delay", description="Delay between messages"
    )
    queue_messages: bool = Field(
        True,
        title="Queue Messages",
        description="Whether messages should be queued, and sent all at once after intents are done processing, or should be sent as they are generated by the intents.",
    )


class MessageHandlingConfig(BaseModel):
    confirmation_thresholds: Dict[str, float] = Field(
        {"Stop Conversation": 0.75, "Pause Conversation": 0.75}
    )
    confirmation_messages: Dict[str, str] = Field(
        {
            "Stop Conversation": one_of(
                [
                    "If I am hearing you correctly, you don't want to talk to me anymore?",
                    "I don't want to assume, but it sounds like you want to end our chat. Is it?",
                    "Correct me if I'm wrong, but it feels like you want to end this conversation. Is it?",
                    "It seems like you're not enjoying this chat. You want to stop talking to me?",
                ]
            ),
            "Pause Conversation": one_of(
                [
                    "Okay, I'll talk with you later?",
                    "So, would you be available to continue our conversation later?",
                    "Can I check in with you later to chat some more then?",
                    "Alright then, is it okay if we reconnect after a while?",
                    "Okay then, would it be alright if I reached out to you later to talk more?",
                    "Sure, Shall we continue the chat after a short break?",
                ]
            ),
        },
        description="phrase such that replying yes will handle that intent",
    )
    confirmation_replied_yes_messages: Dict[str, str] = Field(
        {
            "Stop Conversation": one_of(
                [
                    "That's okay. I am sad I wish I could have done better. If you ever want to chat with me again, you just have to say Hi.",
                    "I've enjoyed talking with you and I'd love to chat again sometime. Just say hi whenever you're ready!",
                    "I've had a great time talking with you and I'd be happy to do it again. Just let me know when you want to chat!",
                    "For me, this conversation was really good. If you ever feel like talking again, just say hi and we can pick up where we left off!",
                    "I've genuinely enjoyed our chat and I would be happy to do it again anytime. Just reach out with a hi and we can talk more!",
                    "I've had a really good time talking with you and I'd be happy to chat again. Just let me know when you're up for it by saying hi!",
                ]
            ),
            "Pause Conversation": one_of(
                [
                    "Good. We will talk later then. Hope to hear from you.",
                    "Sounds good, we can chat later!",
                    "Alright then, let's connect again soon.",
                    "Sure thing, I'll catch up with you later.",
                    "Cool, we can continue this conversation at a later time.",
                ]
            ),
        }
    )
    confirmation_replied_no_messages: Dict[str, str] = Field(
        {
            "Stop Conversation": one_of(
                [
                    "Oh my bad, I am shy so I keep checking if you want to really chat with me or not. Let's keep talking.",
                    "Thanks for understanding, I'm a bit shy sometimes. But I'm really enjoying our conversation, let's continue!",
                    "Sorry if I seemed hesitant before, I'm just a bit shy. But I'm feeling more comfortable now, so let's keep talking!",
                    "I hope I'm not coming across as disinterested, I'm just naturally a bit shy. But I'm actually really enjoying our conversation and I'd love to keep it going!",
                    "It's not that I don't want to talk to you, I'm just shy and sometimes need reassurance. But I'm really enjoying our chat and would like to keep it up!",
                    "I know I can be a bit reserved at first, but I'm really enjoying talking with you. Let's keep the conversation going!",
                ]
            ),
            "Pause Conversation": one_of(
                [
                    "Oh my bad, I am shy so I keep checking if you are busy or not. Let's keep talking.",
                    "Thanks for understanding, I'm a bit shy sometimes. But I'm really enjoying our conversation, let's continue!",
                    "Sorry if I seemed hesitant before, I'm just a bit shy. But I'm feeling more comfortable now, so let's keep talking!",
                    "I hope I'm not coming across as disinterested, I'm just naturally a bit shy. But I'm actually really enjoying our conversation and I'd love to keep it going!",
                    "It's not that I don't want to talk to you, I'm just shy and sometimes need reassurance. But I'm really enjoying our chat and would like to keep it up!",
                    "I know I can be a bit reserved at first, but I'm really enjoying talking with you. Let's keep the conversation going!",
                ]
            ),
        }
    )
    transfer_to_agent_if_message_handling: bool = Field(
        False,
        title="Transfer to agent if message is confirmed as Stop or Pause.",
    )
    smart_filter_subflow_steps: Dict[  # NOTE: not yet implemented
        str,  # classification or filter label name
        Dict[
            str,  # step name for that filter handling subflow
            Union[
                AskDefiniteIntent,
                AskOpenIntent,
                SayIntent,
                ConditionIntent,
                GPTGenerateIntent,
                ExpressionIntent,
                HTTPRequestIntent,
            ],
        ],
    ] = Field(
        {},
        title="Steps for each label to handle",
        description="Ordered dictionary of limited Intents",
    )


@_basemodel_decorator
class MessageHandling(BaseModel):
    """
    End with Confirmation
    If I am hearing you correctly, you don't want to talk to me anymore?

    No => That's okay. I am sad I wish I could have done better. If you ever want to chat with me again, you just have to say Hi.
    Yes => Oh my bad, I am shy so I keep checking if you want to really chat with me or not. Let's keep talking.


    Pause
    Okay, I'll talk with you later?

    Yes => Okay, I am glad we can still keep talking. I do like chatting with you.
    No => I think I made you too angry. Sorry! You can ping me whenever you want.   (Consider END)
    """

    enable_common_message_handling_filters: bool = Field(
        True,
        title="Enable common Message Handling Filters",
        description="Whether to stop/pause/resume the flow.",
    )
    message_handling_config: MessageHandlingConfig = Field(
        MessageHandlingConfig(),
        title="Message Handling Config Thresholds and Flow Messages",
    )


class KnowledgeBaseThresholds(BaseModel):
    search_fact_with_minimum_similarity: float = Field(  # TODO: lower down if query is in hinglish
        0.5,
        title="Athena's Minimum Similarity to be considered as retrieved fact.",
        description="The minimum similarity for a fact to be considered a KB answer.",
    )
    handle_as_query_start_threshold_kb_decider: float = Field(
        0.8,
        title="Minimum probability for a message to decide if it should be handled as a query by KB or now.",
    )
    handle_as_query_start_threshold_fact_similarity: float = Field(
        0.75,
        title="Minimum probability for a statement if matched with KB fact, to let handle despite it being classified statement"
    )

class KnowledgeBaseFeatureFlags(BaseModel):
    is_this_support_first_bot: bool = Field(
        False,
        title="Bot's main flow is support first and micro flows are triggered only with user requests.",
    )
    enable_transfer_for_media_messages: bool = Field(
        False,
        title="Transfer to agents if user sends media messages"
    )
    static_agent_transfer_override_message: Union[str, None] = Field(
        None,
        title="Static message to send to user when we transfer to agent."
    )
    timezone: str = Field(
        "Asia/Kolkata",
        title="Timezone to use for out of office hours",
        description="Timezone to use for out of office hours. Default is Asia/Kolkata"
    )
    out_of_office_hours_custom_agent_transfer_message: Union[str, None] = Field(
        None,
        title="Customize message to send to user sends message during out of office hours and we transfer to agent."
    )
    out_of_office_hours: List[str] = Field(   # TODO: change to Time after migrating to Pydantic 2
        [
            "23:30",
            "07:30",
        ],
        title="Starting and ending Out of office hours for the bot",
        description="The bot will transfer to agents if the user sends a message during these hours."
    )
    medical_guardrail_threshold: float = Field(
        0.9,
        title="Threshold for medical guardrail to kick in and apologize or transfer to agent.",
    )
    use_partial_answerable: bool = Field(
        True,
        title="Use partially answerable facts to answer the user query and seek confirmation.",
    )

KnowledgeBaseFeatureFlags.update_forward_refs()

class KnowledgeBase(BaseModel):
    enable_kb_search_globally: bool = Field(
        False,
        title="Enable KB Search Globally",
        description="Whether to enable KB search globally, or only when the flow has the intent.",
    )
    knowledge_base_name: str = Field(  # TODO: add Validator and athena endpoint to check if KB collection exists in qdrant
        "workhack",
        title="Knowledge Base Collection name in Athena",
        description="The knowledge base to use for this flow. If not specified, the default workhack's knowledge base will be used.",
    )
    context: Union[str, None] = Field(
        "User details unavailable. Do not make any assumption of which company or product they asked for.",
        title="Context for the knowledge base paraphrasing",
        description="Example: We are nutrition consultant at Our Little Joys, an Indian health company for Kids of age 2-12 years selling Nutrimix a protein powder made of natural grains, nuts and jaggery. Answer with confident assertive personality."
    )
    thresholds: KnowledgeBaseThresholds = Field(
        KnowledgeBaseThresholds(),
        title="Various Knowledge Base Configuration Thresholds",
    )
    feature_flags: KnowledgeBaseFeatureFlags = Field(
        KnowledgeBaseFeatureFlags(),
        title="Optional Knowledge Base Feature Flags",
    )

@_basemodel_decorator
class Flow(BaseModel):
    flow_id: str = Field(..., title="Flow ID", description="Name of the flow.")
    flow_description: str = Field(
        ...,
        title="Flow Description",
        description="A short description of what the flow does.",
    )
    data: dict = Field(
        {},
        title="Data",
        description="Global flow data all user conversations have access to.",
    )
    steps: Dict[
        str,
        Union[
            AskDefiniteIntent,
            AskOpenIntent,
            SayIntent,
            CollectAttachmentsIntent,
            ConditionIntent,
            GPTGenerateIntent,
            GPTSearchIntent,
            ExpressionIntent,
            HTTPRequestIntent,
            DynamicImage,
            KnowledgeBaseSearch,
            ImageGenerateIntent,
            AskOpenAgentIntent,
            JumpIntent,
            ScheduleJobIntent,
        ],
    ] = Field(
        {},
        title="Steps",
        description="Ordered dictionary of Intents",
    )
    invitation_messages: List[BotMessageUnion] = Field(
        [], title="Invitation Messages", description="Messages sent on invitation."
    )
    end_conversation_messages: List[str] = Field(
        ["Your responses have been recorded."],
        title="End Conversation Message",
        description="Message to be sent at the end of the conversation.",
    )
    referred_conversation_messages: List[str] = Field(
        ["Hello, {name}."],
        title="Referred Conversation Messages",
        description="Message to be sent at the begining of the conversation if the user started the conversation.",
    )
    status_webhook: StatusWebhook = Field(
        StatusWebhook(),
        title="Status Webhook",
        description="URL and data for status webhook.",
    )
    message_config: MessageConfig = Field(
        MessageConfig(),
        title="Message Config",
        description="Config for how messages are sent.",
    )
    knowledge_base: KnowledgeBase = Field(
        KnowledgeBase(),
        title="Knowledge base Config",
        description="Config for knowledge base search.",
    )
    message_handling: MessageHandling = Field(
        MessageHandling(),
        title="Message Handling",
        description="Config for message handling.",
    )

    class Config:
        smart_union = True

