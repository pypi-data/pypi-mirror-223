# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_nostr_sdk_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_nostr_sdk_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_nostr_sdk_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder(*args):
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consumeWithStream")
        finally:
            self.free()

    @contextlib.contextmanager
    def readWithStream(self):
        """Context-manager to read a buffer using a RustBufferStream.

        This is like consumeWithStream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `RustBuffer` data.
        """
        s = RustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of readWithStream")

class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream:
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")

    def readCSizeT(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class RustBufferBuilder:
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)

    def writeCSizeT(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def rust_call_async(scaffolding_fn, callback_fn, *args):
    # Call the scaffolding function, passing it a callback handler for `AsyncTypes.py` and a pointer
    # to a python Future object.  The async function then awaits the Future.
    uniffi_eventloop = asyncio.get_running_loop()
    uniffi_py_future = uniffi_eventloop.create_future()
    uniffi_call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))
    scaffolding_fn(*args,
       FfiConverterForeignExecutor._pointer_manager.new_pointer(uniffi_eventloop),
       callback_fn,
       # Note: It's tempting to skip the pointer manager and just use a `py_object` pointing to a
       # local variable like we do in Swift.  However, Python doesn't use cooperative cancellation
       # -- asyncio can cancel a task at anytime.  This means if we use a local variable, the Rust
       # callback could fire with a dangling pointer.
       UniFfiPyFuturePointerManager.new_pointer(uniffi_py_future),
       ctypes.byref(uniffi_call_status),
    )
    uniffi_check_call_status(None, uniffi_call_status)
    return uniffi_py_future

def uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(RustBuffer))
class UniFfiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See UniFfiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class UniFfiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as UniFfiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    UniFfiPointerManager = UniFfiPointerManagerCPython  # type: ignore
else:
    UniFfiPointerManager = UniFfiPointerManagerGeneral  # type: ignore
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.writeUnchecked(cls.check(value), buf)

class FfiConverterPrimitiveInt(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class FfiConverterPrimitiveFloat(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p)

def uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, RustCallStatus)

from pathlib import Path

def loadIndirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("nostr_sdk_ffi")
    path = str(Path(__file__).parent / libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 22
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_nostr_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def uniffi_check_api_checksums(lib):
    if lib.uniffi_nostr_sdk_checksum_func_nip04_encrypt() != 49043:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_func_nip04_decrypt() != 41451:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_func_verify_nip05() != 62577:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_func_get_nip05_profile() != 14503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_func_init_logger() != 22868:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_name() != 61239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_description() != 51721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_pubkey() != 54945:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_contact() != 52227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_supported_nips() != 4824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_software() != 2492:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_version() != 11282:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_public_key() != 25897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_relay_url() != 43411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_name() != 14069:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_url() != 42824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_description() != 14075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_profile_to_bech32() != 33129:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_profile_to_nostr_uri() != 6904:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_profile_public_key() != 58326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_profile_relays() != 24458:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_imagedimensions_width() != 31102:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_imagedimensions_height() != 11249:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_timestamp_as_secs() != 16326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_timestamp_to_human_datetime() != 21262:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_secretkey_to_hex() != 54909:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_secretkey_to_bech32() != 4484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_publickey_to_hex() != 14001:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_publickey_to_bech32() != 17373:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_publickey_to_nostr_uri() != 51041:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_keys_public_key() != 28447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_keys_secret_key() != 64487:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_id() != 11929:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_ids() != 59009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_author() != 50416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_authors() != 26531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_kind() != 32792:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_kinds() != 12323:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_event() != 44713:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_events() != 49685:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_pubkey() != 7756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_pubkeys() != 1024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_search() != 49994:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_since() != 43056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_until() != 7776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_limit() != 60627:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_custom_tag() != 31220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filter_as_json() != 44560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventid_as_bytes() != 59641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventid_to_hex() != 48869:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventid_to_bech32() != 51748:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventid_to_nostr_uri() != 41847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_id() != 63045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_pubkey() != 45626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_created_at() != 43917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_kind() != 43685:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_tags() != 2880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_content() != 5418:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_sign() != 63641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_add_signature() != 53768:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_unsignedevent_as_json() != 19056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_id() != 42213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_pubkey() != 61122:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_created_at() != 38149:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_kind() != 9991:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_tags() != 64767:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_content() != 61289:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_signature() != 51475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_verify() != 42880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_event_as_json() != 26774:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_event() != 47288:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_pow_event() != 49016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_event() != 25117:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_pow_event() != 57682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_contact_alias() != 7484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_contact_public_key() != 7174:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_contact_relay_url() != 5572:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_accountmetadata_name() != 32146:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_accountmetadata_display_name() != 31496:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_accountmetadata_about() != 245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_accountmetadata_picture() != 42395:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_accountmetadata_nip05() != 36375:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filemetadata_aes_256_gcm() != 42674:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filemetadata_size() != 55579:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filemetadata_dimensions() != 43468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filemetadata_magnet() != 567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_filemetadata_blurhash() != 12187:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_tag_as_enum() != 46171:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_tag_as_vec() != 25536:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_tag_kind() != 20691:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_attempts() != 57259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_success() != 33094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_connected_at() != 20634:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_activesubscription_id() != 13538:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_activesubscription_filters() != 18110:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_url() != 63830:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_proxy() != 37491:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_status() != 42548:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_is_connected() != 42522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_document() != 38574:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_subscriptions() != 19371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_update_subscription_filters() != 16638:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_stats() != 34071:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_queue() != 41226:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_connect() != 40847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_stop() != 53893:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_terminate() != 30121:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_send_msg() != 43650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_subscribe() != 33520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_unsubscribe() != 28598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_get_events_of() != 42242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_relay_req_events_of() != 57693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_wait_for_connection() != 64406:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_wait_for_send() != 50644:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_wait_for_ok() != 37939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_wait_for_subscription() != 54839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_difficulty() != 55584:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_req_filters_chunk_size() != 32969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_timeout() != 40520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_send_timeout() != 46598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_options_nip46_timeout() != 53514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_update_difficulty() != 16293:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_keys() != 24602:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_start() != 34021:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_stop() != 23547:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_is_running() != 29603:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_shutdown() != 8409:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_clear_already_seen_events() != 13739:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_relays() != 33892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_relay() != 16028:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_add_relay() != 46021:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_remove_relay() != 20000:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_connect_relay() != 44731:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_disconnect_relay() != 9298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_connect() != 1786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_disconnect() != 7794:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_subscribe() != 59977:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_unsubscribe() != 47263:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_get_events_of() != 39045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_req_events_of() != 571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_send_msg() != 18330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_send_msg_to() != 41225:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_send_event() != 56916:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_send_event_to() != 41856:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_file_metadata() != 53563:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_method_client_handle_notifications() != 6806:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_relayinformationdocument_get() != 35117:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_nostrconnecturi_from_string() != 16579:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_profile_new() != 43228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_profile_from_bech32() != 57990:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_profile_from_nostr_uri() != 6144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_imagedimensions_new() != 56829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_timestamp_now() != 40120:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_timestamp_from_secs() != 24259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_secretkey_from_hex() != 45466:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_secretkey_from_bech32() != 49705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_publickey_from_hex() != 26120:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_publickey_from_bech32() != 43445:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_publickey_from_nostr_uri() != 28819:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_new() != 65452:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_from_public_key() != 18854:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_from_sk_str() != 8858:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_from_pk_str() != 46636:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_generate() != 7127:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_vanity() != 46291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_keys_from_mnemonic() != 55257:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_filter_new() != 59121:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_filter_from_json() != 49237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventid_new() != 23137:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventid_from_slice() != 63630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventid_from_hex() != 44700:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventid_from_bech32() != 51381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventid_from_nostr_uri() != 62444:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_unsignedevent_from_json() != 6716:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_event_from_json() != 40059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new() != 33931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_metadata() != 50751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_add_recommended_relay() != 20155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_text_note() != 26461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_long_form_text_note() != 34296:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_repost() != 58397:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_contact_list() != 55954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_encrypted_direct_msg() != 2016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_delete() != 32677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_reaction() != 46279:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel() != 14798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_channel_metadata() != 5534:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel_msg() != 32541:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_hide_channel_msg() != 2207:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_mute_channel_user() != 15046:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_auth() != 682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_report() != 24985:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap_request() != 48382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap() != 35089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_file_metadata() != 45590:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_contact_new() != 1452:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_accountmetadata_new() != 65302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_filemetadata_new() != 9277:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_tag_parse() != 12983:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_tag_from_enum() != 45661:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_options_new() != 18345:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_client_new() != 40232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_nostr_sdk_checksum_constructor_client_with_opts() != 52224:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.uniffi_nostr_sdk_fn_free_relayinformationdocument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_relayinformationdocument.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_relayinformationdocument_get.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_relayinformationdocument_get.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_name.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_description.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_pubkey.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_contact.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_supported_nips.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_supported_nips.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_software.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_software.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_version.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_nostrconnecturi.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_nostrconnecturi.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_nostrconnecturi_from_string.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_nostrconnecturi_from_string.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_public_key.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_relay_url.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_name.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_url.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_description.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_profile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_profile.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_new.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_from_bech32.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_from_bech32.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_from_nostr_uri.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_from_nostr_uri.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_to_bech32.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_to_nostr_uri.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_public_key.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_profile_relays.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_imagedimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_imagedimensions.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_imagedimensions_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_imagedimensions_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_imagedimensions_width.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_imagedimensions_width.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_imagedimensions_height.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_imagedimensions_height.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_free_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_timestamp.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_timestamp_now.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_timestamp_now.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_timestamp_from_secs.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_timestamp_from_secs.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_timestamp_as_secs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_timestamp_as_secs.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_timestamp_to_human_datetime.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_timestamp_to_human_datetime.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_secretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_secretkey.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_secretkey_from_hex.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_secretkey_from_hex.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_secretkey_from_bech32.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_secretkey_from_bech32.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_secretkey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_secretkey_to_hex.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_secretkey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_secretkey_to_bech32.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_publickey.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_hex.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_hex.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_bech32.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_bech32.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_nostr_uri.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_nostr_uri.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_hex.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_bech32.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_nostr_uri.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_keys.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_public_key.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_sk_str.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_sk_str.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_pk_str.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_pk_str.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_generate.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_generate.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_vanity.argtypes = (
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_vanity.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_mnemonic.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_mnemonic.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_keys_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_keys_public_key.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_keys_secret_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_keys_secret_key.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_free_filter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_filter.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_filter_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_filter_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_filter_from_json.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_filter_from_json.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_id.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_id.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_ids.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_ids.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_author.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_author.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_authors.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_authors.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_kind.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_kinds.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_kinds.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_event.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_events.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_events.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_pubkey.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_pubkeys.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_pubkeys.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_search.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_search.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_since.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_since.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_until.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_until.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_limit.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_custom_tag.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_custom_tag.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filter_as_json.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_eventid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_eventid.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_slice.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_slice.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_hex.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_hex.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_bech32.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_bech32.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_nostr_uri.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_nostr_uri.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_as_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_as_bytes.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_hex.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_bech32.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_nostr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_nostr_uri.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_unsignedevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_unsignedevent.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_unsignedevent_from_json.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_unsignedevent_from_json.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_id.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_pubkey.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_created_at.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_kind.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_tags.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_content.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_sign.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_add_signature.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_add_signature.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_as_json.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_event.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_event_from_json.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_event_from_json.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_event_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_id.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_event_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_pubkey.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_event_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_created_at.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_event_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_kind.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_event_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_tags.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_event_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_content.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_event_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_signature.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_event_verify.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_verify.restype = ctypes.c_int8
_UniFFILib.uniffi_nostr_sdk_fn_method_event_as_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_event_as_json.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_eventbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_eventbuilder.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new.argtypes = (
    ctypes.c_uint64,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_metadata.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_add_recommended_relay.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_add_recommended_relay.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_text_note.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_text_note.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_long_form_text_note.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_repost.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_repost.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_contact_list.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_contact_list.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_encrypted_direct_msg.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_encrypted_direct_msg.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_delete.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_delete.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_reaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_reaction.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_channel_metadata.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_channel_metadata.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel_msg.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel_msg.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_hide_channel_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_mute_channel_user.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_auth.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_auth.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_report.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_report.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap_request.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap_request.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_file_metadata.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_file_metadata.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_event.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_pow_event.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_event.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_pow_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_free_contact.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_contact.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_contact_new.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_contact_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_contact_alias.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_contact_alias.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_contact_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_contact_public_key.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_contact_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_contact_relay_url.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_accountmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_accountmetadata.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_accountmetadata_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_accountmetadata_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_name.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_name.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_display_name.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_display_name.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_about.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_about.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_picture.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_picture.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_nip05.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_nip05.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_free_filemetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_filemetadata.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_filemetadata_new.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_filemetadata_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_aes_256_gcm.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_aes_256_gcm.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_size.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_dimensions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_dimensions.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_magnet.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_magnet.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_blurhash.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_blurhash.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_free_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_tag.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_tag_parse.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_tag_parse.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_tag_from_enum.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_tag_from_enum.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_tag_as_enum.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_tag_as_enum.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_tag_as_vec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_tag_as_vec.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_tag_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_tag_kind.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_relayconnectionstats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_relayconnectionstats.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_attempts.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_attempts.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_success.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_success.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_connected_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_connected_at.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_free_activesubscription.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_activesubscription.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_activesubscription_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_activesubscription_id.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_activesubscription_filters.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_activesubscription_filters.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_free_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_relay.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_url.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_proxy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_proxy.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_status.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_is_connected.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_is_connected.restype = ctypes.c_int8
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_document.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_document.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_subscriptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_subscriptions.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_update_subscription_filters.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_update_subscription_filters.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_stats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_stats.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_queue.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_queue.restype = ctypes.c_uint64
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_connect.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_stop.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_terminate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_terminate.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_send_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_send_msg.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_subscribe.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_subscribe.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_unsubscribe.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_unsubscribe.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_get_events_of.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_get_events_of.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_req_events_of.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_relay_req_events_of.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_free_options.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_options.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_options_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_options_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_connection.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_send.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_send.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_ok.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_ok.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_subscription.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_subscription.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_difficulty.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_difficulty.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_req_filters_chunk_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_req_filters_chunk_size.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_timeout.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_timeout.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_send_timeout.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_send_timeout.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_options_nip46_timeout.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_options_nip46_timeout.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_free_client.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_free_client.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_constructor_client_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_client_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_constructor_client_with_opts.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_constructor_client_with_opts.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_client_update_difficulty.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_update_difficulty.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_keys.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_client_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_start.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_stop.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_is_running.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_is_running.restype = ctypes.c_int8
_UniFFILib.uniffi_nostr_sdk_fn_method_client_shutdown.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_shutdown.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_clear_already_seen_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_clear_already_seen_events.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_relays.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_relays.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_client_relay.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_relay.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_client_add_relay.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_add_relay.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_remove_relay.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_remove_relay.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_connect_relay.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_connect_relay.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_disconnect_relay.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_disconnect_relay.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_connect.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_disconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_disconnect.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_subscribe.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_subscribe.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_unsubscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_unsubscribe.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_get_events_of.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_get_events_of.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_method_client_req_events_of.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_req_events_of.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_msg.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_msg_to.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_msg_to.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_event.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_event_to.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_event_to.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_client_file_metadata.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_file_metadata.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_method_client_handle_notifications.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_method_client_handle_notifications.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_init_callback_handlenotification.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_init_callback_handlenotification.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_func_nip04_encrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_func_nip04_encrypt.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_func_nip04_decrypt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_func_nip04_decrypt.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_fn_func_verify_nip05.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_func_verify_nip05.restype = None
_UniFFILib.uniffi_nostr_sdk_fn_func_get_nip05_profile.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_func_get_nip05_profile.restype = ctypes.c_void_p
_UniFFILib.uniffi_nostr_sdk_fn_func_init_logger.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_nostr_sdk_fn_func_init_logger.restype = None
_UniFFILib.ffi_nostr_sdk_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_nostr_sdk_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_nostr_sdk_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_nostr_sdk_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_nostr_sdk_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_nostr_sdk_rustbuffer_free.restype = None
_UniFFILib.ffi_nostr_sdk_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_nostr_sdk_rustbuffer_reserve.restype = RustBuffer
_UniFFILib.uniffi_nostr_sdk_checksum_func_nip04_encrypt.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_func_nip04_encrypt.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_func_nip04_decrypt.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_func_nip04_decrypt.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_func_verify_nip05.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_func_verify_nip05.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_func_get_nip05_profile.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_func_get_nip05_profile.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_func_init_logger.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_func_init_logger.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_name.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_name.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_description.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_description.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_pubkey.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_pubkey.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_contact.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_contact.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_supported_nips.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_supported_nips.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_software.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_software.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_version.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayinformationdocument_version.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_public_key.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_public_key.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_relay_url.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_relay_url.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_name.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_name.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_url.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_url.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_description.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_nostrconnecturi_description.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_to_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_to_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_to_nostr_uri.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_to_nostr_uri.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_public_key.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_public_key.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_relays.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_profile_relays.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_imagedimensions_width.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_imagedimensions_width.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_imagedimensions_height.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_imagedimensions_height.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_timestamp_as_secs.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_timestamp_as_secs.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_timestamp_to_human_datetime.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_timestamp_to_human_datetime.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_secretkey_to_hex.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_secretkey_to_hex.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_secretkey_to_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_secretkey_to_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_publickey_to_hex.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_publickey_to_hex.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_publickey_to_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_publickey_to_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_publickey_to_nostr_uri.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_publickey_to_nostr_uri.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_keys_public_key.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_keys_public_key.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_keys_secret_key.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_keys_secret_key.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_id.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_id.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_ids.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_ids.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_author.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_author.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_authors.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_authors.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_kind.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_kind.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_kinds.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_kinds.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_event.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_event.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_events.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_events.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_pubkey.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_pubkey.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_pubkeys.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_pubkeys.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_search.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_search.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_since.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_since.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_until.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_until.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_limit.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_limit.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_custom_tag.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_custom_tag.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_as_json.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filter_as_json.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_as_bytes.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_as_bytes.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_to_hex.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_to_hex.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_to_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_to_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_to_nostr_uri.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventid_to_nostr_uri.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_id.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_id.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_pubkey.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_pubkey.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_created_at.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_created_at.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_kind.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_kind.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_tags.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_tags.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_content.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_content.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_sign.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_sign.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_add_signature.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_add_signature.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_as_json.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_unsignedevent_as_json.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_id.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_id.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_pubkey.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_pubkey.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_created_at.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_created_at.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_kind.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_kind.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_tags.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_tags.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_content.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_content.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_signature.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_signature.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_verify.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_verify.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_as_json.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_event_as_json.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_event.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_event.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_pow_event.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_pow_event.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_event.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_event.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_pow_event.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_pow_event.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_contact_alias.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_contact_alias.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_contact_public_key.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_contact_public_key.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_contact_relay_url.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_contact_relay_url.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_name.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_name.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_display_name.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_display_name.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_about.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_about.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_picture.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_picture.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_nip05.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_accountmetadata_nip05.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_aes_256_gcm.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_aes_256_gcm.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_size.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_size.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_dimensions.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_dimensions.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_magnet.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_magnet.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_blurhash.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_filemetadata_blurhash.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_tag_as_enum.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_tag_as_enum.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_tag_as_vec.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_tag_as_vec.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_tag_kind.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_tag_kind.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_attempts.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_attempts.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_success.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_success.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_connected_at.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relayconnectionstats_connected_at.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_activesubscription_id.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_activesubscription_id.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_activesubscription_filters.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_activesubscription_filters.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_url.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_url.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_proxy.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_proxy.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_status.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_status.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_is_connected.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_is_connected.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_document.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_document.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_subscriptions.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_subscriptions.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_update_subscription_filters.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_update_subscription_filters.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_stats.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_stats.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_queue.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_queue.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_connect.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_connect.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_stop.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_stop.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_terminate.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_terminate.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_send_msg.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_send_msg.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_subscribe.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_subscribe.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_unsubscribe.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_unsubscribe.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_get_events_of.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_get_events_of.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_req_events_of.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_relay_req_events_of.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_connection.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_connection.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_send.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_send.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_ok.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_ok.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_subscription.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_wait_for_subscription.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_difficulty.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_difficulty.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_req_filters_chunk_size.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_req_filters_chunk_size.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_timeout.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_timeout.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_send_timeout.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_send_timeout.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_nip46_timeout.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_options_nip46_timeout.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_update_difficulty.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_update_difficulty.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_keys.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_keys.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_start.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_start.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_stop.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_stop.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_is_running.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_is_running.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_shutdown.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_shutdown.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_clear_already_seen_events.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_clear_already_seen_events.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_relays.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_relays.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_relay.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_relay.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_add_relay.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_add_relay.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_remove_relay.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_remove_relay.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_connect_relay.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_connect_relay.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_disconnect_relay.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_disconnect_relay.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_connect.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_connect.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_disconnect.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_disconnect.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_subscribe.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_subscribe.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_unsubscribe.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_unsubscribe.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_get_events_of.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_get_events_of.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_req_events_of.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_req_events_of.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_msg.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_msg.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_msg_to.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_msg_to.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_event.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_event.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_event_to.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_send_event_to.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_file_metadata.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_file_metadata.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_handle_notifications.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_method_client_handle_notifications.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_relayinformationdocument_get.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_relayinformationdocument_get.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_nostrconnecturi_from_string.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_nostrconnecturi_from_string.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_profile_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_profile_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_profile_from_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_profile_from_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_profile_from_nostr_uri.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_profile_from_nostr_uri.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_imagedimensions_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_imagedimensions_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_timestamp_now.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_timestamp_now.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_timestamp_from_secs.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_timestamp_from_secs.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_secretkey_from_hex.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_secretkey_from_hex.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_secretkey_from_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_secretkey_from_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_publickey_from_hex.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_publickey_from_hex.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_publickey_from_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_publickey_from_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_publickey_from_nostr_uri.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_publickey_from_nostr_uri.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_public_key.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_public_key.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_sk_str.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_sk_str.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_pk_str.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_pk_str.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_generate.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_generate.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_vanity.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_vanity.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_mnemonic.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_keys_from_mnemonic.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_filter_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_filter_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_filter_from_json.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_filter_from_json.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_slice.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_slice.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_hex.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_hex.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_bech32.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_bech32.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_nostr_uri.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventid_from_nostr_uri.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_unsignedevent_from_json.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_unsignedevent_from_json.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_event_from_json.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_event_from_json.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_metadata.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_metadata.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_add_recommended_relay.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_add_recommended_relay.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_text_note.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_text_note.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_long_form_text_note.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_long_form_text_note.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_repost.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_repost.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_contact_list.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_contact_list.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_encrypted_direct_msg.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_encrypted_direct_msg.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_delete.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_delete.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_reaction.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_reaction.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_channel_metadata.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_channel_metadata.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel_msg.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel_msg.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_hide_channel_msg.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_hide_channel_msg.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_mute_channel_user.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_mute_channel_user.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_auth.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_auth.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_report.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_report.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap_request.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap_request.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_file_metadata.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_eventbuilder_file_metadata.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_contact_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_contact_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_accountmetadata_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_accountmetadata_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_filemetadata_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_filemetadata_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_tag_parse.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_tag_parse.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_tag_from_enum.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_tag_from_enum.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_options_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_options_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_client_new.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_client_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_client_with_opts.argtypes = (
)
_UniFFILib.uniffi_nostr_sdk_checksum_constructor_client_with_opts.restype = ctypes.c_uint16
_UniFFILib.ffi_nostr_sdk_uniffi_contract_version.argtypes = (
)
_UniFFILib.ffi_nostr_sdk_uniffi_contract_version.restype = ctypes.c_uint32
uniffi_check_contract_api_version(_UniFFILib)
uniffi_check_api_checksums(_UniFFILib)

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU8(value)

class FfiConverterUInt16(FfiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.readU16()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU16(value)

class FfiConverterUInt64(FfiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU64(value)

class FfiConverterBool(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def writeUnchecked(cls, value, buf):
        buf.writeU8(value)

    @staticmethod
    def lift(value):
        return value != 0

class FfiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = FfiConverterString.check(value)
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = FfiConverterString.check(value)
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

# The Duration type.
Duration = datetime.timedelta

# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class FfiConverterDuration(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.readU64()
        microseconds = buf.readU32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")
        buf.writeI64(seconds)
        buf.writeU32(nanoseconds)



class AccountMetadata:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_accountmetadata_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_accountmetadata, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def name(self, name: "str") -> "AccountMetadata":
        
        return FfiConverterTypeAccountMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_name,self._pointer,
        FfiConverterString.lower(name))
        )






    def display_name(self, display_name: "str") -> "AccountMetadata":
        
        return FfiConverterTypeAccountMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_display_name,self._pointer,
        FfiConverterString.lower(display_name))
        )






    def about(self, about: "str") -> "AccountMetadata":
        
        return FfiConverterTypeAccountMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_about,self._pointer,
        FfiConverterString.lower(about))
        )






    def picture(self, picture: "str") -> "AccountMetadata":
        
        return FfiConverterTypeAccountMetadata.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_picture,self._pointer,
        FfiConverterString.lower(picture))
        )






    def nip05(self, nip05: "str") -> "AccountMetadata":
        
        return FfiConverterTypeAccountMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_accountmetadata_nip05,self._pointer,
        FfiConverterString.lower(nip05))
        )






class FfiConverterTypeAccountMetadata:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AccountMetadata):
            raise TypeError("Expected AccountMetadata instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AccountMetadata._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ActiveSubscription:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_activesubscription, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def id(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_activesubscription_id,self._pointer,)
        )






    def filters(self, ) -> "typing.List[Filter]":
        return FfiConverterSequenceTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_activesubscription_filters,self._pointer,)
        )






class FfiConverterTypeActiveSubscription:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ActiveSubscription):
            raise TypeError("Expected ActiveSubscription instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ActiveSubscription._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Client:
    _pointer: ctypes.c_void_p
    def __init__(self, keys: "Keys"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_client_new,
        FfiConverterTypeKeys.lower(keys))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_client, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def with_opts(cls, keys: "Keys",opts: "Options"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_client_with_opts,
        FfiConverterTypeKeys.lower(keys),
        FfiConverterTypeOptions.lower(opts))
        return cls._make_instance_(pointer)



    def update_difficulty(self, difficulty: "int"):
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_update_difficulty,self._pointer,
        FfiConverterUInt8.lower(difficulty))







    def keys(self, ) -> "Keys":
        return FfiConverterTypeKeys.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_keys,self._pointer,)
        )






    def start(self, ):
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_start,self._pointer,)







    def stop(self, ):
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_stop,self._pointer,)







    def is_running(self, ) -> "bool":
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_is_running,self._pointer,)
        )






    def shutdown(self, ):
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_shutdown,self._pointer,)







    def clear_already_seen_events(self, ):
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_clear_already_seen_events,self._pointer,)







    def relays(self, ) -> "dict":
        return FfiConverterMapStringTypeRelay.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_relays,self._pointer,)
        )






    def relay(self, url: "str") -> "Relay":
        
        return FfiConverterTypeRelay.lift(
            rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_relay,self._pointer,
        FfiConverterString.lower(url))
        )






    def add_relay(self, url: "str",proxy: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
        
        if proxy is DEFAULT:
            proxy = None
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_add_relay,self._pointer,
        FfiConverterString.lower(url),
        FfiConverterOptionalString.lower(proxy))







    def remove_relay(self, url: "str"):
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_remove_relay,self._pointer,
        FfiConverterString.lower(url))







    def connect_relay(self, url: "str"):
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_connect_relay,self._pointer,
        FfiConverterString.lower(url))







    def disconnect_relay(self, url: "str"):
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_disconnect_relay,self._pointer,
        FfiConverterString.lower(url))







    def connect(self, ):
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_connect,self._pointer,)







    def disconnect(self, ):
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_disconnect,self._pointer,)







    def subscribe(self, filters: "typing.List[Filter]"):
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_subscribe,self._pointer,
        FfiConverterSequenceTypeFilter.lower(filters))







    def unsubscribe(self, ):
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_unsubscribe,self._pointer,)







    def get_events_of(self, filters: "typing.List[Filter]",timeout: "typing.Optional[Duration]") -> "typing.List[Event]":
        
        
        return FfiConverterSequenceTypeEvent.lift(
            rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_get_events_of,self._pointer,
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionalDuration.lower(timeout))
        )






    def req_events_of(self, filters: "typing.List[Filter]",timeout: "typing.Optional[Duration]"):
        
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_req_events_of,self._pointer,
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionalDuration.lower(timeout))







    def send_msg(self, msg: "ClientMessage"):
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_msg,self._pointer,
        FfiConverterTypeClientMessage.lower(msg))







    def send_msg_to(self, url: "str",msg: "ClientMessage"):
        
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_msg_to,self._pointer,
        FfiConverterString.lower(url),
        FfiConverterTypeClientMessage.lower(msg))







    def send_event(self, event: "Event") -> "EventId":
        
        return FfiConverterTypeEventId.lift(
            rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_event,self._pointer,
        FfiConverterTypeEvent.lower(event))
        )






    def send_event_to(self, url: "str",event: "Event") -> "EventId":
        
        
        return FfiConverterTypeEventId.lift(
            rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_send_event_to,self._pointer,
        FfiConverterString.lower(url),
        FfiConverterTypeEvent.lower(event))
        )






    def file_metadata(self, description: "str",metadata: "FileMetadata") -> "EventId":
        
        
        return FfiConverterTypeEventId.lift(
            rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_client_file_metadata,self._pointer,
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata.lower(metadata))
        )






    def handle_notifications(self, handler: "HandleNotification"):
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_client_handle_notifications,self._pointer,
        FfiConverterCallbackInterfaceHandleNotification.lower(handler))







class FfiConverterTypeClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Client._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Contact:
    _pointer: ctypes.c_void_p
    def __init__(self, pk: "PublicKey",relay_url: "typing.Union[object, typing.Optional[str]]" = DEFAULT,alias: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
        
        if relay_url is DEFAULT:
            relay_url = None
        
        if alias is DEFAULT:
            alias = None
        
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_contact_new,
        FfiConverterTypePublicKey.lower(pk),
        FfiConverterOptionalString.lower(relay_url),
        FfiConverterOptionalString.lower(alias))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_contact, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def alias(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_contact_alias,self._pointer,)
        )






    def public_key(self, ) -> "PublicKey":
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_contact_public_key,self._pointer,)
        )






    def relay_url(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_contact_relay_url,self._pointer,)
        )






class FfiConverterTypeContact:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Contact):
            raise TypeError("Expected Contact instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Contact._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Event:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_event, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_event_from_json,
        FfiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def id(self, ) -> "EventId":
        return FfiConverterTypeEventId.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_id,self._pointer,)
        )






    def pubkey(self, ) -> "PublicKey":
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_pubkey,self._pointer,)
        )






    def created_at(self, ) -> "Timestamp":
        return FfiConverterTypeTimestamp.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_created_at,self._pointer,)
        )






    def kind(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_kind,self._pointer,)
        )






    def tags(self, ) -> "typing.List[Tag]":
        return FfiConverterSequenceTypeTag.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_tags,self._pointer,)
        )






    def content(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_content,self._pointer,)
        )






    def signature(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_signature,self._pointer,)
        )






    def verify(self, ) -> "bool":
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_verify,self._pointer,)
        )






    def as_json(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_event_as_json,self._pointer,)
        )






class FfiConverterTypeEvent:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Event):
            raise TypeError("Expected Event instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Event._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EventBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, kind: "int",content: "str",tags: "typing.List[Tag]"):
        
        
        
        self._pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new,
        FfiConverterUInt64.lower(kind),
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_eventbuilder, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def set_metadata(cls, metadata: "AccountMetadata"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_metadata,
        FfiConverterTypeAccountMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def add_recommended_relay(cls, url: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_add_recommended_relay,
        FfiConverterString.lower(url))
        return cls._make_instance_(pointer)


    @classmethod
    def new_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_text_note,
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def long_form_text_note(cls, content: "str",tags: "typing.List[Tag]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_long_form_text_note,
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags))
        return cls._make_instance_(pointer)


    @classmethod
    def repost(cls, event_id: "EventId",public_key: "PublicKey"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_repost,
        FfiConverterTypeEventId.lower(event_id),
        FfiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)


    @classmethod
    def set_contact_list(cls, list: "typing.List[Contact]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_contact_list,
        FfiConverterSequenceTypeContact.lower(list))
        return cls._make_instance_(pointer)


    @classmethod
    def new_encrypted_direct_msg(cls, sender_keys: "Keys",receiver_pubkey: "PublicKey",content: "str",reply: "typing.Optional[EventId]"):
        
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_encrypted_direct_msg,
        FfiConverterTypeKeys.lower(sender_keys),
        FfiConverterTypePublicKey.lower(receiver_pubkey),
        FfiConverterString.lower(content),
        FfiConverterOptionalTypeEventId.lower(reply))
        return cls._make_instance_(pointer)


    @classmethod
    def delete(cls, ids: "typing.List[EventId]",reason: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
        
        if reason is DEFAULT:
            reason = None
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_delete,
        FfiConverterSequenceTypeEventId.lower(ids),
        FfiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def new_reaction(cls, event_id: "EventId",public_key: "PublicKey",content: "str"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_reaction,
        FfiConverterTypeEventId.lower(event_id),
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def new_channel(cls, metadata: "AccountMetadata"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel,
        FfiConverterTypeAccountMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def set_channel_metadata(cls, channel_id: "str",relay_url: "typing.Optional[str]",metadata: "AccountMetadata"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_set_channel_metadata,
        FfiConverterString.lower(channel_id),
        FfiConverterOptionalString.lower(relay_url),
        FfiConverterTypeAccountMetadata.lower(metadata))
        return cls._make_instance_(pointer)


    @classmethod
    def new_channel_msg(cls, channel_id: "str",relay_url: "str",content: "str"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel_msg,
        FfiConverterString.lower(channel_id),
        FfiConverterString.lower(relay_url),
        FfiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def hide_channel_msg(cls, message_id: "EventId",reason: "typing.Optional[str]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_hide_channel_msg,
        FfiConverterTypeEventId.lower(message_id),
        FfiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def mute_channel_user(cls, public_key: "PublicKey",reason: "typing.Optional[str]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_mute_channel_user,
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterOptionalString.lower(reason))
        return cls._make_instance_(pointer)


    @classmethod
    def auth(cls, challenge: "str",relay_url: "str"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_auth,
        FfiConverterString.lower(challenge),
        FfiConverterString.lower(relay_url))
        return cls._make_instance_(pointer)


    @classmethod
    def report(cls, tags: "typing.List[Tag]",content: "str"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_report,
        FfiConverterSequenceTypeTag.lower(tags),
        FfiConverterString.lower(content))
        return cls._make_instance_(pointer)


    @classmethod
    def new_zap_request(cls, pubkey: "PublicKey",event_id: "typing.Optional[EventId]",amount: "typing.Optional[int]",lnurl: "typing.Optional[str]"):
        
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap_request,
        FfiConverterTypePublicKey.lower(pubkey),
        FfiConverterOptionalTypeEventId.lower(event_id),
        FfiConverterOptionalUInt64.lower(amount),
        FfiConverterOptionalString.lower(lnurl))
        return cls._make_instance_(pointer)


    @classmethod
    def new_zap(cls, bolt11: "str",preimage: "typing.Optional[str]",zap_request: "Event"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap,
        FfiConverterString.lower(bolt11),
        FfiConverterOptionalString.lower(preimage),
        FfiConverterTypeEvent.lower(zap_request))
        return cls._make_instance_(pointer)


    @classmethod
    def file_metadata(cls, description: "str",metadata: "FileMetadata"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventbuilder_file_metadata,
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata.lower(metadata))
        return cls._make_instance_(pointer)



    def to_event(self, keys: "Keys") -> "Event":
        
        return FfiConverterTypeEvent.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_event,self._pointer,
        FfiConverterTypeKeys.lower(keys))
        )






    def to_pow_event(self, keys: "Keys",difficulty: "int") -> "Event":
        
        
        return FfiConverterTypeEvent.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_pow_event,self._pointer,
        FfiConverterTypeKeys.lower(keys),
        FfiConverterUInt8.lower(difficulty))
        )






    def to_unsigned_event(self, public_key: "PublicKey") -> "UnsignedEvent":
        
        return FfiConverterTypeUnsignedEvent.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_event,self._pointer,
        FfiConverterTypePublicKey.lower(public_key))
        )






    def to_unsigned_pow_event(self, public_key: "PublicKey",difficulty: "int") -> "UnsignedEvent":
        
        
        return FfiConverterTypeUnsignedEvent.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_pow_event,self._pointer,
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterUInt8.lower(difficulty))
        )






class FfiConverterTypeEventBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EventBuilder):
            raise TypeError("Expected EventBuilder instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EventBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EventId:
    _pointer: ctypes.c_void_p
    def __init__(self, pubkey: "PublicKey",created_at: "Timestamp",kind: "int",tags: "typing.List[typing.List[str]]",content: "str"):
        
        
        
        
        
        self._pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_new,
        FfiConverterTypePublicKey.lower(pubkey),
        FfiConverterTypeTimestamp.lower(created_at),
        FfiConverterUInt64.lower(kind),
        FfiConverterSequenceSequenceString.lower(tags),
        FfiConverterString.lower(content))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_eventid, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_slice(cls, bytes: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_slice,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_hex(cls, hex: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_hex,
        FfiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bech32(cls, id: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_bech32,
        FfiConverterString.lower(id))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_eventid_from_nostr_uri,
        FfiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def as_bytes(self, ) -> "typing.List[int]":
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_as_bytes,self._pointer,)
        )






    def to_hex(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_hex,self._pointer,)
        )






    def to_bech32(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_bech32,self._pointer,)
        )






    def to_nostr_uri(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_eventid_to_nostr_uri,self._pointer,)
        )






class FfiConverterTypeEventId:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EventId):
            raise TypeError("Expected EventId instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EventId._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class FileMetadata:
    _pointer: ctypes.c_void_p
    def __init__(self, url: "str",mime_type: "str",hash: "str"):
        
        
        
        self._pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_filemetadata_new,
        FfiConverterString.lower(url),
        FfiConverterString.lower(mime_type),
        FfiConverterString.lower(hash))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_filemetadata, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def aes_256_gcm(self, key: "str",iv: "str") -> "FileMetadata":
        
        
        return FfiConverterTypeFileMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_aes_256_gcm,self._pointer,
        FfiConverterString.lower(key),
        FfiConverterString.lower(iv))
        )






    def size(self, size: "int") -> "FileMetadata":
        
        return FfiConverterTypeFileMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_size,self._pointer,
        FfiConverterUInt64.lower(size))
        )






    def dimensions(self, dim: "ImageDimensions") -> "FileMetadata":
        
        return FfiConverterTypeFileMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_dimensions,self._pointer,
        FfiConverterTypeImageDimensions.lower(dim))
        )






    def magnet(self, magnet: "str") -> "FileMetadata":
        
        return FfiConverterTypeFileMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_magnet,self._pointer,
        FfiConverterString.lower(magnet))
        )






    def blurhash(self, blurhash: "str") -> "FileMetadata":
        
        return FfiConverterTypeFileMetadata.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filemetadata_blurhash,self._pointer,
        FfiConverterString.lower(blurhash))
        )






class FfiConverterTypeFileMetadata:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, FileMetadata):
            raise TypeError("Expected FileMetadata instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return FileMetadata._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Filter:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_filter_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_filter, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_filter_from_json,
        FfiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def id(self, id: "str") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_id,self._pointer,
        FfiConverterString.lower(id))
        )






    def ids(self, ids: "typing.List[str]") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_ids,self._pointer,
        FfiConverterSequenceString.lower(ids))
        )






    def author(self, author: "str") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_author,self._pointer,
        FfiConverterString.lower(author))
        )






    def authors(self, authors: "typing.List[str]") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_authors,self._pointer,
        FfiConverterSequenceString.lower(authors))
        )






    def kind(self, kind: "int") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_kind,self._pointer,
        FfiConverterUInt64.lower(kind))
        )






    def kinds(self, kinds: "typing.List[int]") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_kinds,self._pointer,
        FfiConverterSequenceUInt64.lower(kinds))
        )






    def event(self, event_id: "EventId") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_event,self._pointer,
        FfiConverterTypeEventId.lower(event_id))
        )






    def events(self, ids: "typing.List[EventId]") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_events,self._pointer,
        FfiConverterSequenceTypeEventId.lower(ids))
        )






    def pubkey(self, pubkey: "PublicKey") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_pubkey,self._pointer,
        FfiConverterTypePublicKey.lower(pubkey))
        )






    def pubkeys(self, pubkeys: "typing.List[PublicKey]") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_pubkeys,self._pointer,
        FfiConverterSequenceTypePublicKey.lower(pubkeys))
        )






    def search(self, text: "str") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_search,self._pointer,
        FfiConverterString.lower(text))
        )






    def since(self, timestamp: "Timestamp") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_since,self._pointer,
        FfiConverterTypeTimestamp.lower(timestamp))
        )






    def until(self, timestamp: "Timestamp") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_until,self._pointer,
        FfiConverterTypeTimestamp.lower(timestamp))
        )






    def limit(self, limit: "int") -> "Filter":
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_limit,self._pointer,
        FfiConverterUInt64.lower(limit))
        )






    def custom_tag(self, tag: "Alphabet",content: "typing.List[str]") -> "Filter":
        
        
        return FfiConverterTypeFilter.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_custom_tag,self._pointer,
        FfiConverterTypeAlphabet.lower(tag),
        FfiConverterSequenceString.lower(content))
        )






    def as_json(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_filter_as_json,self._pointer,)
        )






class FfiConverterTypeFilter:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Filter):
            raise TypeError("Expected Filter instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Filter._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ImageDimensions:
    _pointer: ctypes.c_void_p
    def __init__(self, width: "int",height: "int"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_imagedimensions_new,
        FfiConverterUInt64.lower(width),
        FfiConverterUInt64.lower(height))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_imagedimensions, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def width(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_imagedimensions_width,self._pointer,)
        )






    def height(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_imagedimensions_height,self._pointer,)
        )






class FfiConverterTypeImageDimensions:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ImageDimensions):
            raise TypeError("Expected ImageDimensions instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ImageDimensions._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Keys:
    _pointer: ctypes.c_void_p
    def __init__(self, sk: "SecretKey"):
        
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_new,
        FfiConverterTypeSecretKey.lower(sk))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_keys, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_public_key(cls, pk: "PublicKey"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_public_key,
        FfiConverterTypePublicKey.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_sk_str(cls, sk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_sk_str,
        FfiConverterString.lower(sk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_pk_str(cls, pk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_pk_str,
        FfiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_generate,)
        return cls._make_instance_(pointer)


    @classmethod
    def vanity(cls, prefixes: "typing.List[str]",bech32: "bool",num_cores: "int"):
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_vanity,
        FfiConverterSequenceString.lower(prefixes),
        FfiConverterBool.lower(bech32),
        FfiConverterUInt8.lower(num_cores))
        return cls._make_instance_(pointer)


    @classmethod
    def from_mnemonic(cls, mnemonic: "str",passphrase: "typing.Union[object, typing.Optional[str]]" = DEFAULT):
        
        if passphrase is DEFAULT:
            passphrase = None
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_keys_from_mnemonic,
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionalString.lower(passphrase))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_keys_public_key,self._pointer,)
        )






    def secret_key(self, ) -> "SecretKey":
        return FfiConverterTypeSecretKey.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_keys_secret_key,self._pointer,)
        )






class FfiConverterTypeKeys:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Keys):
            raise TypeError("Expected Keys instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Keys._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NostrConnectUri:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_nostrconnecturi, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_nostrconnecturi_from_string,
        FfiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_public_key,self._pointer,)
        )






    def relay_url(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_relay_url,self._pointer,)
        )






    def name(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_name,self._pointer,)
        )






    def url(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_url,self._pointer,)
        )






    def description(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_nostrconnecturi_description,self._pointer,)
        )






class FfiConverterTypeNostrConnectURI:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NostrConnectUri):
            raise TypeError("Expected NostrConnectUri instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NostrConnectUri._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Options:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_options_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_options, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def wait_for_connection(self, wait: "bool") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_connection,self._pointer,
        FfiConverterBool.lower(wait))
        )






    def wait_for_send(self, wait: "bool") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_send,self._pointer,
        FfiConverterBool.lower(wait))
        )






    def wait_for_ok(self, wait: "bool") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_ok,self._pointer,
        FfiConverterBool.lower(wait))
        )






    def wait_for_subscription(self, wait: "bool") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_wait_for_subscription,self._pointer,
        FfiConverterBool.lower(wait))
        )






    def difficulty(self, difficulty: "int") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_difficulty,self._pointer,
        FfiConverterUInt8.lower(difficulty))
        )






    def req_filters_chunk_size(self, req_filters_chunk_size: "int") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_req_filters_chunk_size,self._pointer,
        FfiConverterUInt8.lower(req_filters_chunk_size))
        )






    def timeout(self, timeout: "typing.Optional[Duration]") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_timeout,self._pointer,
        FfiConverterOptionalDuration.lower(timeout))
        )






    def send_timeout(self, send_timeout: "typing.Optional[Duration]") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_send_timeout,self._pointer,
        FfiConverterOptionalDuration.lower(send_timeout))
        )






    def nip46_timeout(self, nip46_timeout: "typing.Optional[Duration]") -> "Options":
        
        return FfiConverterTypeOptions.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_options_nip46_timeout,self._pointer,
        FfiConverterOptionalDuration.lower(nip46_timeout))
        )






class FfiConverterTypeOptions:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Options):
            raise TypeError("Expected Options instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Options._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Profile:
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "PublicKey",relays: "typing.List[str]"):
        
        
        self._pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_new,
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterSequenceString.lower(relays))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_profile, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bech32(cls, bech32: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_from_bech32,
        FfiConverterString.lower(bech32))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_profile_from_nostr_uri,
        FfiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def to_bech32(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_profile_to_bech32,self._pointer,)
        )






    def to_nostr_uri(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_profile_to_nostr_uri,self._pointer,)
        )






    def public_key(self, ) -> "PublicKey":
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_profile_public_key,self._pointer,)
        )






    def relays(self, ) -> "typing.List[str]":
        return FfiConverterSequenceString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_profile_relays,self._pointer,)
        )






class FfiConverterTypeProfile:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Profile):
            raise TypeError("Expected Profile instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Profile._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PublicKey:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_publickey, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_hex(cls, hex: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_hex,
        FfiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bech32(cls, pk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_bech32,
        FfiConverterString.lower(pk))
        return cls._make_instance_(pointer)


    @classmethod
    def from_nostr_uri(cls, uri: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_publickey_from_nostr_uri,
        FfiConverterString.lower(uri))
        return cls._make_instance_(pointer)



    def to_hex(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_hex,self._pointer,)
        )






    def to_bech32(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_bech32,self._pointer,)
        )






    def to_nostr_uri(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_publickey_to_nostr_uri,self._pointer,)
        )






class FfiConverterTypePublicKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PublicKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Relay:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_relay, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def url(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_url,self._pointer,)
        )






    def proxy(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_proxy,self._pointer,)
        )






    def status(self, ) -> "RelayStatus":
        return FfiConverterTypeRelayStatus.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_status,self._pointer,)
        )






    def is_connected(self, ) -> "bool":
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_is_connected,self._pointer,)
        )






    def document(self, ) -> "RelayInformationDocument":
        return FfiConverterTypeRelayInformationDocument.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_document,self._pointer,)
        )






    def subscriptions(self, ) -> "dict":
        return FfiConverterMapStringTypeActiveSubscription.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_subscriptions,self._pointer,)
        )






    def update_subscription_filters(self, internal_id: "str",filters: "typing.List[Filter]"):
        
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_update_subscription_filters,self._pointer,
        FfiConverterString.lower(internal_id),
        FfiConverterSequenceTypeFilter.lower(filters))







    def stats(self, ) -> "RelayConnectionStats":
        return FfiConverterTypeRelayConnectionStats.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_stats,self._pointer,)
        )






    def queue(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_queue,self._pointer,)
        )






    def connect(self, wait_for_connection: "bool"):
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_connect,self._pointer,
        FfiConverterBool.lower(wait_for_connection))







    def stop(self, ):
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_relay_stop,self._pointer,)







    def terminate(self, ):
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_relay_terminate,self._pointer,)







    def send_msg(self, msg: "ClientMessage",wait: "typing.Optional[Duration]"):
        
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_relay_send_msg,self._pointer,
        FfiConverterTypeClientMessage.lower(msg),
        FfiConverterOptionalDuration.lower(wait))







    def subscribe(self, filters: "typing.List[Filter]",wait: "typing.Optional[Duration]"):
        
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_relay_subscribe,self._pointer,
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionalDuration.lower(wait))







    def unsubscribe(self, wait: "typing.Optional[Duration]"):
        
        rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_relay_unsubscribe,self._pointer,
        FfiConverterOptionalDuration.lower(wait))







    def get_events_of(self, filters: "typing.List[Filter]",timeout: "typing.Optional[Duration]") -> "typing.List[Event]":
        
        
        return FfiConverterSequenceTypeEvent.lift(
            rust_call_with_error(
    FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_method_relay_get_events_of,self._pointer,
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionalDuration.lower(timeout))
        )






    def req_events_of(self, filters: "typing.List[Filter]",timeout: "typing.Optional[Duration]"):
        
        
        rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relay_req_events_of,self._pointer,
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionalDuration.lower(timeout))







class FfiConverterTypeRelay:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Relay):
            raise TypeError("Expected Relay instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Relay._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RelayConnectionStats:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_relayconnectionstats, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def attempts(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_attempts,self._pointer,)
        )






    def success(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_success,self._pointer,)
        )






    def connected_at(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayconnectionstats_connected_at,self._pointer,)
        )






class FfiConverterTypeRelayConnectionStats:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RelayConnectionStats):
            raise TypeError("Expected RelayConnectionStats instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RelayConnectionStats._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RelayInformationDocument:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_relayinformationdocument, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def get(cls, url: "str",proxy: "typing.Optional[str]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_relayinformationdocument_get,
        FfiConverterString.lower(url),
        FfiConverterOptionalString.lower(proxy))
        return cls._make_instance_(pointer)



    def name(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_name,self._pointer,)
        )






    def description(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_description,self._pointer,)
        )






    def pubkey(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_pubkey,self._pointer,)
        )






    def contact(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_contact,self._pointer,)
        )






    def supported_nips(self, ) -> "typing.Optional[typing.List[int]]":
        return FfiConverterOptionalSequenceUInt16.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_supported_nips,self._pointer,)
        )






    def software(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_software,self._pointer,)
        )






    def version(self, ) -> "typing.Optional[str]":
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_relayinformationdocument_version,self._pointer,)
        )






class FfiConverterTypeRelayInformationDocument:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RelayInformationDocument):
            raise TypeError("Expected RelayInformationDocument instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RelayInformationDocument._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SecretKey:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_secretkey, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_hex(cls, hex: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_secretkey_from_hex,
        FfiConverterString.lower(hex))
        return cls._make_instance_(pointer)


    @classmethod
    def from_bech32(cls, pk: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_secretkey_from_bech32,
        FfiConverterString.lower(pk))
        return cls._make_instance_(pointer)



    def to_hex(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_secretkey_to_hex,self._pointer,)
        )






    def to_bech32(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_secretkey_to_bech32,self._pointer,)
        )






class FfiConverterTypeSecretKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SecretKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Tag:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_tag, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def parse(cls, data: "typing.List[str]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_tag_parse,
        FfiConverterSequenceString.lower(data))
        return cls._make_instance_(pointer)


    @classmethod
    def from_enum(cls, e: "TagEnum"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_tag_from_enum,
        FfiConverterTypeTagEnum.lower(e))
        return cls._make_instance_(pointer)



    def as_enum(self, ) -> "TagEnum":
        return FfiConverterTypeTagEnum.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_tag_as_enum,self._pointer,)
        )






    def as_vec(self, ) -> "typing.List[str]":
        return FfiConverterSequenceString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_tag_as_vec,self._pointer,)
        )






    def kind(self, ) -> "TagKind":
        return FfiConverterTypeTagKind.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_tag_kind,self._pointer,)
        )






class FfiConverterTypeTag:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Tag):
            raise TypeError("Expected Tag instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Tag._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Timestamp:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_timestamp, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def now(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_timestamp_now,)
        return cls._make_instance_(pointer)


    @classmethod
    def from_secs(cls, secs: "int"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.uniffi_nostr_sdk_fn_constructor_timestamp_from_secs,
        FfiConverterUInt64.lower(secs))
        return cls._make_instance_(pointer)



    def as_secs(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_timestamp_as_secs,self._pointer,)
        )






    def to_human_datetime(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_timestamp_to_human_datetime,self._pointer,)
        )






class FfiConverterTypeTimestamp:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Timestamp):
            raise TypeError("Expected Timestamp instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Timestamp._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UnsignedEvent:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_free_unsignedevent, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_json(cls, json: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_constructor_unsignedevent_from_json,
        FfiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def id(self, ) -> "EventId":
        return FfiConverterTypeEventId.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_id,self._pointer,)
        )






    def pubkey(self, ) -> "PublicKey":
        return FfiConverterTypePublicKey.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_pubkey,self._pointer,)
        )






    def created_at(self, ) -> "Timestamp":
        return FfiConverterTypeTimestamp.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_created_at,self._pointer,)
        )






    def kind(self, ) -> "int":
        return FfiConverterUInt64.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_kind,self._pointer,)
        )






    def tags(self, ) -> "typing.List[Tag]":
        return FfiConverterSequenceTypeTag.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_tags,self._pointer,)
        )






    def content(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_content,self._pointer,)
        )






    def sign(self, keys: "Keys") -> "Event":
        
        return FfiConverterTypeEvent.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_sign,self._pointer,
        FfiConverterTypeKeys.lower(keys))
        )






    def add_signature(self, sig: "str") -> "Event":
        
        return FfiConverterTypeEvent.lift(
            rust_call_with_error(
    FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_add_signature,self._pointer,
        FfiConverterString.lower(sig))
        )






    def as_json(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_nostr_sdk_fn_method_unsignedevent_as_json,self._pointer,)
        )






class FfiConverterTypeUnsignedEvent:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UnsignedEvent):
            raise TypeError("Expected UnsignedEvent instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UnsignedEvent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer





class Alphabet(enum.Enum):
    A = 1
    B = 2
    C = 3
    D = 4
    E = 5
    F = 6
    G = 7
    H = 8
    I = 9
    J = 10
    K = 11
    L = 12
    M = 13
    N = 14
    O = 15
    P = 16
    Q = 17
    R = 18
    S = 19
    T = 20
    U = 21
    V = 22
    W = 23
    X = 24
    Y = 25
    Z = 26
    


class FfiConverterTypeAlphabet(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Alphabet.A
        if variant == 2:
            return Alphabet.B
        if variant == 3:
            return Alphabet.C
        if variant == 4:
            return Alphabet.D
        if variant == 5:
            return Alphabet.E
        if variant == 6:
            return Alphabet.F
        if variant == 7:
            return Alphabet.G
        if variant == 8:
            return Alphabet.H
        if variant == 9:
            return Alphabet.I
        if variant == 10:
            return Alphabet.J
        if variant == 11:
            return Alphabet.K
        if variant == 12:
            return Alphabet.L
        if variant == 13:
            return Alphabet.M
        if variant == 14:
            return Alphabet.N
        if variant == 15:
            return Alphabet.O
        if variant == 16:
            return Alphabet.P
        if variant == 17:
            return Alphabet.Q
        if variant == 18:
            return Alphabet.R
        if variant == 19:
            return Alphabet.S
        if variant == 20:
            return Alphabet.T
        if variant == 21:
            return Alphabet.U
        if variant == 22:
            return Alphabet.V
        if variant == 23:
            return Alphabet.W
        if variant == 24:
            return Alphabet.X
        if variant == 25:
            return Alphabet.Y
        if variant == 26:
            return Alphabet.Z
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Alphabet.A:
            buf.writeI32(1)
        if value == Alphabet.B:
            buf.writeI32(2)
        if value == Alphabet.C:
            buf.writeI32(3)
        if value == Alphabet.D:
            buf.writeI32(4)
        if value == Alphabet.E:
            buf.writeI32(5)
        if value == Alphabet.F:
            buf.writeI32(6)
        if value == Alphabet.G:
            buf.writeI32(7)
        if value == Alphabet.H:
            buf.writeI32(8)
        if value == Alphabet.I:
            buf.writeI32(9)
        if value == Alphabet.J:
            buf.writeI32(10)
        if value == Alphabet.K:
            buf.writeI32(11)
        if value == Alphabet.L:
            buf.writeI32(12)
        if value == Alphabet.M:
            buf.writeI32(13)
        if value == Alphabet.N:
            buf.writeI32(14)
        if value == Alphabet.O:
            buf.writeI32(15)
        if value == Alphabet.P:
            buf.writeI32(16)
        if value == Alphabet.Q:
            buf.writeI32(17)
        if value == Alphabet.R:
            buf.writeI32(18)
        if value == Alphabet.S:
            buf.writeI32(19)
        if value == Alphabet.T:
            buf.writeI32(20)
        if value == Alphabet.U:
            buf.writeI32(21)
        if value == Alphabet.V:
            buf.writeI32(22)
        if value == Alphabet.W:
            buf.writeI32(23)
        if value == Alphabet.X:
            buf.writeI32(24)
        if value == Alphabet.Y:
            buf.writeI32(25)
        if value == Alphabet.Z:
            buf.writeI32(26)






class ClientMessage:
    def __init__(self):
        raise RuntimeError("ClientMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EV:
        def __init__(self,event):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.EV(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_ev():
                return False
            if self.event != other.event:
                return False
            return True
    class REQ:
        def __init__(self,subscription_id, filters):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.REQ(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_req():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class COUNT:
        def __init__(self,subscription_id, filters):
            
            self.subscription_id = subscription_id
            self.filters = filters
            

        def __str__(self):
            return "ClientMessage.COUNT(subscription_id={}, filters={})".format(self.subscription_id, self.filters)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.filters != other.filters:
                return False
            return True
    class CLOSE:
        def __init__(self,subscription_id):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "ClientMessage.CLOSE(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_close():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class AUTH:
        def __init__(self,event):
            
            self.event = event
            

        def __str__(self):
            return "ClientMessage.AUTH(event={})".format(self.event)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.event != other.event:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ev(self) -> bool:
        return isinstance(self, ClientMessage.EV)
    def is_req(self) -> bool:
        return isinstance(self, ClientMessage.REQ)
    def is_count(self) -> bool:
        return isinstance(self, ClientMessage.COUNT)
    def is_close(self) -> bool:
        return isinstance(self, ClientMessage.CLOSE)
    def is_auth(self) -> bool:
        return isinstance(self, ClientMessage.AUTH)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClientMessage.EV = type("ClientMessage.EV", (ClientMessage.EV, ClientMessage,), {})  # type: ignore
ClientMessage.REQ = type("ClientMessage.REQ", (ClientMessage.REQ, ClientMessage,), {})  # type: ignore
ClientMessage.COUNT = type("ClientMessage.COUNT", (ClientMessage.COUNT, ClientMessage,), {})  # type: ignore
ClientMessage.CLOSE = type("ClientMessage.CLOSE", (ClientMessage.CLOSE, ClientMessage,), {})  # type: ignore
ClientMessage.AUTH = type("ClientMessage.AUTH", (ClientMessage.AUTH, ClientMessage,), {})  # type: ignore




class FfiConverterTypeClientMessage(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ClientMessage.EV(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ClientMessage.REQ(
                FfiConverterString.read(buf),
                FfiConverterSequenceString.read(buf),
            )
        if variant == 3:
            return ClientMessage.COUNT(
                FfiConverterString.read(buf),
                FfiConverterSequenceString.read(buf),
            )
        if variant == 4:
            return ClientMessage.CLOSE(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return ClientMessage.AUTH(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ev():
            buf.writeI32(1)
            FfiConverterString.write(value.event, buf)
        if value.is_req():
            buf.writeI32(2)
            FfiConverterString.write(value.subscription_id, buf)
            FfiConverterSequenceString.write(value.filters, buf)
        if value.is_count():
            buf.writeI32(3)
            FfiConverterString.write(value.subscription_id, buf)
            FfiConverterSequenceString.write(value.filters, buf)
        if value.is_close():
            buf.writeI32(4)
            FfiConverterString.write(value.subscription_id, buf)
        if value.is_auth():
            buf.writeI32(5)
            FfiConverterString.write(value.event, buf)






class LogLevel(enum.Enum):
    ERROR = 1
    WARN = 2
    INFO = 3
    DEBUG = 4
    TRACE = 5
    


class FfiConverterTypeLogLevel(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return LogLevel.ERROR
        if variant == 2:
            return LogLevel.WARN
        if variant == 3:
            return LogLevel.INFO
        if variant == 4:
            return LogLevel.DEBUG
        if variant == 5:
            return LogLevel.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == LogLevel.ERROR:
            buf.writeI32(1)
        if value == LogLevel.WARN:
            buf.writeI32(2)
        if value == LogLevel.INFO:
            buf.writeI32(3)
        if value == LogLevel.DEBUG:
            buf.writeI32(4)
        if value == LogLevel.TRACE:
            buf.writeI32(5)



# NostrError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NostrError(Exception):
    pass

UniFFITempNostrError = NostrError

class NostrError:  # type: ignore
    class Generic(UniFFITempNostrError):
        def __init__(self, err):
            super().__init__(", ".join([
                "err={!r}".format(err),
            ]))
            self.err = err
        def __repr__(self):
            return "NostrError.Generic({})".format(str(self))
    UniFFITempNostrError.Generic = Generic  # type: ignore

NostrError = UniFFITempNostrError  # type: ignore
del UniFFITempNostrError


class FfiConverterTypeNostrError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return NostrError.Generic(
                err=FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, NostrError.Generic):
            buf.writeI32(1)
            FfiConverterString.write(value.err, buf)


# NostrSdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NostrSdkError(Exception):
    pass

UniFFITempNostrSdkError = NostrSdkError

class NostrSdkError:  # type: ignore
    class Generic(UniFFITempNostrSdkError):
        def __init__(self, err):
            super().__init__(", ".join([
                "err={!r}".format(err),
            ]))
            self.err = err
        def __repr__(self):
            return "NostrSdkError.Generic({})".format(str(self))
    UniFFITempNostrSdkError.Generic = Generic  # type: ignore

NostrSdkError = UniFFITempNostrSdkError  # type: ignore
del UniFFITempNostrSdkError


class FfiConverterTypeNostrSdkError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return NostrSdkError.Generic(
                err=FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, NostrSdkError.Generic):
            buf.writeI32(1)
            FfiConverterString.write(value.err, buf)





class RelayMessage:
    def __init__(self):
        raise RuntimeError("RelayMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class EV:
        def __init__(self,subscription_id, event):
            
            self.subscription_id = subscription_id
            self.event = event
            

        def __str__(self):
            return "RelayMessage.EV(subscription_id={}, event={})".format(self.subscription_id, self.event)

        def __eq__(self, other):
            if not other.is_ev():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.event != other.event:
                return False
            return True
    class NOTICE:
        def __init__(self,message):
            
            self.message = message
            

        def __str__(self):
            return "RelayMessage.NOTICE(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_notice():
                return False
            if self.message != other.message:
                return False
            return True
    class END_OF_STORED_EVENTS:
        def __init__(self,subscription_id):
            
            self.subscription_id = subscription_id
            

        def __str__(self):
            return "RelayMessage.END_OF_STORED_EVENTS(subscription_id={})".format(self.subscription_id)

        def __eq__(self, other):
            if not other.is_end_of_stored_events():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            return True
    class OK:
        def __init__(self,event_id, status, message):
            
            self.event_id = event_id
            self.status = status
            self.message = message
            

        def __str__(self):
            return "RelayMessage.OK(event_id={}, status={}, message={})".format(self.event_id, self.status, self.message)

        def __eq__(self, other):
            if not other.is_ok():
                return False
            if self.event_id != other.event_id:
                return False
            if self.status != other.status:
                return False
            if self.message != other.message:
                return False
            return True
    class AUTH:
        def __init__(self,challenge):
            
            self.challenge = challenge
            

        def __str__(self):
            return "RelayMessage.AUTH(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_auth():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class COUNT:
        def __init__(self,subscription_id, count):
            
            self.subscription_id = subscription_id
            self.count = count
            

        def __str__(self):
            return "RelayMessage.COUNT(subscription_id={}, count={})".format(self.subscription_id, self.count)

        def __eq__(self, other):
            if not other.is_count():
                return False
            if self.subscription_id != other.subscription_id:
                return False
            if self.count != other.count:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ev(self) -> bool:
        return isinstance(self, RelayMessage.EV)
    def is_notice(self) -> bool:
        return isinstance(self, RelayMessage.NOTICE)
    def is_end_of_stored_events(self) -> bool:
        return isinstance(self, RelayMessage.END_OF_STORED_EVENTS)
    def is_ok(self) -> bool:
        return isinstance(self, RelayMessage.OK)
    def is_auth(self) -> bool:
        return isinstance(self, RelayMessage.AUTH)
    def is_count(self) -> bool:
        return isinstance(self, RelayMessage.COUNT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RelayMessage.EV = type("RelayMessage.EV", (RelayMessage.EV, RelayMessage,), {})  # type: ignore
RelayMessage.NOTICE = type("RelayMessage.NOTICE", (RelayMessage.NOTICE, RelayMessage,), {})  # type: ignore
RelayMessage.END_OF_STORED_EVENTS = type("RelayMessage.END_OF_STORED_EVENTS", (RelayMessage.END_OF_STORED_EVENTS, RelayMessage,), {})  # type: ignore
RelayMessage.OK = type("RelayMessage.OK", (RelayMessage.OK, RelayMessage,), {})  # type: ignore
RelayMessage.AUTH = type("RelayMessage.AUTH", (RelayMessage.AUTH, RelayMessage,), {})  # type: ignore
RelayMessage.COUNT = type("RelayMessage.COUNT", (RelayMessage.COUNT, RelayMessage,), {})  # type: ignore




class FfiConverterTypeRelayMessage(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RelayMessage.EV(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return RelayMessage.NOTICE(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return RelayMessage.END_OF_STORED_EVENTS(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return RelayMessage.OK(
                FfiConverterString.read(buf),
                FfiConverterBool.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return RelayMessage.AUTH(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return RelayMessage.COUNT(
                FfiConverterString.read(buf),
                FfiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ev():
            buf.writeI32(1)
            FfiConverterString.write(value.subscription_id, buf)
            FfiConverterString.write(value.event, buf)
        if value.is_notice():
            buf.writeI32(2)
            FfiConverterString.write(value.message, buf)
        if value.is_end_of_stored_events():
            buf.writeI32(3)
            FfiConverterString.write(value.subscription_id, buf)
        if value.is_ok():
            buf.writeI32(4)
            FfiConverterString.write(value.event_id, buf)
            FfiConverterBool.write(value.status, buf)
            FfiConverterString.write(value.message, buf)
        if value.is_auth():
            buf.writeI32(5)
            FfiConverterString.write(value.challenge, buf)
        if value.is_count():
            buf.writeI32(6)
            FfiConverterString.write(value.subscription_id, buf)
            FfiConverterUInt64.write(value.count, buf)






class RelayStatus(enum.Enum):
    INITIALIZED = 1
    CONNECTED = 2
    CONNECTING = 3
    DISCONNECTED = 4
    STOPPED = 5
    TERMINATED = 6
    


class FfiConverterTypeRelayStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RelayStatus.INITIALIZED
        if variant == 2:
            return RelayStatus.CONNECTED
        if variant == 3:
            return RelayStatus.CONNECTING
        if variant == 4:
            return RelayStatus.DISCONNECTED
        if variant == 5:
            return RelayStatus.STOPPED
        if variant == 6:
            return RelayStatus.TERMINATED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == RelayStatus.INITIALIZED:
            buf.writeI32(1)
        if value == RelayStatus.CONNECTED:
            buf.writeI32(2)
        if value == RelayStatus.CONNECTING:
            buf.writeI32(3)
        if value == RelayStatus.DISCONNECTED:
            buf.writeI32(4)
        if value == RelayStatus.STOPPED:
            buf.writeI32(5)
        if value == RelayStatus.TERMINATED:
            buf.writeI32(6)






class TagEnum:
    def __init__(self):
        raise RuntimeError("TagEnum cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UNKNOWN:
        def __init__(self,kind, data):
            
            self.kind = kind
            self.data = data
            

        def __str__(self):
            return "TagEnum.UNKNOWN(kind={}, data={})".format(self.kind, self.data)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.kind != other.kind:
                return False
            if self.data != other.data:
                return False
            return True
    class E:
        def __init__(self,event_id, relay_url, marker):
            
            self.event_id = event_id
            self.relay_url = relay_url
            self.marker = marker
            

        def __str__(self):
            return "TagEnum.E(event_id={}, relay_url={}, marker={})".format(self.event_id, self.relay_url, self.marker)

        def __eq__(self, other):
            if not other.is_e():
                return False
            if self.event_id != other.event_id:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            return True
    class PUB_KEY:
        def __init__(self,public_key, relay_url):
            
            self.public_key = public_key
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.PUB_KEY(public_key={}, relay_url={})".format(self.public_key, self.relay_url)

        def __eq__(self, other):
            if not other.is_pub_key():
                return False
            if self.public_key != other.public_key:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class EVENT_REPORT:
        def __init__(self,event_id, report):
            
            self.event_id = event_id
            self.report = report
            

        def __str__(self):
            return "TagEnum.EVENT_REPORT(event_id={}, report={})".format(self.event_id, self.report)

        def __eq__(self, other):
            if not other.is_event_report():
                return False
            if self.event_id != other.event_id:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_REPORT:
        def __init__(self,public_key, report):
            
            self.public_key = public_key
            self.report = report
            

        def __str__(self):
            return "TagEnum.PUB_KEY_REPORT(public_key={}, report={})".format(self.public_key, self.report)

        def __eq__(self, other):
            if not other.is_pub_key_report():
                return False
            if self.public_key != other.public_key:
                return False
            if self.report != other.report:
                return False
            return True
    class PUB_KEY_LIVE_EVENT:
        def __init__(self,pk, relay_url, marker, proof):
            
            self.pk = pk
            self.relay_url = relay_url
            self.marker = marker
            self.proof = proof
            

        def __str__(self):
            return "TagEnum.PUB_KEY_LIVE_EVENT(pk={}, relay_url={}, marker={}, proof={})".format(self.pk, self.relay_url, self.marker, self.proof)

        def __eq__(self, other):
            if not other.is_pub_key_live_event():
                return False
            if self.pk != other.pk:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.marker != other.marker:
                return False
            if self.proof != other.proof:
                return False
            return True
    class REFERENCE:
        def __init__(self,reference):
            
            self.reference = reference
            

        def __str__(self):
            return "TagEnum.REFERENCE(reference={})".format(self.reference)

        def __eq__(self, other):
            if not other.is_reference():
                return False
            if self.reference != other.reference:
                return False
            return True
    class RELAY_METADATA:
        def __init__(self,relay_url, rw):
            
            self.relay_url = relay_url
            self.rw = rw
            

        def __str__(self):
            return "TagEnum.RELAY_METADATA(relay_url={}, rw={})".format(self.relay_url, self.rw)

        def __eq__(self, other):
            if not other.is_relay_metadata():
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.rw != other.rw:
                return False
            return True
    class HASHTAG:
        def __init__(self,hashtag):
            
            self.hashtag = hashtag
            

        def __str__(self):
            return "TagEnum.HASHTAG(hashtag={})".format(self.hashtag)

        def __eq__(self, other):
            if not other.is_hashtag():
                return False
            if self.hashtag != other.hashtag:
                return False
            return True
    class GEOHASH:
        def __init__(self,geohash):
            
            self.geohash = geohash
            

        def __str__(self):
            return "TagEnum.GEOHASH(geohash={})".format(self.geohash)

        def __eq__(self, other):
            if not other.is_geohash():
                return False
            if self.geohash != other.geohash:
                return False
            return True
    class IDENTIFIER:
        def __init__(self,identifier):
            
            self.identifier = identifier
            

        def __str__(self):
            return "TagEnum.IDENTIFIER(identifier={})".format(self.identifier)

        def __eq__(self, other):
            if not other.is_identifier():
                return False
            if self.identifier != other.identifier:
                return False
            return True
    class EXTERNAL_IDENTITY:
        def __init__(self,identity, proof):
            
            self.identity = identity
            self.proof = proof
            

        def __str__(self):
            return "TagEnum.EXTERNAL_IDENTITY(identity={}, proof={})".format(self.identity, self.proof)

        def __eq__(self, other):
            if not other.is_external_identity():
                return False
            if self.identity != other.identity:
                return False
            if self.proof != other.proof:
                return False
            return True
    class A:
        def __init__(self,kind, public_key, identifier, relay_url):
            
            self.kind = kind
            self.public_key = public_key
            self.identifier = identifier
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.A(kind={}, public_key={}, identifier={}, relay_url={})".format(self.kind, self.public_key, self.identifier, self.relay_url)

        def __eq__(self, other):
            if not other.is_a():
                return False
            if self.kind != other.kind:
                return False
            if self.public_key != other.public_key:
                return False
            if self.identifier != other.identifier:
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class RELAY_URL:
        def __init__(self,relay_url):
            
            self.relay_url = relay_url
            

        def __str__(self):
            return "TagEnum.RELAY_URL(relay_url={})".format(self.relay_url)

        def __eq__(self, other):
            if not other.is_relay_url():
                return False
            if self.relay_url != other.relay_url:
                return False
            return True
    class CONTACT_LIST:
        def __init__(self,pk, relay_url, alias):
            
            self.pk = pk
            self.relay_url = relay_url
            self.alias = alias
            

        def __str__(self):
            return "TagEnum.CONTACT_LIST(pk={}, relay_url={}, alias={})".format(self.pk, self.relay_url, self.alias)

        def __eq__(self, other):
            if not other.is_contact_list():
                return False
            if self.pk != other.pk:
                return False
            if self.relay_url != other.relay_url:
                return False
            if self.alias != other.alias:
                return False
            return True
    class POW:
        def __init__(self,nonce, difficulty):
            
            self.nonce = nonce
            self.difficulty = difficulty
            

        def __str__(self):
            return "TagEnum.POW(nonce={}, difficulty={})".format(self.nonce, self.difficulty)

        def __eq__(self, other):
            if not other.is_pow():
                return False
            if self.nonce != other.nonce:
                return False
            if self.difficulty != other.difficulty:
                return False
            return True
    class DELEGATION:
        def __init__(self,delegator_pk, conditions, sig):
            
            self.delegator_pk = delegator_pk
            self.conditions = conditions
            self.sig = sig
            

        def __str__(self):
            return "TagEnum.DELEGATION(delegator_pk={}, conditions={}, sig={})".format(self.delegator_pk, self.conditions, self.sig)

        def __eq__(self, other):
            if not other.is_delegation():
                return False
            if self.delegator_pk != other.delegator_pk:
                return False
            if self.conditions != other.conditions:
                return False
            if self.sig != other.sig:
                return False
            return True
    class CONTENT_WARNING:
        def __init__(self,reason):
            
            self.reason = reason
            

        def __str__(self):
            return "TagEnum.CONTENT_WARNING(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_content_warning():
                return False
            if self.reason != other.reason:
                return False
            return True
    class EXPIRATION:
        def __init__(self,timestamp):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.EXPIRATION(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_expiration():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class SUBJECT:
        def __init__(self,subject):
            
            self.subject = subject
            

        def __str__(self):
            return "TagEnum.SUBJECT(subject={})".format(self.subject)

        def __eq__(self, other):
            if not other.is_subject():
                return False
            if self.subject != other.subject:
                return False
            return True
    class CHALLENGE:
        def __init__(self,challenge):
            
            self.challenge = challenge
            

        def __str__(self):
            return "TagEnum.CHALLENGE(challenge={})".format(self.challenge)

        def __eq__(self, other):
            if not other.is_challenge():
                return False
            if self.challenge != other.challenge:
                return False
            return True
    class TITLE:
        def __init__(self,title):
            
            self.title = title
            

        def __str__(self):
            return "TagEnum.TITLE(title={})".format(self.title)

        def __eq__(self, other):
            if not other.is_title():
                return False
            if self.title != other.title:
                return False
            return True
    class IMAGE:
        def __init__(self,url, dimensions):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.IMAGE(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_image():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class THUMB:
        def __init__(self,url, dimensions):
            
            self.url = url
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.THUMB(url={}, dimensions={})".format(self.url, self.dimensions)

        def __eq__(self, other):
            if not other.is_thumb():
                return False
            if self.url != other.url:
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class SUMMARY:
        def __init__(self,summary):
            
            self.summary = summary
            

        def __str__(self):
            return "TagEnum.SUMMARY(summary={})".format(self.summary)

        def __eq__(self, other):
            if not other.is_summary():
                return False
            if self.summary != other.summary:
                return False
            return True
    class DESCRIPTION:
        def __init__(self,desc):
            
            self.desc = desc
            

        def __str__(self):
            return "TagEnum.DESCRIPTION(desc={})".format(self.desc)

        def __eq__(self, other):
            if not other.is_description():
                return False
            if self.desc != other.desc:
                return False
            return True
    class BOLT11:
        def __init__(self,bolt11):
            
            self.bolt11 = bolt11
            

        def __str__(self):
            return "TagEnum.BOLT11(bolt11={})".format(self.bolt11)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    class PREIMAGE:
        def __init__(self,preimage):
            
            self.preimage = preimage
            

        def __str__(self):
            return "TagEnum.PREIMAGE(preimage={})".format(self.preimage)

        def __eq__(self, other):
            if not other.is_preimage():
                return False
            if self.preimage != other.preimage:
                return False
            return True
    class RELAYS:
        def __init__(self,urls):
            
            self.urls = urls
            

        def __str__(self):
            return "TagEnum.RELAYS(urls={})".format(self.urls)

        def __eq__(self, other):
            if not other.is_relays():
                return False
            if self.urls != other.urls:
                return False
            return True
    class AMOUNT:
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "TagEnum.AMOUNT(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.amount != other.amount:
                return False
            return True
    class LNURL:
        def __init__(self,lnurl):
            
            self.lnurl = lnurl
            

        def __str__(self):
            return "TagEnum.LNURL(lnurl={})".format(self.lnurl)

        def __eq__(self, other):
            if not other.is_lnurl():
                return False
            if self.lnurl != other.lnurl:
                return False
            return True
    class NAME:
        def __init__(self,name):
            
            self.name = name
            

        def __str__(self):
            return "TagEnum.NAME(name={})".format(self.name)

        def __eq__(self, other):
            if not other.is_name():
                return False
            if self.name != other.name:
                return False
            return True
    class PUBLISHED_AT:
        def __init__(self,timestamp):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.PUBLISHED_AT(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_published_at():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class URL:
        def __init__(self,url):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.url != other.url:
                return False
            return True
    class MIME_TYPE:
        def __init__(self,mime):
            
            self.mime = mime
            

        def __str__(self):
            return "TagEnum.MIME_TYPE(mime={})".format(self.mime)

        def __eq__(self, other):
            if not other.is_mime_type():
                return False
            if self.mime != other.mime:
                return False
            return True
    class AES256_GCM:
        def __init__(self,key, iv):
            
            self.key = key
            self.iv = iv
            

        def __str__(self):
            return "TagEnum.AES256_GCM(key={}, iv={})".format(self.key, self.iv)

        def __eq__(self, other):
            if not other.is_aes256_gcm():
                return False
            if self.key != other.key:
                return False
            if self.iv != other.iv:
                return False
            return True
    class SHA256:
        def __init__(self,hash):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.SHA256(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_sha256():
                return False
            if self.hash != other.hash:
                return False
            return True
    class SIZE:
        def __init__(self,size):
            
            self.size = size
            

        def __str__(self):
            return "TagEnum.SIZE(size={})".format(self.size)

        def __eq__(self, other):
            if not other.is_size():
                return False
            if self.size != other.size:
                return False
            return True
    class DIM:
        def __init__(self,dimensions):
            
            self.dimensions = dimensions
            

        def __str__(self):
            return "TagEnum.DIM(dimensions={})".format(self.dimensions)

        def __eq__(self, other):
            if not other.is_dim():
                return False
            if self.dimensions != other.dimensions:
                return False
            return True
    class MAGNET:
        def __init__(self,uri):
            
            self.uri = uri
            

        def __str__(self):
            return "TagEnum.MAGNET(uri={})".format(self.uri)

        def __eq__(self, other):
            if not other.is_magnet():
                return False
            if self.uri != other.uri:
                return False
            return True
    class BLURHASH:
        def __init__(self,blurhash):
            
            self.blurhash = blurhash
            

        def __str__(self):
            return "TagEnum.BLURHASH(blurhash={})".format(self.blurhash)

        def __eq__(self, other):
            if not other.is_blurhash():
                return False
            if self.blurhash != other.blurhash:
                return False
            return True
    class STREAMING:
        def __init__(self,url):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.STREAMING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_streaming():
                return False
            if self.url != other.url:
                return False
            return True
    class RECORDING:
        def __init__(self,url):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.RECORDING(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_recording():
                return False
            if self.url != other.url:
                return False
            return True
    class STARTS:
        def __init__(self,timestamp):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.STARTS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_starts():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class ENDS:
        def __init__(self,timestamp):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "TagEnum.ENDS(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_ends():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class STATUS:
        def __init__(self,status):
            
            self.status = status
            

        def __str__(self):
            return "TagEnum.STATUS(status={})".format(self.status)

        def __eq__(self, other):
            if not other.is_status():
                return False
            if self.status != other.status:
                return False
            return True
    class CURRENT_PARTICIPANTS:
        def __init__(self,num):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.CURRENT_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_current_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class TOTAL_PARTICIPANTS:
        def __init__(self,num):
            
            self.num = num
            

        def __str__(self):
            return "TagEnum.TOTAL_PARTICIPANTS(num={})".format(self.num)

        def __eq__(self, other):
            if not other.is_total_participants():
                return False
            if self.num != other.num:
                return False
            return True
    class ABSOLUTE_URL:
        def __init__(self,url):
            
            self.url = url
            

        def __str__(self):
            return "TagEnum.ABSOLUTE_URL(url={})".format(self.url)

        def __eq__(self, other):
            if not other.is_absolute_url():
                return False
            if self.url != other.url:
                return False
            return True
    class METHOD:
        def __init__(self,method):
            
            self.method = method
            

        def __str__(self):
            return "TagEnum.METHOD(method={})".format(self.method)

        def __eq__(self, other):
            if not other.is_method():
                return False
            if self.method != other.method:
                return False
            return True
    class PAYLOAD:
        def __init__(self,hash):
            
            self.hash = hash
            

        def __str__(self):
            return "TagEnum.PAYLOAD(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_payload():
                return False
            if self.hash != other.hash:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_unknown(self) -> bool:
        return isinstance(self, TagEnum.UNKNOWN)
    def is_e(self) -> bool:
        return isinstance(self, TagEnum.E)
    def is_pub_key(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY)
    def is_event_report(self) -> bool:
        return isinstance(self, TagEnum.EVENT_REPORT)
    def is_pub_key_report(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_REPORT)
    def is_pub_key_live_event(self) -> bool:
        return isinstance(self, TagEnum.PUB_KEY_LIVE_EVENT)
    def is_reference(self) -> bool:
        return isinstance(self, TagEnum.REFERENCE)
    def is_relay_metadata(self) -> bool:
        return isinstance(self, TagEnum.RELAY_METADATA)
    def is_hashtag(self) -> bool:
        return isinstance(self, TagEnum.HASHTAG)
    def is_geohash(self) -> bool:
        return isinstance(self, TagEnum.GEOHASH)
    def is_identifier(self) -> bool:
        return isinstance(self, TagEnum.IDENTIFIER)
    def is_external_identity(self) -> bool:
        return isinstance(self, TagEnum.EXTERNAL_IDENTITY)
    def is_a(self) -> bool:
        return isinstance(self, TagEnum.A)
    def is_relay_url(self) -> bool:
        return isinstance(self, TagEnum.RELAY_URL)
    def is_contact_list(self) -> bool:
        return isinstance(self, TagEnum.CONTACT_LIST)
    def is_pow(self) -> bool:
        return isinstance(self, TagEnum.POW)
    def is_delegation(self) -> bool:
        return isinstance(self, TagEnum.DELEGATION)
    def is_content_warning(self) -> bool:
        return isinstance(self, TagEnum.CONTENT_WARNING)
    def is_expiration(self) -> bool:
        return isinstance(self, TagEnum.EXPIRATION)
    def is_subject(self) -> bool:
        return isinstance(self, TagEnum.SUBJECT)
    def is_challenge(self) -> bool:
        return isinstance(self, TagEnum.CHALLENGE)
    def is_title(self) -> bool:
        return isinstance(self, TagEnum.TITLE)
    def is_image(self) -> bool:
        return isinstance(self, TagEnum.IMAGE)
    def is_thumb(self) -> bool:
        return isinstance(self, TagEnum.THUMB)
    def is_summary(self) -> bool:
        return isinstance(self, TagEnum.SUMMARY)
    def is_description(self) -> bool:
        return isinstance(self, TagEnum.DESCRIPTION)
    def is_bolt11(self) -> bool:
        return isinstance(self, TagEnum.BOLT11)
    def is_preimage(self) -> bool:
        return isinstance(self, TagEnum.PREIMAGE)
    def is_relays(self) -> bool:
        return isinstance(self, TagEnum.RELAYS)
    def is_amount(self) -> bool:
        return isinstance(self, TagEnum.AMOUNT)
    def is_lnurl(self) -> bool:
        return isinstance(self, TagEnum.LNURL)
    def is_name(self) -> bool:
        return isinstance(self, TagEnum.NAME)
    def is_published_at(self) -> bool:
        return isinstance(self, TagEnum.PUBLISHED_AT)
    def is_url(self) -> bool:
        return isinstance(self, TagEnum.URL)
    def is_mime_type(self) -> bool:
        return isinstance(self, TagEnum.MIME_TYPE)
    def is_aes256_gcm(self) -> bool:
        return isinstance(self, TagEnum.AES256_GCM)
    def is_sha256(self) -> bool:
        return isinstance(self, TagEnum.SHA256)
    def is_size(self) -> bool:
        return isinstance(self, TagEnum.SIZE)
    def is_dim(self) -> bool:
        return isinstance(self, TagEnum.DIM)
    def is_magnet(self) -> bool:
        return isinstance(self, TagEnum.MAGNET)
    def is_blurhash(self) -> bool:
        return isinstance(self, TagEnum.BLURHASH)
    def is_streaming(self) -> bool:
        return isinstance(self, TagEnum.STREAMING)
    def is_recording(self) -> bool:
        return isinstance(self, TagEnum.RECORDING)
    def is_starts(self) -> bool:
        return isinstance(self, TagEnum.STARTS)
    def is_ends(self) -> bool:
        return isinstance(self, TagEnum.ENDS)
    def is_status(self) -> bool:
        return isinstance(self, TagEnum.STATUS)
    def is_current_participants(self) -> bool:
        return isinstance(self, TagEnum.CURRENT_PARTICIPANTS)
    def is_total_participants(self) -> bool:
        return isinstance(self, TagEnum.TOTAL_PARTICIPANTS)
    def is_absolute_url(self) -> bool:
        return isinstance(self, TagEnum.ABSOLUTE_URL)
    def is_method(self) -> bool:
        return isinstance(self, TagEnum.METHOD)
    def is_payload(self) -> bool:
        return isinstance(self, TagEnum.PAYLOAD)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagEnum.UNKNOWN = type("TagEnum.UNKNOWN", (TagEnum.UNKNOWN, TagEnum,), {})  # type: ignore
TagEnum.E = type("TagEnum.E", (TagEnum.E, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY = type("TagEnum.PUB_KEY", (TagEnum.PUB_KEY, TagEnum,), {})  # type: ignore
TagEnum.EVENT_REPORT = type("TagEnum.EVENT_REPORT", (TagEnum.EVENT_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_REPORT = type("TagEnum.PUB_KEY_REPORT", (TagEnum.PUB_KEY_REPORT, TagEnum,), {})  # type: ignore
TagEnum.PUB_KEY_LIVE_EVENT = type("TagEnum.PUB_KEY_LIVE_EVENT", (TagEnum.PUB_KEY_LIVE_EVENT, TagEnum,), {})  # type: ignore
TagEnum.REFERENCE = type("TagEnum.REFERENCE", (TagEnum.REFERENCE, TagEnum,), {})  # type: ignore
TagEnum.RELAY_METADATA = type("TagEnum.RELAY_METADATA", (TagEnum.RELAY_METADATA, TagEnum,), {})  # type: ignore
TagEnum.HASHTAG = type("TagEnum.HASHTAG", (TagEnum.HASHTAG, TagEnum,), {})  # type: ignore
TagEnum.GEOHASH = type("TagEnum.GEOHASH", (TagEnum.GEOHASH, TagEnum,), {})  # type: ignore
TagEnum.IDENTIFIER = type("TagEnum.IDENTIFIER", (TagEnum.IDENTIFIER, TagEnum,), {})  # type: ignore
TagEnum.EXTERNAL_IDENTITY = type("TagEnum.EXTERNAL_IDENTITY", (TagEnum.EXTERNAL_IDENTITY, TagEnum,), {})  # type: ignore
TagEnum.A = type("TagEnum.A", (TagEnum.A, TagEnum,), {})  # type: ignore
TagEnum.RELAY_URL = type("TagEnum.RELAY_URL", (TagEnum.RELAY_URL, TagEnum,), {})  # type: ignore
TagEnum.CONTACT_LIST = type("TagEnum.CONTACT_LIST", (TagEnum.CONTACT_LIST, TagEnum,), {})  # type: ignore
TagEnum.POW = type("TagEnum.POW", (TagEnum.POW, TagEnum,), {})  # type: ignore
TagEnum.DELEGATION = type("TagEnum.DELEGATION", (TagEnum.DELEGATION, TagEnum,), {})  # type: ignore
TagEnum.CONTENT_WARNING = type("TagEnum.CONTENT_WARNING", (TagEnum.CONTENT_WARNING, TagEnum,), {})  # type: ignore
TagEnum.EXPIRATION = type("TagEnum.EXPIRATION", (TagEnum.EXPIRATION, TagEnum,), {})  # type: ignore
TagEnum.SUBJECT = type("TagEnum.SUBJECT", (TagEnum.SUBJECT, TagEnum,), {})  # type: ignore
TagEnum.CHALLENGE = type("TagEnum.CHALLENGE", (TagEnum.CHALLENGE, TagEnum,), {})  # type: ignore
TagEnum.TITLE = type("TagEnum.TITLE", (TagEnum.TITLE, TagEnum,), {})  # type: ignore
TagEnum.IMAGE = type("TagEnum.IMAGE", (TagEnum.IMAGE, TagEnum,), {})  # type: ignore
TagEnum.THUMB = type("TagEnum.THUMB", (TagEnum.THUMB, TagEnum,), {})  # type: ignore
TagEnum.SUMMARY = type("TagEnum.SUMMARY", (TagEnum.SUMMARY, TagEnum,), {})  # type: ignore
TagEnum.DESCRIPTION = type("TagEnum.DESCRIPTION", (TagEnum.DESCRIPTION, TagEnum,), {})  # type: ignore
TagEnum.BOLT11 = type("TagEnum.BOLT11", (TagEnum.BOLT11, TagEnum,), {})  # type: ignore
TagEnum.PREIMAGE = type("TagEnum.PREIMAGE", (TagEnum.PREIMAGE, TagEnum,), {})  # type: ignore
TagEnum.RELAYS = type("TagEnum.RELAYS", (TagEnum.RELAYS, TagEnum,), {})  # type: ignore
TagEnum.AMOUNT = type("TagEnum.AMOUNT", (TagEnum.AMOUNT, TagEnum,), {})  # type: ignore
TagEnum.LNURL = type("TagEnum.LNURL", (TagEnum.LNURL, TagEnum,), {})  # type: ignore
TagEnum.NAME = type("TagEnum.NAME", (TagEnum.NAME, TagEnum,), {})  # type: ignore
TagEnum.PUBLISHED_AT = type("TagEnum.PUBLISHED_AT", (TagEnum.PUBLISHED_AT, TagEnum,), {})  # type: ignore
TagEnum.URL = type("TagEnum.URL", (TagEnum.URL, TagEnum,), {})  # type: ignore
TagEnum.MIME_TYPE = type("TagEnum.MIME_TYPE", (TagEnum.MIME_TYPE, TagEnum,), {})  # type: ignore
TagEnum.AES256_GCM = type("TagEnum.AES256_GCM", (TagEnum.AES256_GCM, TagEnum,), {})  # type: ignore
TagEnum.SHA256 = type("TagEnum.SHA256", (TagEnum.SHA256, TagEnum,), {})  # type: ignore
TagEnum.SIZE = type("TagEnum.SIZE", (TagEnum.SIZE, TagEnum,), {})  # type: ignore
TagEnum.DIM = type("TagEnum.DIM", (TagEnum.DIM, TagEnum,), {})  # type: ignore
TagEnum.MAGNET = type("TagEnum.MAGNET", (TagEnum.MAGNET, TagEnum,), {})  # type: ignore
TagEnum.BLURHASH = type("TagEnum.BLURHASH", (TagEnum.BLURHASH, TagEnum,), {})  # type: ignore
TagEnum.STREAMING = type("TagEnum.STREAMING", (TagEnum.STREAMING, TagEnum,), {})  # type: ignore
TagEnum.RECORDING = type("TagEnum.RECORDING", (TagEnum.RECORDING, TagEnum,), {})  # type: ignore
TagEnum.STARTS = type("TagEnum.STARTS", (TagEnum.STARTS, TagEnum,), {})  # type: ignore
TagEnum.ENDS = type("TagEnum.ENDS", (TagEnum.ENDS, TagEnum,), {})  # type: ignore
TagEnum.STATUS = type("TagEnum.STATUS", (TagEnum.STATUS, TagEnum,), {})  # type: ignore
TagEnum.CURRENT_PARTICIPANTS = type("TagEnum.CURRENT_PARTICIPANTS", (TagEnum.CURRENT_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.TOTAL_PARTICIPANTS = type("TagEnum.TOTAL_PARTICIPANTS", (TagEnum.TOTAL_PARTICIPANTS, TagEnum,), {})  # type: ignore
TagEnum.ABSOLUTE_URL = type("TagEnum.ABSOLUTE_URL", (TagEnum.ABSOLUTE_URL, TagEnum,), {})  # type: ignore
TagEnum.METHOD = type("TagEnum.METHOD", (TagEnum.METHOD, TagEnum,), {})  # type: ignore
TagEnum.PAYLOAD = type("TagEnum.PAYLOAD", (TagEnum.PAYLOAD, TagEnum,), {})  # type: ignore




class FfiConverterTypeTagEnum(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TagEnum.UNKNOWN(
                FfiConverterTypeTagKind.read(buf),
                FfiConverterSequenceString.read(buf),
            )
        if variant == 2:
            return TagEnum.E(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 3:
            return TagEnum.PUB_KEY(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 4:
            return TagEnum.EVENT_REPORT(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return TagEnum.PUB_KEY_REPORT(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return TagEnum.PUB_KEY_LIVE_EVENT(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 7:
            return TagEnum.REFERENCE(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return TagEnum.RELAY_METADATA(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 9:
            return TagEnum.HASHTAG(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return TagEnum.GEOHASH(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return TagEnum.IDENTIFIER(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return TagEnum.EXTERNAL_IDENTITY(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 13:
            return TagEnum.A(
                FfiConverterUInt64.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 14:
            return TagEnum.RELAY_URL(
                FfiConverterString.read(buf),
            )
        if variant == 15:
            return TagEnum.CONTACT_LIST(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 16:
            return TagEnum.POW(
                FfiConverterString.read(buf),
                FfiConverterUInt8.read(buf),
            )
        if variant == 17:
            return TagEnum.DELEGATION(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 18:
            return TagEnum.CONTENT_WARNING(
                FfiConverterOptionalString.read(buf),
            )
        if variant == 19:
            return TagEnum.EXPIRATION(
                FfiConverterUInt64.read(buf),
            )
        if variant == 20:
            return TagEnum.SUBJECT(
                FfiConverterString.read(buf),
            )
        if variant == 21:
            return TagEnum.CHALLENGE(
                FfiConverterString.read(buf),
            )
        if variant == 22:
            return TagEnum.TITLE(
                FfiConverterString.read(buf),
            )
        if variant == 23:
            return TagEnum.IMAGE(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 24:
            return TagEnum.THUMB(
                FfiConverterString.read(buf),
                FfiConverterOptionalString.read(buf),
            )
        if variant == 25:
            return TagEnum.SUMMARY(
                FfiConverterString.read(buf),
            )
        if variant == 26:
            return TagEnum.DESCRIPTION(
                FfiConverterString.read(buf),
            )
        if variant == 27:
            return TagEnum.BOLT11(
                FfiConverterString.read(buf),
            )
        if variant == 28:
            return TagEnum.PREIMAGE(
                FfiConverterString.read(buf),
            )
        if variant == 29:
            return TagEnum.RELAYS(
                FfiConverterSequenceString.read(buf),
            )
        if variant == 30:
            return TagEnum.AMOUNT(
                FfiConverterUInt64.read(buf),
            )
        if variant == 31:
            return TagEnum.LNURL(
                FfiConverterString.read(buf),
            )
        if variant == 32:
            return TagEnum.NAME(
                FfiConverterString.read(buf),
            )
        if variant == 33:
            return TagEnum.PUBLISHED_AT(
                FfiConverterUInt64.read(buf),
            )
        if variant == 34:
            return TagEnum.URL(
                FfiConverterString.read(buf),
            )
        if variant == 35:
            return TagEnum.MIME_TYPE(
                FfiConverterString.read(buf),
            )
        if variant == 36:
            return TagEnum.AES256_GCM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 37:
            return TagEnum.SHA256(
                FfiConverterString.read(buf),
            )
        if variant == 38:
            return TagEnum.SIZE(
                FfiConverterUInt64.read(buf),
            )
        if variant == 39:
            return TagEnum.DIM(
                FfiConverterString.read(buf),
            )
        if variant == 40:
            return TagEnum.MAGNET(
                FfiConverterString.read(buf),
            )
        if variant == 41:
            return TagEnum.BLURHASH(
                FfiConverterString.read(buf),
            )
        if variant == 42:
            return TagEnum.STREAMING(
                FfiConverterString.read(buf),
            )
        if variant == 43:
            return TagEnum.RECORDING(
                FfiConverterString.read(buf),
            )
        if variant == 44:
            return TagEnum.STARTS(
                FfiConverterUInt64.read(buf),
            )
        if variant == 45:
            return TagEnum.ENDS(
                FfiConverterUInt64.read(buf),
            )
        if variant == 46:
            return TagEnum.STATUS(
                FfiConverterString.read(buf),
            )
        if variant == 47:
            return TagEnum.CURRENT_PARTICIPANTS(
                FfiConverterUInt64.read(buf),
            )
        if variant == 48:
            return TagEnum.TOTAL_PARTICIPANTS(
                FfiConverterUInt64.read(buf),
            )
        if variant == 49:
            return TagEnum.ABSOLUTE_URL(
                FfiConverterString.read(buf),
            )
        if variant == 50:
            return TagEnum.METHOD(
                FfiConverterString.read(buf),
            )
        if variant == 51:
            return TagEnum.PAYLOAD(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_unknown():
            buf.writeI32(1)
            FfiConverterTypeTagKind.write(value.kind, buf)
            FfiConverterSequenceString.write(value.data, buf)
        if value.is_e():
            buf.writeI32(2)
            FfiConverterString.write(value.event_id, buf)
            FfiConverterOptionalString.write(value.relay_url, buf)
            FfiConverterOptionalString.write(value.marker, buf)
        if value.is_pub_key():
            buf.writeI32(3)
            FfiConverterString.write(value.public_key, buf)
            FfiConverterOptionalString.write(value.relay_url, buf)
        if value.is_event_report():
            buf.writeI32(4)
            FfiConverterString.write(value.event_id, buf)
            FfiConverterString.write(value.report, buf)
        if value.is_pub_key_report():
            buf.writeI32(5)
            FfiConverterString.write(value.public_key, buf)
            FfiConverterString.write(value.report, buf)
        if value.is_pub_key_live_event():
            buf.writeI32(6)
            FfiConverterString.write(value.pk, buf)
            FfiConverterOptionalString.write(value.relay_url, buf)
            FfiConverterString.write(value.marker, buf)
            FfiConverterOptionalString.write(value.proof, buf)
        if value.is_reference():
            buf.writeI32(7)
            FfiConverterString.write(value.reference, buf)
        if value.is_relay_metadata():
            buf.writeI32(8)
            FfiConverterString.write(value.relay_url, buf)
            FfiConverterOptionalString.write(value.rw, buf)
        if value.is_hashtag():
            buf.writeI32(9)
            FfiConverterString.write(value.hashtag, buf)
        if value.is_geohash():
            buf.writeI32(10)
            FfiConverterString.write(value.geohash, buf)
        if value.is_identifier():
            buf.writeI32(11)
            FfiConverterString.write(value.identifier, buf)
        if value.is_external_identity():
            buf.writeI32(12)
            FfiConverterString.write(value.identity, buf)
            FfiConverterString.write(value.proof, buf)
        if value.is_a():
            buf.writeI32(13)
            FfiConverterUInt64.write(value.kind, buf)
            FfiConverterString.write(value.public_key, buf)
            FfiConverterString.write(value.identifier, buf)
            FfiConverterOptionalString.write(value.relay_url, buf)
        if value.is_relay_url():
            buf.writeI32(14)
            FfiConverterString.write(value.relay_url, buf)
        if value.is_contact_list():
            buf.writeI32(15)
            FfiConverterString.write(value.pk, buf)
            FfiConverterOptionalString.write(value.relay_url, buf)
            FfiConverterOptionalString.write(value.alias, buf)
        if value.is_pow():
            buf.writeI32(16)
            FfiConverterString.write(value.nonce, buf)
            FfiConverterUInt8.write(value.difficulty, buf)
        if value.is_delegation():
            buf.writeI32(17)
            FfiConverterString.write(value.delegator_pk, buf)
            FfiConverterString.write(value.conditions, buf)
            FfiConverterString.write(value.sig, buf)
        if value.is_content_warning():
            buf.writeI32(18)
            FfiConverterOptionalString.write(value.reason, buf)
        if value.is_expiration():
            buf.writeI32(19)
            FfiConverterUInt64.write(value.timestamp, buf)
        if value.is_subject():
            buf.writeI32(20)
            FfiConverterString.write(value.subject, buf)
        if value.is_challenge():
            buf.writeI32(21)
            FfiConverterString.write(value.challenge, buf)
        if value.is_title():
            buf.writeI32(22)
            FfiConverterString.write(value.title, buf)
        if value.is_image():
            buf.writeI32(23)
            FfiConverterString.write(value.url, buf)
            FfiConverterOptionalString.write(value.dimensions, buf)
        if value.is_thumb():
            buf.writeI32(24)
            FfiConverterString.write(value.url, buf)
            FfiConverterOptionalString.write(value.dimensions, buf)
        if value.is_summary():
            buf.writeI32(25)
            FfiConverterString.write(value.summary, buf)
        if value.is_description():
            buf.writeI32(26)
            FfiConverterString.write(value.desc, buf)
        if value.is_bolt11():
            buf.writeI32(27)
            FfiConverterString.write(value.bolt11, buf)
        if value.is_preimage():
            buf.writeI32(28)
            FfiConverterString.write(value.preimage, buf)
        if value.is_relays():
            buf.writeI32(29)
            FfiConverterSequenceString.write(value.urls, buf)
        if value.is_amount():
            buf.writeI32(30)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_lnurl():
            buf.writeI32(31)
            FfiConverterString.write(value.lnurl, buf)
        if value.is_name():
            buf.writeI32(32)
            FfiConverterString.write(value.name, buf)
        if value.is_published_at():
            buf.writeI32(33)
            FfiConverterUInt64.write(value.timestamp, buf)
        if value.is_url():
            buf.writeI32(34)
            FfiConverterString.write(value.url, buf)
        if value.is_mime_type():
            buf.writeI32(35)
            FfiConverterString.write(value.mime, buf)
        if value.is_aes256_gcm():
            buf.writeI32(36)
            FfiConverterString.write(value.key, buf)
            FfiConverterString.write(value.iv, buf)
        if value.is_sha256():
            buf.writeI32(37)
            FfiConverterString.write(value.hash, buf)
        if value.is_size():
            buf.writeI32(38)
            FfiConverterUInt64.write(value.size, buf)
        if value.is_dim():
            buf.writeI32(39)
            FfiConverterString.write(value.dimensions, buf)
        if value.is_magnet():
            buf.writeI32(40)
            FfiConverterString.write(value.uri, buf)
        if value.is_blurhash():
            buf.writeI32(41)
            FfiConverterString.write(value.blurhash, buf)
        if value.is_streaming():
            buf.writeI32(42)
            FfiConverterString.write(value.url, buf)
        if value.is_recording():
            buf.writeI32(43)
            FfiConverterString.write(value.url, buf)
        if value.is_starts():
            buf.writeI32(44)
            FfiConverterUInt64.write(value.timestamp, buf)
        if value.is_ends():
            buf.writeI32(45)
            FfiConverterUInt64.write(value.timestamp, buf)
        if value.is_status():
            buf.writeI32(46)
            FfiConverterString.write(value.status, buf)
        if value.is_current_participants():
            buf.writeI32(47)
            FfiConverterUInt64.write(value.num, buf)
        if value.is_total_participants():
            buf.writeI32(48)
            FfiConverterUInt64.write(value.num, buf)
        if value.is_absolute_url():
            buf.writeI32(49)
            FfiConverterString.write(value.url, buf)
        if value.is_method():
            buf.writeI32(50)
            FfiConverterString.write(value.method, buf)
        if value.is_payload():
            buf.writeI32(51)
            FfiConverterString.write(value.hash, buf)






class TagKind:
    def __init__(self):
        raise RuntimeError("TagKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class KNOWN:
        def __init__(self,known):
            
            self.known = known
            

        def __str__(self):
            return "TagKind.KNOWN(known={})".format(self.known)

        def __eq__(self, other):
            if not other.is_known():
                return False
            if self.known != other.known:
                return False
            return True
    class UNKNOWN:
        def __init__(self,unknown):
            
            self.unknown = unknown
            

        def __str__(self):
            return "TagKind.UNKNOWN(unknown={})".format(self.unknown)

        def __eq__(self, other):
            if not other.is_unknown():
                return False
            if self.unknown != other.unknown:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_known(self) -> bool:
        return isinstance(self, TagKind.KNOWN)
    def is_unknown(self) -> bool:
        return isinstance(self, TagKind.UNKNOWN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TagKind.KNOWN = type("TagKind.KNOWN", (TagKind.KNOWN, TagKind,), {})  # type: ignore
TagKind.UNKNOWN = type("TagKind.UNKNOWN", (TagKind.UNKNOWN, TagKind,), {})  # type: ignore




class FfiConverterTypeTagKind(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TagKind.KNOWN(
                FfiConverterTypeTagKindKnown.read(buf),
            )
        if variant == 2:
            return TagKind.UNKNOWN(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_known():
            buf.writeI32(1)
            FfiConverterTypeTagKindKnown.write(value.known, buf)
        if value.is_unknown():
            buf.writeI32(2)
            FfiConverterString.write(value.unknown, buf)






class TagKindKnown(enum.Enum):
    P = 1
    E = 2
    R = 3
    T = 4
    G = 5
    D = 6
    A = 7
    I = 8
    M = 9
    U = 10
    X = 11
    RELAY_URL = 12
    NONCE = 13
    DELEGATION = 14
    CONTENT_WARNING = 15
    EXPIRATION = 16
    SUBJECT = 17
    CHALLENGE = 18
    TITLE = 19
    IMAGE = 20
    THUMB = 21
    SUMMARY = 22
    PUBLISHED_AT = 23
    DESCRIPTION = 24
    BOLT11 = 25
    PREIMAGE = 26
    RELAYS = 27
    AMOUNT = 28
    LNURL = 29
    NAME = 30
    URL = 31
    AES256_GCM = 32
    SIZE = 33
    DIM = 34
    MAGNET = 35
    BLURHASH = 36
    STREAMING = 37
    RECORDING = 38
    STARTS = 39
    ENDS = 40
    STATUS = 41
    CURRENT_PARTICIPANTS = 42
    TOTAL_PARTICIPANTS = 43
    METHOD = 44
    PAYLOAD = 45
    


class FfiConverterTypeTagKindKnown(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TagKindKnown.P
        if variant == 2:
            return TagKindKnown.E
        if variant == 3:
            return TagKindKnown.R
        if variant == 4:
            return TagKindKnown.T
        if variant == 5:
            return TagKindKnown.G
        if variant == 6:
            return TagKindKnown.D
        if variant == 7:
            return TagKindKnown.A
        if variant == 8:
            return TagKindKnown.I
        if variant == 9:
            return TagKindKnown.M
        if variant == 10:
            return TagKindKnown.U
        if variant == 11:
            return TagKindKnown.X
        if variant == 12:
            return TagKindKnown.RELAY_URL
        if variant == 13:
            return TagKindKnown.NONCE
        if variant == 14:
            return TagKindKnown.DELEGATION
        if variant == 15:
            return TagKindKnown.CONTENT_WARNING
        if variant == 16:
            return TagKindKnown.EXPIRATION
        if variant == 17:
            return TagKindKnown.SUBJECT
        if variant == 18:
            return TagKindKnown.CHALLENGE
        if variant == 19:
            return TagKindKnown.TITLE
        if variant == 20:
            return TagKindKnown.IMAGE
        if variant == 21:
            return TagKindKnown.THUMB
        if variant == 22:
            return TagKindKnown.SUMMARY
        if variant == 23:
            return TagKindKnown.PUBLISHED_AT
        if variant == 24:
            return TagKindKnown.DESCRIPTION
        if variant == 25:
            return TagKindKnown.BOLT11
        if variant == 26:
            return TagKindKnown.PREIMAGE
        if variant == 27:
            return TagKindKnown.RELAYS
        if variant == 28:
            return TagKindKnown.AMOUNT
        if variant == 29:
            return TagKindKnown.LNURL
        if variant == 30:
            return TagKindKnown.NAME
        if variant == 31:
            return TagKindKnown.URL
        if variant == 32:
            return TagKindKnown.AES256_GCM
        if variant == 33:
            return TagKindKnown.SIZE
        if variant == 34:
            return TagKindKnown.DIM
        if variant == 35:
            return TagKindKnown.MAGNET
        if variant == 36:
            return TagKindKnown.BLURHASH
        if variant == 37:
            return TagKindKnown.STREAMING
        if variant == 38:
            return TagKindKnown.RECORDING
        if variant == 39:
            return TagKindKnown.STARTS
        if variant == 40:
            return TagKindKnown.ENDS
        if variant == 41:
            return TagKindKnown.STATUS
        if variant == 42:
            return TagKindKnown.CURRENT_PARTICIPANTS
        if variant == 43:
            return TagKindKnown.TOTAL_PARTICIPANTS
        if variant == 44:
            return TagKindKnown.METHOD
        if variant == 45:
            return TagKindKnown.PAYLOAD
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TagKindKnown.P:
            buf.writeI32(1)
        if value == TagKindKnown.E:
            buf.writeI32(2)
        if value == TagKindKnown.R:
            buf.writeI32(3)
        if value == TagKindKnown.T:
            buf.writeI32(4)
        if value == TagKindKnown.G:
            buf.writeI32(5)
        if value == TagKindKnown.D:
            buf.writeI32(6)
        if value == TagKindKnown.A:
            buf.writeI32(7)
        if value == TagKindKnown.I:
            buf.writeI32(8)
        if value == TagKindKnown.M:
            buf.writeI32(9)
        if value == TagKindKnown.U:
            buf.writeI32(10)
        if value == TagKindKnown.X:
            buf.writeI32(11)
        if value == TagKindKnown.RELAY_URL:
            buf.writeI32(12)
        if value == TagKindKnown.NONCE:
            buf.writeI32(13)
        if value == TagKindKnown.DELEGATION:
            buf.writeI32(14)
        if value == TagKindKnown.CONTENT_WARNING:
            buf.writeI32(15)
        if value == TagKindKnown.EXPIRATION:
            buf.writeI32(16)
        if value == TagKindKnown.SUBJECT:
            buf.writeI32(17)
        if value == TagKindKnown.CHALLENGE:
            buf.writeI32(18)
        if value == TagKindKnown.TITLE:
            buf.writeI32(19)
        if value == TagKindKnown.IMAGE:
            buf.writeI32(20)
        if value == TagKindKnown.THUMB:
            buf.writeI32(21)
        if value == TagKindKnown.SUMMARY:
            buf.writeI32(22)
        if value == TagKindKnown.PUBLISHED_AT:
            buf.writeI32(23)
        if value == TagKindKnown.DESCRIPTION:
            buf.writeI32(24)
        if value == TagKindKnown.BOLT11:
            buf.writeI32(25)
        if value == TagKindKnown.PREIMAGE:
            buf.writeI32(26)
        if value == TagKindKnown.RELAYS:
            buf.writeI32(27)
        if value == TagKindKnown.AMOUNT:
            buf.writeI32(28)
        if value == TagKindKnown.LNURL:
            buf.writeI32(29)
        if value == TagKindKnown.NAME:
            buf.writeI32(30)
        if value == TagKindKnown.URL:
            buf.writeI32(31)
        if value == TagKindKnown.AES256_GCM:
            buf.writeI32(32)
        if value == TagKindKnown.SIZE:
            buf.writeI32(33)
        if value == TagKindKnown.DIM:
            buf.writeI32(34)
        if value == TagKindKnown.MAGNET:
            buf.writeI32(35)
        if value == TagKindKnown.BLURHASH:
            buf.writeI32(36)
        if value == TagKindKnown.STREAMING:
            buf.writeI32(37)
        if value == TagKindKnown.RECORDING:
            buf.writeI32(38)
        if value == TagKindKnown.STARTS:
            buf.writeI32(39)
        if value == TagKindKnown.ENDS:
            buf.writeI32(40)
        if value == TagKindKnown.STATUS:
            buf.writeI32(41)
        if value == TagKindKnown.CURRENT_PARTICIPANTS:
            buf.writeI32(42)
        if value == TagKindKnown.TOTAL_PARTICIPANTS:
            buf.writeI32(43)
        if value == TagKindKnown.METHOD:
            buf.writeI32(44)
        if value == TagKindKnown.PAYLOAD:
            buf.writeI32(45)




import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0
# Return codes for callback calls
UNIFFI_CALLBACK_SUCCESS = 0
UNIFFI_CALLBACK_ERROR = 1
UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class FfiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.readU64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.writeU64(cls.lower(cb))

# Declaration and FfiConverters for HandleNotification Callback Interface

class HandleNotification:
    def handle_msg(self, relay_url: "str",msg: "RelayMessage"):
        raise NotImplementedError

    def handle(self, relay_url: "str",event: "Event"):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceHandleNotification(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_handle_msg(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.handle_msg(
                FfiConverterString.read(args_stream), 
                FfiConverterTypeRelayMessage.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    
    def invoke_handle(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.handle(
                FfiConverterString.read(args_stream), 
                FfiConverterTypeEvent.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    

    cb = FfiConverterCallbackInterfaceHandleNotification.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceHandleNotification.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_handle_msg(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 2:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_handle(cb, RustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = FfiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceHandleNotification = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceHandleNotification)
rust_call(lambda err: _UniFFILib.uniffi_nostr_sdk_fn_init_callback_handlenotification(foreignCallbackCallbackInterfaceHandleNotification, err))

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
FfiConverterCallbackInterfaceHandleNotification = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceHandleNotification)



class FfiConverterOptionalUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalDuration(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeEventId(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeEventId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeEventId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceUInt16(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceUInt16(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt16.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt16.read(buf) for i in range(count)
        ]



class FfiConverterSequenceUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt64.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeContact(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeContact.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeContact.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeEvent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeEvent.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeEventId(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeEventId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeEventId.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeFilter.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypePublicKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeTag(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeTag.read(buf) for i in range(count)
        ]



class FfiConverterSequenceSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterSequenceString.read(buf) for i in range(count)
        ]



class FfiConverterMapStringTypeActiveSubscription(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterString.write(key, buf)
            FfiConverterTypeActiveSubscription.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterString.read(buf)
            val = FfiConverterTypeActiveSubscription.read(buf)
            d[key] = val
        return d



class FfiConverterMapStringTypeRelay(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterString.write(key, buf)
            FfiConverterTypeRelay.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterString.read(buf)
            val = FfiConverterTypeRelay.read(buf)
            d[key] = val
        return d

def nip04_encrypt(secret_key: "SecretKey",public_key: "PublicKey",content: "str"):
    
    
    
    return FfiConverterString.lift(rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_func_nip04_encrypt,
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterString.lower(content)))


def nip04_decrypt(secret_key: "SecretKey",public_key: "PublicKey",encrypted_content: "str"):
    
    
    
    return FfiConverterString.lift(rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_func_nip04_decrypt,
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterString.lower(encrypted_content)))


def verify_nip05(public_key: "PublicKey",nip05: "str",proxy: "typing.Optional[str]"):
    
    
    
    rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_func_verify_nip05,
        FfiConverterTypePublicKey.lower(public_key),
        FfiConverterString.lower(nip05),
        FfiConverterOptionalString.lower(proxy))


def get_nip05_profile(nip05: "str",proxy: "typing.Optional[str]"):
    
    
    return FfiConverterTypeProfile.lift(rust_call_with_error(FfiConverterTypeNostrError,_UniFFILib.uniffi_nostr_sdk_fn_func_get_nip05_profile,
        FfiConverterString.lower(nip05),
        FfiConverterOptionalString.lower(proxy)))


def init_logger(level: "LogLevel"):
    
    rust_call_with_error(FfiConverterTypeNostrSdkError,_UniFFILib.uniffi_nostr_sdk_fn_func_init_logger,
        FfiConverterTypeLogLevel.lower(level))


__all__ = [
    "InternalError",
    "Alphabet",
    "ClientMessage",
    "LogLevel",
    "NostrError",
    "NostrSdkError",
    "RelayMessage",
    "RelayStatus",
    "TagEnum",
    "TagKind",
    "TagKindKnown",
    "nip04_encrypt",
    "nip04_decrypt",
    "verify_nip05",
    "get_nip05_profile",
    "init_logger",
    "RelayInformationDocument",
    "NostrConnectUri",
    "Profile",
    "ImageDimensions",
    "Timestamp",
    "SecretKey",
    "PublicKey",
    "Keys",
    "Filter",
    "EventId",
    "UnsignedEvent",
    "Event",
    "EventBuilder",
    "Contact",
    "AccountMetadata",
    "FileMetadata",
    "Tag",
    "RelayConnectionStats",
    "ActiveSubscription",
    "Relay",
    "Options",
    "Client",
    "HandleNotification",
]

