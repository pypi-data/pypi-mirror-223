# mypy: disable-error-code="misc, override, no-redef"

import Boost.Python
import pxr.Ar
import pxr.Gf
import pxr.Kind
import pxr.Pcp
import pxr.Sdf
import pxr.Tf
import pxr.UsdGeom
import pxr.UsdShade
import pxr.Vt
import types
import typing
import typing_extensions
from _typeshed import Incomplete
from typing import Any, ClassVar, overload

BlockStageCachePopulation: StageCacheContextBlockType
BlockStageCaches: StageCacheContextBlockType
InterpolationTypeHeld: InterpolationType
InterpolationTypeLinear: InterpolationType
ListPositionBackOfAppendList: ListPosition
ListPositionBackOfPrependList: ListPosition
ListPositionFrontOfAppendList: ListPosition
ListPositionFrontOfPrependList: ListPosition
LoadWithDescendants: LoadPolicy
LoadWithoutDescendants: LoadPolicy
PrimAllPrimsPredicate: _PrimFlagsPredicate
PrimDefaultPredicate: _PrimFlagsConjunction
PrimHasDefiningSpecifier: _Term
PrimIsAbstract: _Term
PrimIsActive: _Term
PrimIsDefined: _Term
PrimIsGroup: _Term
PrimIsInstance: _Term
PrimIsLoaded: _Term
PrimIsModel: _Term
ResolveInfoSourceDefault: ResolveInfoSource
ResolveInfoSourceFallback: ResolveInfoSource
ResolveInfoSourceNone: ResolveInfoSource
ResolveInfoSourceTimeSamples: ResolveInfoSource
ResolveInfoSourceValueClips: ResolveInfoSource
_NoBlock: StageCacheContextBlockType
__MFB_FULL_PACKAGE_NAME: str

class APISchemaBase(SchemaBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...

class AssetInfoKeys(Boost.Python.instance):
    identifier: ClassVar[str] = ...  # read-only
    name: ClassVar[str] = ...  # read-only
    payloadAssetDependencies: ClassVar[str] = ...  # read-only
    version: ClassVar[str] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...

class Attribute(Property):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def AddConnection(self, source: pxr.Sdf.Path | str, position: ListPosition = ...) -> bool: ...
    def Block(self) -> None: ...
    def Clear(self) -> bool: ...
    def ClearAtTime(self, time: TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    def ClearColorSpace(self) -> bool: ...
    def ClearConnections(self) -> bool: ...
    def ClearDefault(self) -> bool: ...
    def Get(self, time: TimeCode | float | pxr.Sdf.TimeCode = ...) -> Any: ...
    def GetBracketingTimeSamples(self, desiredTime: float) -> tuple[float, float, bool]: ...
    def GetColorSpace(self) -> str: ...
    def GetConnections(self) -> list[pxr.Sdf.Path]: ...
    def GetNumTimeSamples(self) -> int: ...
    def GetResolveInfo(self, time: TimeCode | float | pxr.Sdf.TimeCode = ...) -> ResolveInfo: ...
    def GetRoleName(self) -> str: ...
    def GetTimeSamples(self) -> list[float]: ...
    def GetTimeSamplesInInterval(self, interval: pxr.Gf.Interval) -> list[float]: ...
    def GetTypeName(self) -> pxr.Sdf.ValueTypeName: ...
    @classmethod
    def GetUnionedTimeSamples(cls, attrs: typing.Iterable[Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output]) -> list[float]: ...
    @classmethod
    def GetUnionedTimeSamplesInInterval(cls, attrs: typing.Iterable[Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output], interval: pxr.Gf.Interval) -> list[float]: ...
    def GetVariability(self) -> pxr.Sdf.Variability: ...
    def HasAuthoredConnections(self) -> bool: ...
    def HasAuthoredValue(self) -> bool: ...
    def HasAuthoredValueOpinion(self) -> bool: ...
    def HasColorSpace(self) -> bool: ...
    def HasFallbackValue(self) -> bool: ...
    def HasValue(self) -> bool: ...
    def RemoveConnection(self, source: pxr.Sdf.Path | str) -> bool: ...
    def Set(self, value: object, time: TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetColorSpace(self, arg2: str | pxr.Ar.ResolvedPath) -> None: ...
    def SetConnections(self, sources: typing.Iterable[pxr.Sdf.Path | str]) -> bool: ...
    def SetTypeName(self, typeName: pxr.Sdf.ValueTypeName) -> bool: ...
    def SetVariability(self, variability: pxr.Sdf.Variability) -> bool: ...
    def ValueMightBeTimeVarying(self) -> bool: ...

class AttributeQuery(Boost.Python.instance):
    @overload
    def __init__(self, prim: Prim, attributeName: object) -> None: ...
    @overload
    def __init__(self, attribute: Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output, resolveTarget: ResolveTarget) -> None: ...
    @overload
    def __init__(self, attribute: Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output) -> None: ...
    @classmethod
    def CreateQueries(cls, prim: Prim, attributeNames: list[str] | list[pxr.Ar.ResolvedPath]) -> list[AttributeQuery]: ...
    def Get(self, time: TimeCode | float | pxr.Sdf.TimeCode = ...) -> Any: ...
    def GetAttribute(self) -> Attribute: ...
    def GetBracketingTimeSamples(self, desiredTime: float) -> tuple[float, float, bool]: ...
    def GetNumTimeSamples(self) -> int: ...
    def GetTimeSamples(self) -> list[float]: ...
    def GetTimeSamplesInInterval(self, interval: pxr.Gf.Interval) -> list[float]: ...
    @classmethod
    def GetUnionedTimeSamples(cls, attrQueries: typing.Iterable[AttributeQuery]) -> list[float]: ...
    @classmethod
    def GetUnionedTimeSamplesInInterval(cls, attrQueries: typing.Iterable[AttributeQuery], interval: pxr.Gf.Interval) -> list[float]: ...
    def HasAuthoredValue(self) -> bool: ...
    def HasAuthoredValueOpinion(self) -> bool: ...
    def HasFallbackValue(self) -> bool: ...
    def HasValue(self) -> bool: ...
    def IsValid(self) -> bool: ...
    def ValueMightBeTimeVarying(self) -> bool: ...
    def __bool__(self) -> bool: ...

class ClipsAPI(APISchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, schemaObj: SchemaBase) -> None: ...
    @overload
    def __init__(self, prim: Prim) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def ComputeClipAssetPaths(self, clipSet: str | pxr.Ar.ResolvedPath) -> list: ...
    @overload
    def ComputeClipAssetPaths(self) -> list: ...
    @overload
    def GenerateClipManifest(self, clipSet: str | pxr.Ar.ResolvedPath, writeBlocksForClipsWithMissingValues: bool = ...) -> pxr.Sdf.Layer: ...
    @overload
    def GenerateClipManifest(self, writeBlocksForClipsWithMissingValues: bool = ...) -> pxr.Sdf.Layer: ...
    @classmethod
    def GenerateClipManifestFromLayers(cls, clipLayers: list[pxr.Sdf.Layer], clipPrimPath: pxr.Sdf.Path | str) -> pxr.Sdf.Layer: ...
    @classmethod
    def Get(cls, stage: Stage, path: pxr.Sdf.Path | str) -> ClipsAPI: ...
    @overload
    def GetClipActive(self, clipSet: str | pxr.Ar.ResolvedPath) -> pxr.Vt.Vec2dArray: ...
    @overload
    def GetClipActive(self) -> pxr.Vt.Vec2dArray: ...
    @overload
    def GetClipAssetPaths(self, clipSet: str | pxr.Ar.ResolvedPath) -> list: ...
    @overload
    def GetClipAssetPaths(self) -> list: ...
    @overload
    def GetClipManifestAssetPath(self, clipSet: str | pxr.Ar.ResolvedPath) -> pxr.Sdf.AssetPath: ...
    @overload
    def GetClipManifestAssetPath(self) -> pxr.Sdf.AssetPath: ...
    @overload
    def GetClipPrimPath(self, clipSet: str | pxr.Ar.ResolvedPath) -> str: ...
    @overload
    def GetClipPrimPath(self) -> str: ...
    def GetClipSets(self) -> pxr.Sdf.StringListOp: ...
    @overload
    def GetClipTemplateActiveOffset(self, clipSet: str | pxr.Ar.ResolvedPath) -> float: ...
    @overload
    def GetClipTemplateActiveOffset(self) -> float: ...
    @overload
    def GetClipTemplateAssetPath(self, clipSet: str | pxr.Ar.ResolvedPath) -> str: ...
    @overload
    def GetClipTemplateAssetPath(self) -> str: ...
    @overload
    def GetClipTemplateEndTime(self, clipSet: str | pxr.Ar.ResolvedPath) -> float: ...
    @overload
    def GetClipTemplateEndTime(self) -> float: ...
    @overload
    def GetClipTemplateStartTime(self, clipSet: str | pxr.Ar.ResolvedPath) -> float: ...
    @overload
    def GetClipTemplateStartTime(self) -> float: ...
    @overload
    def GetClipTemplateStride(self, clipSet: str | pxr.Ar.ResolvedPath) -> float: ...
    @overload
    def GetClipTemplateStride(self) -> float: ...
    @overload
    def GetClipTimes(self, clipSet: str | pxr.Ar.ResolvedPath) -> pxr.Vt.Vec2dArray: ...
    @overload
    def GetClipTimes(self) -> pxr.Vt.Vec2dArray: ...
    def GetClips(self) -> dict: ...
    @overload
    def GetInterpolateMissingClipValues(self, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def GetInterpolateMissingClipValues(self) -> bool: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @overload
    def SetClipActive(self, activeClips: pxr.Vt.Vec2dArray | typing.Iterable[pxr.Gf.Vec2d], clipSet: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    def SetClipActive(self, activeClips: pxr.Vt.Vec2dArray | typing.Iterable[pxr.Gf.Vec2d]) -> None: ...
    @overload
    def SetClipAssetPaths(self, assetPaths: pxr.Sdf.AssetPathArray, clipSet: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    def SetClipAssetPaths(self, assetPaths: pxr.Sdf.AssetPathArray) -> None: ...
    @overload
    def SetClipManifestAssetPath(self, manifestAssetPath: pxr.Sdf.AssetPath | str, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetClipManifestAssetPath(self, manifestAssetPath: pxr.Sdf.AssetPath | str) -> bool: ...
    @overload
    def SetClipPrimPath(self, primPath: str | pxr.Ar.ResolvedPath, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetClipPrimPath(self, primPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetClipSets(self, clipSets: pxr.Sdf.StringListOp) -> bool: ...
    @overload
    def SetClipTemplateActiveOffset(self, clipTemplateActiveOffset: float, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetClipTemplateActiveOffset(self, clipTemplateActiveOffset: float) -> bool: ...
    @overload
    def SetClipTemplateAssetPath(self, clipTemplateAssetPath: str | pxr.Ar.ResolvedPath, clipSet: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    def SetClipTemplateAssetPath(self, clipTemplateAssetPath: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    def SetClipTemplateEndTime(self, clipTemplateEndTime: float, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetClipTemplateEndTime(self, clipTemplateEndTime: float) -> bool: ...
    @overload
    def SetClipTemplateStartTime(self, clipTemplateStartTime: float, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetClipTemplateStartTime(self, clipTemplateStartTime: float) -> bool: ...
    @overload
    def SetClipTemplateStride(self, clipTemplateStride: float, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetClipTemplateStride(self, clipTemplateStride: float) -> bool: ...
    @overload
    def SetClipTimes(self, clipTimes: pxr.Vt.Vec2dArray | typing.Iterable[pxr.Gf.Vec2d], clipSet: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    def SetClipTimes(self, clipTimes: pxr.Vt.Vec2dArray | typing.Iterable[pxr.Gf.Vec2d]) -> None: ...
    def SetClips(self, clips: dict) -> bool: ...
    @overload
    def SetInterpolateMissingClipValues(self, interpolate: bool, clipSet: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def SetInterpolateMissingClipValues(self, interpolate: bool) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...

class CollectionAPI(APISchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: Prim, arg3: object) -> None: ...
    @overload
    def __init__(self, arg2: SchemaBase, arg3: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Apply(cls, prim: Prim, name: str | pxr.Ar.ResolvedPath) -> CollectionAPI: ...
    def BlockCollection(self) -> bool: ...
    @classmethod
    def CanApply(cls, prim: Prim, name: str | pxr.Ar.ResolvedPath) -> _CanApplyResult: ...
    @classmethod
    def CanContainPropertyName(cls, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def ComputeIncludedObjects(cls, query: UsdCollectionMembershipQuery, stage: Stage, predicate: _PrimFlagsPredicate | _Term = ...) -> list[Object]: ...
    @classmethod
    def ComputeIncludedPaths(cls, query: UsdCollectionMembershipQuery, stage: Stage, predicate: _PrimFlagsPredicate | _Term = ...) -> list[pxr.Sdf.Path]: ...
    def ComputeMembershipQuery(self) -> UsdCollectionMembershipQuery: ...
    def CreateCollectionAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> Attribute: ...
    def CreateExcludesRel(self) -> Relationship: ...
    def CreateExpansionRuleAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> Attribute: ...
    def CreateIncludeRootAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> Attribute: ...
    def CreateIncludesRel(self) -> Relationship: ...
    def ExcludePath(self, pathToExclude: pxr.Sdf.Path | str) -> bool: ...
    @overload
    @classmethod
    def Get(cls, stage: Stage, path: pxr.Sdf.Path | str) -> CollectionAPI: ...
    @overload
    @classmethod
    def Get(cls, prim: Prim, name: str | pxr.Ar.ResolvedPath) -> CollectionAPI: ...
    @classmethod
    def GetAll(cls, prim: Prim) -> list[CollectionAPI]: ...
    @classmethod
    def GetAllCollections(cls, prim: Prim) -> list[CollectionAPI]: ...
    @overload
    @classmethod
    def GetCollection(cls, stage: Stage, collectionPath: pxr.Sdf.Path | str) -> CollectionAPI: ...
    @overload
    @classmethod
    def GetCollection(cls, prim: Prim, name: str | pxr.Ar.ResolvedPath) -> CollectionAPI: ...
    def GetCollectionAttr(self) -> Attribute: ...
    def GetCollectionPath(self) -> pxr.Sdf.Path: ...
    def GetExcludesRel(self) -> Relationship: ...
    def GetExpansionRuleAttr(self) -> Attribute: ...
    def GetIncludeRootAttr(self) -> Attribute: ...
    def GetIncludesRel(self) -> Relationship: ...
    def GetName(self) -> str: ...
    @classmethod
    def GetNamedCollectionPath(cls, prim: Prim, collectionName: str | pxr.Ar.ResolvedPath) -> pxr.Sdf.Path: ...
    @overload
    @classmethod
    def GetSchemaAttributeNames(cls, arg1: bool, includeInherited: str | pxr.Ar.ResolvedPath) -> list[str]: ...
    @overload
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def HasNoIncludedPaths(self) -> bool: ...
    def IncludePath(self, pathToInclude: pxr.Sdf.Path | str) -> bool: ...
    @classmethod
    def IsCollectionAPIPath(cls, arg1: pxr.Sdf.Path | str) -> bool: ...
    @classmethod
    def IsSchemaPropertyBaseName(cls, baseName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def ResetCollection(self) -> bool: ...
    def Validate(self) -> str: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...

class CompositionArc(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def GetArcType(self) -> Any: ...
    def GetIntroducingLayer(self) -> pxr.Sdf.Layer: ...
    def GetIntroducingListEditor(self) -> tuple: ...
    def GetIntroducingNode(self) -> pxr.Pcp.NodeRef: ...
    def GetIntroducingPrimPath(self) -> pxr.Sdf.Path: ...
    def GetTargetLayer(self) -> pxr.Sdf.Layer: ...
    def GetTargetNode(self) -> pxr.Pcp.NodeRef: ...
    def GetTargetPrimPath(self) -> pxr.Sdf.Path: ...
    def HasSpecs(self) -> bool: ...
    def IsAncestral(self) -> bool: ...
    def IsImplicit(self) -> bool: ...
    def IsIntroducedInRootLayerPrimSpec(self) -> bool: ...
    def IsIntroducedInRootLayerStack(self) -> bool: ...
    def MakeResolveTargetStrongerThan(self, subLayer: pxr.Sdf.Layer = ...) -> ResolveTarget: ...
    def MakeResolveTargetUpTo(self, subLayer: pxr.Sdf.Layer = ...) -> ResolveTarget: ...

class CrateInfo(Boost.Python.instance):
    class Section(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        name: Incomplete
        size: Incomplete
        start: Incomplete
        @overload
        def __init__(self, name: object, start: int, size: int) -> None: ...
        @overload
        def __init__(self) -> None: ...

    class SummaryStats(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        numSpecs: Incomplete
        numUniqueFieldSets: Incomplete
        numUniqueFields: Incomplete
        numUniquePaths: Incomplete
        numUniqueStrings: Incomplete
        numUniqueTokens: Incomplete
        def __init__(self) -> None: ...
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def GetFileVersion(self) -> str: ...
    def GetSections(self) -> list[CrateInfo.Section]: ...
    def GetSoftwareVersion(self) -> str: ...
    def GetSummaryStats(self) -> CrateInfo.SummaryStats: ...
    @classmethod
    def Open(cls, fileName: str | pxr.Ar.ResolvedPath) -> CrateInfo: ...
    def __bool__(self) -> bool: ...

class EditContext(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, stage: Stage, editTarget: EditTarget | pxr.Sdf.Layer = ...) -> None: ...
    def __enter__(self) -> EditContext: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class EditTarget(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, layer: pxr.Sdf.Layer, node: pxr.Pcp.NodeRef = ...) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComposeOver(self, weaker: EditTarget | pxr.Sdf.Layer) -> EditTarget: ...
    @classmethod
    def ForLocalDirectVariant(cls, layer: pxr.Sdf.Layer, varSelPath: pxr.Sdf.Path | str) -> EditTarget: ...
    def GetLayer(self) -> pxr.Sdf.Layer: ...
    def GetMapFunction(self) -> pxr.Pcp.MapFunction: ...
    def GetPrimSpecForScenePath(self, scenePath: pxr.Sdf.Path | str) -> pxr.Sdf.PrimSpec: ...
    def GetPropertySpecForScenePath(self, scenePath: pxr.Sdf.Path | str) -> pxr.Sdf.PropertySpec: ...
    def GetSpecForScenePath(self, scenePath: pxr.Sdf.Path | str) -> pxr.Sdf.PrimSpec: ...
    def IsNull(self) -> bool: ...
    def IsValid(self) -> bool: ...
    def MapToSpecPath(self, scenePath: pxr.Sdf.Path | str) -> pxr.Sdf.Path: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Inherits(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInherit(self, primPath: pxr.Sdf.Path | str, position: ListPosition = ...) -> bool: ...
    def ClearInherits(self) -> bool: ...
    def GetAllDirectInherits(self) -> list[pxr.Sdf.Path]: ...
    def GetPrim(self) -> Prim: ...
    def RemoveInherit(self, primPath: pxr.Sdf.Path | str) -> bool: ...
    def SetInherits(self, arg2: typing.Iterable[pxr.Sdf.Path | str]) -> bool: ...
    def __bool__(self) -> bool: ...

class InterpolationType(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetValueFromName(self, name: object) -> Any: ...

class ListPosition(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetValueFromName(self, name: object) -> Any: ...

class LoadPolicy(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetValueFromName(self, name: object) -> Any: ...

class ModelAPI(APISchemaBase):
    class KindValidation(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
    KindValidationModelHierarchy: ClassVar[ModelAPI.KindValidation] = ...
    KindValidationNone: ClassVar[ModelAPI.KindValidation] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, schemaObj: SchemaBase) -> None: ...
    @overload
    def __init__(self, prim: Prim) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Get(cls, stage: Stage, path: pxr.Sdf.Path | str) -> ModelAPI: ...
    def GetAssetIdentifier(self) -> pxr.Sdf.AssetPath: ...
    def GetAssetInfo(self) -> dict: ...
    def GetAssetName(self) -> str: ...
    def GetAssetVersion(self) -> str: ...
    def GetKind(self) -> str: ...
    def GetPayloadAssetDependencies(self) -> pxr.Sdf.AssetPathArray: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def IsGroup(self) -> bool: ...
    def IsKind(self, baseKind: str | pxr.Ar.ResolvedPath, validation: pxr.Kind.Validation = ...) -> bool: ...
    def IsModel(self) -> bool: ...
    def SetAssetIdentifier(self, arg2: pxr.Sdf.AssetPath | str) -> None: ...
    def SetAssetInfo(self, arg2: dict) -> None: ...
    def SetAssetName(self, arg2: str | pxr.Ar.ResolvedPath) -> None: ...
    def SetAssetVersion(self, arg2: str | pxr.Ar.ResolvedPath) -> None: ...
    def SetKind(self, value: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetPayloadAssetDependencies(self, arg2: pxr.Sdf.AssetPathArray) -> None: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...

class Notice(Boost.Python.instance):
    class LayerMutingChanged(Notice.StageNotice):
        def __init__(self, *args, **kwargs) -> None: ...
        def GetMutedLayers(self) -> list: ...
        def GetUnmutedLayers(self) -> list: ...

    class ObjectsChanged(Notice.StageNotice):
        def __init__(self, *args, **kwargs) -> None: ...
        def AffectedObject(self, arg2: Object | pxr.UsdGeom.XformOp) -> bool: ...
        def ChangedInfoOnly(self, arg2: Object | pxr.UsdGeom.XformOp) -> bool: ...
        @overload
        def GetChangedFields(self, arg2: Object | pxr.UsdGeom.XformOp) -> Any: ...
        @overload
        def GetChangedFields(self, arg2: pxr.Sdf.Path | str) -> Any: ...
        def GetChangedInfoOnlyPaths(self) -> Any: ...
        def GetResyncedPaths(self) -> Any: ...
        @overload
        def HasChangedFields(self, arg2: Object | pxr.UsdGeom.XformOp) -> bool: ...
        @overload
        def HasChangedFields(self, arg2: pxr.Sdf.Path | str) -> bool: ...
        def ResyncedObject(self, arg2: Object | pxr.UsdGeom.XformOp) -> bool: ...

    class StageContentsChanged(Notice.StageNotice):
        def __init__(self, *args, **kwargs) -> None: ...

    class StageEditTargetChanged(Notice.StageNotice):
        def __init__(self, *args, **kwargs) -> None: ...

    class StageNotice(pxr.Tf.Notice):
        def __init__(self, *args, **kwargs) -> None: ...
        def GetStage(self) -> Stage: ...
    def __init__(self, *args, **kwargs) -> None: ...

class Object(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def ClearAssetInfo(self) -> None: ...
    def ClearAssetInfoByKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> None: ...
    def ClearCustomData(self) -> None: ...
    def ClearCustomDataByKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> None: ...
    def ClearDisplayName(self) -> bool: ...
    def ClearDocumentation(self) -> bool: ...
    def ClearHidden(self) -> bool: ...
    def ClearMetadata(self, key: str | pxr.Ar.ResolvedPath) -> bool: ...
    def ClearMetadataByDictKey(self, key: str | pxr.Ar.ResolvedPath, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def GetAllAuthoredMetadata(self) -> dict: ...
    def GetAllMetadata(self) -> dict: ...
    def GetAssetInfo(self) -> dict: ...
    def GetAssetInfoByKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> Any: ...
    def GetCustomData(self) -> dict: ...
    def GetCustomDataByKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> Any: ...
    def GetDescription(self) -> str: ...
    def GetDisplayName(self) -> str: ...
    def GetDocumentation(self) -> str: ...
    def GetMetadata(self, key: object) -> Any: ...
    def GetMetadataByDictKey(self, key: object, keyPath: object) -> Any: ...
    def GetName(self) -> str: ...
    @classmethod
    def GetNamespaceDelimiter(cls) -> str: ...
    def GetPath(self) -> pxr.Sdf.Path: ...
    def GetPrim(self) -> Prim: ...
    def GetPrimPath(self) -> pxr.Sdf.Path: ...
    def GetStage(self) -> Stage: ...
    def HasAssetInfo(self) -> bool: ...
    def HasAssetInfoKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredAssetInfo(self) -> bool: ...
    def HasAuthoredAssetInfoKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredCustomData(self) -> bool: ...
    def HasAuthoredCustomDataKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredDisplayName(self) -> bool: ...
    def HasAuthoredDocumentation(self) -> bool: ...
    def HasAuthoredHidden(self) -> bool: ...
    def HasAuthoredMetadata(self, key: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredMetadataDictKey(self, key: str | pxr.Ar.ResolvedPath, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasCustomData(self) -> bool: ...
    def HasCustomDataKey(self, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasMetadata(self, key: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasMetadataDictKey(self, key: str | pxr.Ar.ResolvedPath, keyPath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def IsHidden(self) -> bool: ...
    def IsValid(self) -> bool: ...
    def SetAssetInfo(self, assetInfo: dict) -> None: ...
    def SetAssetInfoByKey(self, keyPath: str | pxr.Ar.ResolvedPath, value: Any) -> None: ...
    def SetCustomData(self, customData: dict) -> None: ...
    def SetCustomDataByKey(self, keyPath: str | pxr.Ar.ResolvedPath, value: Any) -> None: ...
    def SetDisplayName(self, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetDocumentation(self, doc: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetHidden(self, hidden: bool) -> bool: ...
    def SetMetadata(self, key: object, value: object) -> bool: ...
    def SetMetadataByDictKey(self, key: object, keyPath: object, value: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class Payloads(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInternalPayload(self, primPath: pxr.Sdf.Path | str, layerOffset: pxr.Sdf.LayerOffset = ..., position: ListPosition = ...) -> bool: ...
    @overload
    def AddPayload(self, assetPath: str | pxr.Ar.ResolvedPath, primPath: pxr.Sdf.Path | str, layerOffset: pxr.Sdf.LayerOffset = ..., position: ListPosition = ...) -> bool: ...
    @overload
    def AddPayload(self, assetPath: str | pxr.Ar.ResolvedPath, layerOffset: pxr.Sdf.LayerOffset = ..., position: ListPosition = ...) -> bool: ...
    @overload
    def AddPayload(self, payload: pxr.Sdf.Payload, position: ListPosition = ...) -> bool: ...
    def ClearPayloads(self) -> bool: ...
    def GetPrim(self) -> Prim: ...
    def RemovePayload(self, payload: pxr.Sdf.Payload) -> bool: ...
    def SetPayloads(self, arg2: list[pxr.Sdf.Payload]) -> bool: ...
    def __bool__(self) -> bool: ...

class Prim(Object):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def AddAppliedSchema(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    def ApplyAPI(self, schemaFamily: object, schemaVersion: int, instanceName: object) -> bool: ...
    @overload
    def ApplyAPI(self, schemaType: pxr.Tf.Type, instanceName: object) -> bool: ...
    @overload
    def ApplyAPI(self, schemaIdentifier: object, instanceName: object) -> bool: ...
    @overload
    def ApplyAPI(self, schemaFamily: object, schemaVersion: int) -> bool: ...
    @overload
    def ApplyAPI(self, schemaType: pxr.Tf.Type) -> bool: ...
    @overload
    def ApplyAPI(self, schemaIdentifier: object) -> bool: ...
    @overload
    def CanApplyAPI(self, schemaFamily: object, schemaVersion: int, instanceName: object) -> _CanApplyAPIResult: ...
    @overload
    def CanApplyAPI(self, schemaType: pxr.Tf.Type, instanceName: object) -> _CanApplyAPIResult: ...
    @overload
    def CanApplyAPI(self, schemaIdentifier: object, instanceName: object) -> _CanApplyAPIResult: ...
    @overload
    def CanApplyAPI(self, schemaFamily: object, schemaVersion: int) -> _CanApplyAPIResult: ...
    @overload
    def CanApplyAPI(self, schemaType: pxr.Tf.Type) -> _CanApplyAPIResult: ...
    @overload
    def CanApplyAPI(self, schemaIdentifier: object) -> _CanApplyAPIResult: ...
    def ClearActive(self) -> bool: ...
    def ClearChildrenReorder(self) -> None: ...
    def ClearInstanceable(self) -> bool: ...
    def ClearPayload(self) -> bool: ...
    def ClearPropertyOrder(self) -> None: ...
    def ClearTypeName(self) -> bool: ...
    def ComputeExpandedPrimIndex(self) -> pxr.Pcp.PrimIndex: ...
    @overload
    def CreateAttribute(self, nameElts: object, typeName: pxr.Sdf.ValueTypeName, custom: bool = ..., variability: object = ...) -> Attribute: ...
    @overload
    def CreateAttribute(self, name: object, typeName: pxr.Sdf.ValueTypeName, custom: bool = ..., variability: object = ...) -> Attribute: ...
    @overload
    def CreateRelationship(self, nameElts: str | pxr.Ar.ResolvedPath, custom: bool = ...) -> Relationship: ...
    @overload
    def CreateRelationship(self, name: typing.Iterable[str | pxr.Ar.ResolvedPath], custom: bool = ...) -> Relationship: ...
    def FindAllAttributeConnectionPaths(self, predicate: typing.Callable[[Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output], bool] = ..., recurseOnSources: bool = ...) -> list[pxr.Sdf.Path]: ...
    def FindAllRelationshipTargetPaths(self, predicate: typing.Callable[[Relationship], bool] = ..., recurseOnTargets: bool = ...) -> list[pxr.Sdf.Path]: ...
    def GetAllChildren(self) -> list: ...
    def GetAllChildrenNames(self) -> list[str]: ...
    def GetAppliedSchemas(self) -> list[str]: ...
    def GetAttribute(self, attrName: str | pxr.Ar.ResolvedPath) -> Attribute: ...
    def GetAttributeAtPath(self, path: pxr.Sdf.Path | str) -> Attribute: ...
    def GetAttributes(self) -> list[Attribute]: ...
    def GetAuthoredAttributes(self) -> list[Attribute]: ...
    def GetAuthoredProperties(self, predicate: PropertyPredicateFunc = ...) -> list[Property]: ...
    @overload
    def GetAuthoredPropertiesInNamespace(self, namespaces: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> list[Property]: ...
    @overload
    def GetAuthoredPropertiesInNamespace(self, namespaces: str | pxr.Ar.ResolvedPath) -> list[Property]: ...
    def GetAuthoredPropertyNames(self, predicate: PropertyPredicateFunc = ...) -> list[str]: ...
    def GetAuthoredRelationships(self) -> list[Relationship]: ...
    def GetChild(self, name: str | pxr.Ar.ResolvedPath) -> Prim: ...
    def GetChildren(self) -> list: ...
    def GetChildrenNames(self) -> list[str]: ...
    def GetChildrenReorder(self) -> list[str]: ...
    def GetFilteredChildren(self, predicate: _PrimFlagsPredicate | _Term) -> list: ...
    def GetFilteredChildrenNames(self, arg2: _PrimFlagsPredicate | _Term) -> list[str]: ...
    def GetFilteredNextSibling(self, arg2: _PrimFlagsPredicate | _Term) -> Prim: ...
    def GetInherits(self) -> Inherits: ...
    def GetInstances(self) -> list[Prim]: ...
    def GetNextSibling(self) -> Prim: ...
    def GetObjectAtPath(self, path: pxr.Sdf.Path | str) -> Object: ...
    def GetParent(self) -> Prim: ...
    def GetPayloads(self) -> Payloads: ...
    def GetPrimAtPath(self, path: pxr.Sdf.Path | str) -> Prim: ...
    def GetPrimDefinition(self) -> PrimDefinition: ...
    def GetPrimInPrototype(self) -> Prim: ...
    def GetPrimIndex(self) -> pxr.Pcp.PrimIndex: ...
    def GetPrimStack(self) -> list[pxr.Sdf.PrimSpec]: ...
    def GetPrimStackWithLayerOffsets(self) -> list[tuple[pxr.Sdf.PrimSpec, pxr.Sdf.LayerOffset]]: ...
    def GetPrimTypeInfo(self) -> PrimTypeInfo: ...
    def GetProperties(self, predicate: PropertyPredicateFunc = ...) -> list[Property]: ...
    @overload
    def GetPropertiesInNamespace(self, namespaces: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> list[Property]: ...
    @overload
    def GetPropertiesInNamespace(self, namespaces: str | pxr.Ar.ResolvedPath) -> list[Property]: ...
    def GetProperty(self, propName: str | pxr.Ar.ResolvedPath) -> Property: ...
    def GetPropertyAtPath(self, path: pxr.Sdf.Path | str) -> Property: ...
    def GetPropertyNames(self, predicate: PropertyPredicateFunc = ...) -> list[str]: ...
    def GetPropertyOrder(self) -> list[str]: ...
    def GetPrototype(self) -> Prim: ...
    def GetReferences(self) -> References: ...
    def GetRelationship(self, relName: str | pxr.Ar.ResolvedPath) -> Relationship: ...
    def GetRelationshipAtPath(self, path: pxr.Sdf.Path | str) -> Relationship: ...
    def GetRelationships(self) -> list[Relationship]: ...
    def GetSpecializes(self) -> Specializes: ...
    def GetSpecifier(self) -> pxr.Sdf.Specifier: ...
    def GetTypeName(self) -> str: ...
    def GetVariantSet(self, arg2: str | pxr.Ar.ResolvedPath) -> VariantSet: ...
    def GetVariantSets(self) -> VariantSets: ...
    @overload
    def GetVersionIfHasAPIInFamily(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> int: ...
    @overload
    def GetVersionIfHasAPIInFamily(self, arg2: str | pxr.Ar.ResolvedPath) -> int: ...
    def GetVersionIfIsInFamily(self, arg2: str | pxr.Ar.ResolvedPath) -> int: ...
    @overload
    def HasAPI(self, schemaFamily: object, schemaVersion: int, instanceName: object) -> bool: ...
    @overload
    def HasAPI(self, schemaType: pxr.Tf.Type, instanceName: object) -> bool: ...
    @overload
    def HasAPI(self, schemaIdentifier: object, instanceName: object) -> bool: ...
    @overload
    def HasAPI(self, schemaFamily: object, schemaVersion: int) -> bool: ...
    @overload
    def HasAPI(self, schemaType: pxr.Tf.Type) -> bool: ...
    @overload
    def HasAPI(self, schemaIdentifier: object) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaFamily: object, schemaVersion: int, versionPolicy: SchemaRegistry.VersionPolicy, instanceName: object) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaType: pxr.Tf.Type, versionPolicy: SchemaRegistry.VersionPolicy, instanceName: object) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaIdentifier: object, versionPolicy: SchemaRegistry.VersionPolicy, instanceName: object) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaFamily: object, schemaVersion: int, versionPolicy: SchemaRegistry.VersionPolicy) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaType: pxr.Tf.Type, versionPolicy: SchemaRegistry.VersionPolicy) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaIdentifier: object, versionPolicy: SchemaRegistry.VersionPolicy) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaFamily: object, instanceName: object) -> bool: ...
    @overload
    def HasAPIInFamily(self, schemaFamily: object) -> bool: ...
    def HasAttribute(self, attrName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredActive(self) -> bool: ...
    def HasAuthoredInherits(self) -> bool: ...
    def HasAuthoredInstanceable(self) -> bool: ...
    def HasAuthoredPayloads(self) -> bool: ...
    def HasAuthoredReferences(self) -> bool: ...
    def HasAuthoredSpecializes(self) -> bool: ...
    def HasAuthoredTypeName(self) -> bool: ...
    def HasDefiningSpecifier(self) -> bool: ...
    def HasPayload(self) -> bool: ...
    def HasProperty(self, propName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasRelationship(self, relName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasVariantSets(self) -> bool: ...
    @overload
    def IsA(self, schemaFamily: object, version: int) -> bool: ...
    @overload
    def IsA(self, schemaType: pxr.Tf.Type) -> bool: ...
    @overload
    def IsA(self, schemaIdentifier: object) -> bool: ...
    def IsAbstract(self) -> bool: ...
    def IsActive(self) -> bool: ...
    def IsDefined(self) -> bool: ...
    def IsGroup(self) -> bool: ...
    @overload
    def IsInFamily(self, schemaFamily: object, version: int, versionPolicy: SchemaRegistry.VersionPolicy) -> bool: ...
    @overload
    def IsInFamily(self, schemaType: pxr.Tf.Type, versionPolicy: SchemaRegistry.VersionPolicy) -> bool: ...
    @overload
    def IsInFamily(self, schemaIdentifier: object, versionPolicy: SchemaRegistry.VersionPolicy) -> bool: ...
    @overload
    def IsInFamily(self, schemaFamily: object) -> bool: ...
    def IsInPrototype(self) -> bool: ...
    def IsInstance(self) -> bool: ...
    def IsInstanceProxy(self) -> bool: ...
    def IsInstanceable(self) -> bool: ...
    def IsLoaded(self) -> bool: ...
    def IsModel(self) -> bool: ...
    @classmethod
    def IsPathInPrototype(cls, path: pxr.Sdf.Path | str) -> bool: ...
    def IsPrototype(self) -> bool: ...
    @classmethod
    def IsPrototypePath(cls, path: pxr.Sdf.Path | str) -> bool: ...
    def IsPseudoRoot(self) -> bool: ...
    def Load(self, policy: LoadPolicy = ...) -> None: ...
    def MakeResolveTargetStrongerThanEditTarget(self, arg2: EditTarget | pxr.Sdf.Layer) -> ResolveTarget: ...
    def MakeResolveTargetUpToEditTarget(self, arg2: EditTarget | pxr.Sdf.Layer) -> ResolveTarget: ...
    @overload
    def RemoveAPI(self, schemaFamily: object, schemaVersion: int, instanceName: object) -> bool: ...
    @overload
    def RemoveAPI(self, schemaType: pxr.Tf.Type, instanceName: object) -> bool: ...
    @overload
    def RemoveAPI(self, schemaIdentifier: object, instanceName: object) -> bool: ...
    @overload
    def RemoveAPI(self, schemaFamily: object, schemaVersion: int) -> bool: ...
    @overload
    def RemoveAPI(self, schemaType: pxr.Tf.Type) -> bool: ...
    @overload
    def RemoveAPI(self, schemaIdentifier: object) -> bool: ...
    def RemoveAppliedSchema(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def RemoveProperty(self, propName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetActive(self, active: bool) -> bool: ...
    def SetChildrenReorder(self, order: list[str] | list[pxr.Ar.ResolvedPath]) -> None: ...
    def SetInstanceable(self, instanceable: bool) -> bool: ...
    @overload
    def SetPayload(self, layer: pxr.Sdf.Layer, primPath: pxr.Sdf.Path | str) -> bool: ...
    @overload
    def SetPayload(self, assetPath: str | pxr.Ar.ResolvedPath, primPath: pxr.Sdf.Path | str) -> bool: ...
    @overload
    def SetPayload(self, payload: pxr.Sdf.Payload) -> bool: ...
    def SetPropertyOrder(self, order: list[str] | list[pxr.Ar.ResolvedPath]) -> None: ...
    def SetSpecifier(self, specifier: pxr.Sdf.Specifier) -> bool: ...
    def SetTypeName(self, typeName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def Unload(self) -> None: ...
    def _GetSourcePrimIndex(self) -> pxr.Pcp.PrimIndex: ...

class PrimCompositionQuery(Boost.Python.instance):
    class ArcIntroducedFilter(Boost.Python.enum):
        All: ClassVar[PrimCompositionQuery.ArcIntroducedFilter] = ...
        IntroducedInRootLayerPrimSpec: ClassVar[PrimCompositionQuery.ArcIntroducedFilter] = ...
        IntroducedInRootLayerStack: ClassVar[PrimCompositionQuery.ArcIntroducedFilter] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...

    class ArcTypeFilter(Boost.Python.enum):
        All: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        Inherit: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        InheritOrSpecialize: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        NotInheritOrSpecialize: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        NotReferenceOrPayload: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        NotVariant: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        Payload: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        Reference: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        ReferenceOrPayload: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        Specialize: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        Variant: ClassVar[PrimCompositionQuery.ArcTypeFilter] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...

    class DependencyTypeFilter(Boost.Python.enum):
        All: ClassVar[PrimCompositionQuery.DependencyTypeFilter] = ...
        Ancestral: ClassVar[PrimCompositionQuery.DependencyTypeFilter] = ...
        Direct: ClassVar[PrimCompositionQuery.DependencyTypeFilter] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...

    class Filter(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        arcIntroducedFilter: Incomplete
        arcTypeFilter: Incomplete
        dependencyTypeFilter: Incomplete
        hasSpecsFilter: Incomplete
        def __init__(self) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...

    class HasSpecsFilter(Boost.Python.enum):
        All: ClassVar[PrimCompositionQuery.HasSpecsFilter] = ...
        HasNoSpecs: ClassVar[PrimCompositionQuery.HasSpecsFilter] = ...
        HasSpecs: ClassVar[PrimCompositionQuery.HasSpecsFilter] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...
    filter: PrimCompositionQuery.Filter
    @overload
    def __init__(self, prim: Prim, filter: PrimCompositionQuery.Filter) -> None: ...
    @overload
    def __init__(self, prim: Prim) -> None: ...
    def GetCompositionArcs(self) -> list[PrimCompositionQueryArc]: ...
    @classmethod
    def GetDirectInherits(cls, arg1: Prim) -> PrimCompositionQuery: ...
    @classmethod
    def GetDirectReferences(cls, arg1: Prim) -> PrimCompositionQuery: ...
    @classmethod
    def GetDirectRootLayerArcs(cls, arg1: Prim) -> PrimCompositionQuery: ...

class PrimDefinition(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def FlattenTo(self, parent: Prim, name: str | pxr.Ar.ResolvedPath, newSpecSpecifier: pxr.Sdf.Specifier = ...) -> Prim: ...
    @overload
    def FlattenTo(self, layer: pxr.Sdf.Layer, path: pxr.Sdf.Path | str, newSpecSpecifier: pxr.Sdf.Specifier = ...) -> bool: ...
    @overload
    def FlattenTo(self, prim: Prim, newSpecSpecifier: pxr.Sdf.Specifier = ...) -> Prim: ...
    def GetAppliedAPISchemas(self) -> list[str]: ...
    def GetAttributeFallbackValue(self, attrName: PrimDefinition, key: T) -> bool: ...
    def GetDocumentation(self) -> str: ...
    def GetMetadata(self, key: str | pxr.Ar.ResolvedPath) -> T: ...
    def GetMetadataByDictKey(self, key: str | pxr.Ar.ResolvedPath, keyPath: str | pxr.Ar.ResolvedPath) -> T: ...
    def GetPropertyDocumentation(self, propName: str | pxr.Ar.ResolvedPath) -> str: ...
    def GetPropertyMetadata(self, propName: str | pxr.Ar.ResolvedPath, key: str | pxr.Ar.ResolvedPath) -> T: ...
    def GetPropertyMetadataByDictKey(self, propName: str | pxr.Ar.ResolvedPath, key: str | pxr.Ar.ResolvedPath, keyPath: str | pxr.Ar.ResolvedPath) -> T: ...
    def GetPropertyNames(self) -> list[str]: ...
    def GetSchemaAttributeSpec(self, attrName: str | pxr.Ar.ResolvedPath) -> pxr.Sdf.AttributeSpec: ...
    def GetSchemaPropertySpec(self, propName: str | pxr.Ar.ResolvedPath) -> pxr.Sdf.PropertySpec: ...
    def GetSchemaRelationshipSpec(self, relName: str | pxr.Ar.ResolvedPath) -> pxr.Sdf.RelationshipSpec: ...
    def ListMetadataFields(self) -> list[str]: ...
    def ListPropertyMetadataFields(self, arg2: str | pxr.Ar.ResolvedPath) -> list[str]: ...

class PrimRange(Boost.Python.instance):
    class _Iterator(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        @overload
        def GetCurrentPrim(self) -> Prim: ...
        @overload
        def GetCurrentPrim(self) -> typing.Any: ...
        def IsPostVisit(self) -> bool: ...
        def IsValid(self) -> bool: ...
        def PruneChildren(self) -> None: ...
        def __iter__(self) -> typing_extensions.Self: ...
        def __next__(self) -> Prim: ...
    @overload
    def __init__(self, root: Prim, predicate: _PrimFlagsPredicate | _Term) -> None: ...
    @overload
    def __init__(self, root: Prim) -> None: ...
    @classmethod
    def AllPrims(cls, root: Prim) -> PrimRange: ...
    @classmethod
    def AllPrimsPreAndPostVisit(cls, root: Prim) -> PrimRange: ...
    def IsValid(self) -> bool: ...
    @overload
    @classmethod
    def PreAndPostVisit(cls, root: Prim, predicate: _PrimFlagsPredicate | _Term) -> PrimRange: ...
    @overload
    @classmethod
    def PreAndPostVisit(cls, root: Prim) -> PrimRange: ...
    @overload
    @classmethod
    def Stage(cls, stage: Stage, predicate: _PrimFlagsPredicate | _Term) -> PrimRange: ...
    @overload
    @classmethod
    def Stage(cls, stage: Stage) -> PrimRange: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __iter__(self) -> _Iterator: ...
    def __ne__(self, other: object) -> bool: ...

class PrimTypeInfo(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def GetAppliedAPISchemas(self) -> list[str]: ...
    @classmethod
    def GetEmptyPrimType(cls) -> PrimTypeInfo: ...
    def GetPrimDefinition(self) -> PrimDefinition: ...
    def GetSchemaType(self) -> pxr.Tf.Type: ...
    def GetSchemaTypeName(self) -> str: ...
    def GetTypeName(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Property(Object):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def ClearDisplayGroup(self) -> bool: ...
    @overload
    def FlattenTo(self, parent: Prim, propName: str | pxr.Ar.ResolvedPath) -> Property: ...
    @overload
    def FlattenTo(self, property: Property | pxr.UsdGeom.XformOp) -> Property: ...
    @overload
    def FlattenTo(self, parent: Prim) -> Property: ...
    def GetBaseName(self) -> str: ...
    def GetDisplayGroup(self) -> str: ...
    def GetNamespace(self) -> str: ...
    def GetNestedDisplayGroups(self) -> list[str]: ...
    def GetPropertyStack(self, time: TimeCode | float | pxr.Sdf.TimeCode = ...) -> list[pxr.Sdf.PropertySpec]: ...
    def GetPropertyStackWithLayerOffsets(self, time: TimeCode | float | pxr.Sdf.TimeCode = ...) -> list[tuple[pxr.Sdf.PropertySpec, pxr.Sdf.LayerOffset]]: ...
    def HasAuthoredDisplayGroup(self) -> bool: ...
    def IsAuthored(self) -> bool: ...
    def IsAuthoredAt(self, editTarget: EditTarget | pxr.Sdf.Layer) -> bool: ...
    def IsCustom(self) -> bool: ...
    def IsDefined(self) -> bool: ...
    def SetCustom(self, isCustom: bool) -> bool: ...
    def SetDisplayGroup(self, displayGroup: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetNestedDisplayGroups(self, nestedGroups: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> bool: ...
    def SplitName(self) -> list[str]: ...

class References(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInternalReference(self, primPath: pxr.Sdf.Path | str, layerOffset: pxr.Sdf.LayerOffset = ..., position: ListPosition = ...) -> bool: ...
    @overload
    def AddReference(self, assetPath: str | pxr.Ar.ResolvedPath, primPath: pxr.Sdf.Path | str, layerOffset: pxr.Sdf.LayerOffset = ..., position: ListPosition = ...) -> bool: ...
    @overload
    def AddReference(self, assetPath: str | pxr.Ar.ResolvedPath, layerOffset: pxr.Sdf.LayerOffset = ..., position: ListPosition = ...) -> bool: ...
    @overload
    def AddReference(self, ref: pxr.Sdf.Reference, position: ListPosition = ...) -> bool: ...
    def ClearReferences(self) -> bool: ...
    def GetPrim(self) -> Prim: ...
    def RemoveReference(self, ref: pxr.Sdf.Reference) -> bool: ...
    def SetReferences(self, arg2: list[pxr.Sdf.Reference]) -> bool: ...
    def __bool__(self) -> bool: ...

class Relationship(Property):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def AddTarget(self, target: pxr.Sdf.Path | str, position: ListPosition = ...) -> bool: ...
    def ClearTargets(self, removeSpec: bool) -> bool: ...
    def GetForwardedTargets(self) -> list[pxr.Sdf.Path]: ...
    def GetTargets(self) -> list[pxr.Sdf.Path]: ...
    def HasAuthoredTargets(self) -> bool: ...
    def RemoveTarget(self, target: pxr.Sdf.Path | str) -> bool: ...
    def SetTargets(self, targets: typing.Iterable[pxr.Sdf.Path | str]) -> bool: ...

class ResolveInfo(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def GetNode(self) -> pxr.Pcp.NodeRef: ...
    def GetSource(self) -> ResolveInfoSource: ...
    def ValueIsBlocked(self) -> bool: ...

class ResolveInfoSource(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetValueFromName(self, name: object) -> Any: ...

class ResolveTarget(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def GetPrimIndex(self) -> pxr.Pcp.PrimIndex: ...
    def GetStartLayer(self) -> pxr.Sdf.Layer: ...
    def GetStartNode(self) -> pxr.Pcp.NodeRef: ...
    def GetStopLayer(self) -> pxr.Sdf.Layer: ...
    def GetStopNode(self) -> pxr.Pcp.NodeRef: ...
    def IsNull(self) -> bool: ...

class SchemaBase(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: Prim) -> None: ...
    @overload
    def __init__(self, otherSchema: SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def GetPath(self) -> pxr.Sdf.Path: ...
    def GetPrim(self) -> Prim: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetSchemaClassPrimDefinition(self) -> PrimDefinition: ...
    def GetSchemaKind(self) -> SchemaKind: ...
    def IsAPISchema(self) -> bool: ...
    def IsAppliedAPISchema(self) -> bool: ...
    def IsConcrete(self) -> bool: ...
    def IsMultipleApplyAPISchema(self) -> bool: ...
    def IsTyped(self) -> bool: ...
    def __bool__(self) -> bool: ...

class SchemaKind(Boost.Python.enum):
    AbstractBase: ClassVar[SchemaKind] = ...
    AbstractTyped: ClassVar[SchemaKind] = ...
    ConcreteTyped: ClassVar[SchemaKind] = ...
    Invalid: ClassVar[SchemaKind] = ...
    MultipleApplyAPI: ClassVar[SchemaKind] = ...
    NonAppliedAPI: ClassVar[SchemaKind] = ...
    SingleApplyAPI: ClassVar[SchemaKind] = ...
    names: ClassVar[dict] = ...
    values: ClassVar[dict] = ...

class SchemaRegistry(Boost.Python.instance):
    class SchemaInfo(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def family(self): ...
        @property
        def identifier(self): ...
        @property
        def kind(self): ...
        @property
        def type(self): ...
        @property
        def version(self): ...

    class VersionPolicy(Boost.Python.enum):
        All: ClassVar[SchemaRegistry.VersionPolicy] = ...
        GreaterThan: ClassVar[SchemaRegistry.VersionPolicy] = ...
        GreaterThanOrEqual: ClassVar[SchemaRegistry.VersionPolicy] = ...
        LessThan: ClassVar[SchemaRegistry.VersionPolicy] = ...
        LessThanOrEqual: ClassVar[SchemaRegistry.VersionPolicy] = ...
        names: ClassVar[dict] = ...
        values: ClassVar[dict] = ...
    def __init__(self) -> None: ...
    def BuildComposedPrimDefinition(self, arg2: str | pxr.Ar.ResolvedPath, arg3: list[str] | list[pxr.Ar.ResolvedPath]) -> PrimDefinition: ...
    def FindAppliedAPIPrimDefinition(self, typeName: str | pxr.Ar.ResolvedPath) -> PrimDefinition: ...
    def FindConcretePrimDefinition(self, typeName: str | pxr.Ar.ResolvedPath) -> PrimDefinition: ...
    @overload
    @classmethod
    def FindSchemaInfo(cls, schemaFamily: object, schemaVersion: int) -> SchemaRegistry.SchemaInfo: ...
    @overload
    @classmethod
    def FindSchemaInfo(cls, schemaType: pxr.Tf.Type) -> SchemaRegistry.SchemaInfo: ...
    @overload
    @classmethod
    def FindSchemaInfo(cls, schemaIdentifier: object) -> SchemaRegistry.SchemaInfo: ...
    @overload
    @classmethod
    def FindSchemaInfosInFamily(cls, schemaFamily: str | pxr.Ar.ResolvedPath, schemaVersion: int, versionPolicy: SchemaRegistry.VersionPolicy) -> list[SchemaRegistry.SchemaInfo]: ...
    @overload
    @classmethod
    def FindSchemaInfosInFamily(cls, schemaFamily: str | pxr.Ar.ResolvedPath) -> list[SchemaRegistry.SchemaInfo]: ...
    @classmethod
    def GetAPISchemaCanOnlyApplyToTypeNames(cls, apiSchemaName: str | pxr.Ar.ResolvedPath, instanceName: str | pxr.Ar.ResolvedPath = ...) -> list[str]: ...
    @classmethod
    def GetAPISchemaTypeName(cls, schemaType: pxr.Tf.Type) -> str: ...
    @classmethod
    def GetAPITypeFromSchemaTypeName(cls, typeName: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
    @classmethod
    def GetAutoApplyAPISchemas(cls) -> dict: ...
    @classmethod
    def GetConcreteSchemaTypeName(cls, schemaType: pxr.Tf.Type) -> str: ...
    @classmethod
    def GetConcreteTypeFromSchemaTypeName(cls, typeName: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
    def GetEmptyPrimDefinition(self) -> PrimDefinition: ...
    def GetFallbackPrimTypes(self) -> dict: ...
    @classmethod
    def GetMultipleApplyNameTemplateBaseName(cls, nameTemplate: str | pxr.Ar.ResolvedPath) -> str: ...
    @overload
    @classmethod
    def GetSchemaKind(cls, primType: pxr.Tf.Type) -> SchemaKind: ...
    @overload
    @classmethod
    def GetSchemaKind(cls, primType: str | pxr.Ar.ResolvedPath) -> SchemaKind: ...
    @classmethod
    def GetSchemaTypeName(cls, schemaType: pxr.Tf.Type) -> Any: ...
    @classmethod
    def GetTypeFromName(cls, typeName: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
    @classmethod
    def GetTypeFromSchemaTypeName(cls, typeName: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
    @classmethod
    def GetTypeNameAndInstance(cls, typeName: str | pxr.Ar.ResolvedPath) -> tuple: ...
    @overload
    @classmethod
    def IsAbstract(cls, primType: pxr.Tf.Type) -> bool: ...
    @overload
    @classmethod
    def IsAbstract(cls, primType: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsAllowedAPISchemaInstanceName(cls, apiSchemaName: str | pxr.Ar.ResolvedPath, instanceName: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsAllowedSchemaFamily(cls, schemaFamily: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsAllowedSchemaIdentifier(cls, schemaIdentifier: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    @classmethod
    def IsAppliedAPISchema(cls, apiSchemaType: pxr.Tf.Type) -> bool: ...
    @overload
    @classmethod
    def IsAppliedAPISchema(cls, apiSchemaType: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    @classmethod
    def IsConcrete(cls, primType: pxr.Tf.Type) -> bool: ...
    @overload
    @classmethod
    def IsConcrete(cls, primType: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsDisallowedField(cls, fieldName: str | pxr.Ar.ResolvedPath) -> bool: ...
    @overload
    @classmethod
    def IsMultipleApplyAPISchema(cls, apiSchemaType: pxr.Tf.Type) -> bool: ...
    @overload
    @classmethod
    def IsMultipleApplyAPISchema(cls, apiSchemaType: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsMultipleApplyNameTemplate(cls, nameTemplate: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsTyped(cls, primType: pxr.Tf.Type) -> bool: ...
    @classmethod
    def MakeMultipleApplyNameInstance(cls, arg1: str | pxr.Ar.ResolvedPath, nameTemplate: str | pxr.Ar.ResolvedPath) -> str: ...
    @classmethod
    def MakeMultipleApplyNameTemplate(cls, arg1: str | pxr.Ar.ResolvedPath, namespacePrefix: str | pxr.Ar.ResolvedPath) -> str: ...
    @classmethod
    def MakeSchemaIdentifierForFamilyAndVersion(cls, schemaFamily: str | pxr.Ar.ResolvedPath, schemaVersion: int) -> str: ...
    @classmethod
    def ParseSchemaFamilyAndVersionFromIdentifier(cls, schemaIdentifier: str | pxr.Ar.ResolvedPath) -> tuple: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...

class Specializes(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddSpecialize(self, primPath: pxr.Sdf.Path | str, position: ListPosition = ...) -> bool: ...
    def ClearSpecializes(self) -> bool: ...
    def GetPrim(self) -> Prim: ...
    def RemoveSpecialize(self, primPath: pxr.Sdf.Path | str) -> bool: ...
    def SetSpecializes(self, arg2: typing.Iterable[pxr.Sdf.Path | str]) -> bool: ...
    def __bool__(self) -> bool: ...

class Stage(Boost.Python.instance):
    class InitialLoadSet(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
    LoadAll: ClassVar[Stage.InitialLoadSet] = ...
    LoadNone: ClassVar[Stage.InitialLoadSet] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def ClearDefaultPrim(self) -> None: ...
    def ClearMetadata(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def ClearMetadataByDictKey(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> bool: ...
    def CreateClassPrim(self, rootPrimPath: pxr.Sdf.Path | str) -> Prim: ...
    @overload
    @classmethod
    def CreateInMemory(cls, identifier: str | pxr.Ar.ResolvedPath, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateInMemory(cls, identifier: str | pxr.Ar.ResolvedPath, sessionLayer: pxr.Sdf.Layer, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateInMemory(cls, identifier: str | pxr.Ar.ResolvedPath, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateInMemory(cls, identifier: str | pxr.Ar.ResolvedPath, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateInMemory(cls, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateNew(cls, identifier: str | pxr.Ar.ResolvedPath, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateNew(cls, identifier: str | pxr.Ar.ResolvedPath, sessionLayer: pxr.Sdf.Layer, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateNew(cls, identifier: str | pxr.Ar.ResolvedPath, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def CreateNew(cls, identifier: str | pxr.Ar.ResolvedPath, load: Stage.InitialLoadSet = ...) -> Stage: ...
    def DefinePrim(self, path: pxr.Sdf.Path | str, typeName: str | pxr.Ar.ResolvedPath = ...) -> Prim: ...
    def ExpandPopulationMask(self, relationshipPredicate: typing.Callable[[Relationship], bool] = ..., attributePredicate: typing.Callable[[Attribute | pxr.UsdGeom.ConstraintTarget | pxr.UsdGeom.Primvar | pxr.UsdGeom.XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output], bool] = ...) -> None: ...
    def Export(self, filename: str | pxr.Ar.ResolvedPath, addSourceFileComment: bool = ..., args: dict = ...) -> bool: ...
    def ExportToString(self, addSourceFileComment: bool = ...) -> str: ...
    def FindLoadable(self, rootPath: pxr.Sdf.Path | str = ...) -> list[pxr.Sdf.Path]: ...
    def Flatten(self, addSourceFileComment: bool = ...) -> pxr.Sdf.Layer: ...
    def GetAttributeAtPath(self, path: pxr.Sdf.Path | str) -> Attribute: ...
    @classmethod
    def GetColorConfigFallbacks(cls) -> tuple[None, pxr.Sdf.AssetPath, str]: ...
    def GetColorConfiguration(self) -> pxr.Sdf.AssetPath: ...
    def GetColorManagementSystem(self) -> str: ...
    def GetDefaultPrim(self) -> Prim: ...
    def GetEditTarget(self) -> EditTarget: ...
    @overload
    def GetEditTargetForLocalLayer(self, arg2: int) -> EditTarget: ...
    @overload
    def GetEditTargetForLocalLayer(self, arg2: pxr.Sdf.Layer) -> EditTarget: ...
    def GetEndTimeCode(self) -> float: ...
    def GetFramesPerSecond(self) -> float: ...
    @classmethod
    def GetGlobalVariantFallbacks(cls) -> dict: ...
    def GetInterpolationType(self) -> InterpolationType: ...
    def GetLayerStack(self, includeSessionLayers: bool = ...) -> list[pxr.Sdf.Layer]: ...
    def GetLoadRules(self) -> StageLoadRules: ...
    def GetLoadSet(self) -> list[pxr.Sdf.Path]: ...
    def GetMetadata(self, arg2: object) -> Any: ...
    def GetMetadataByDictKey(self, arg2: object, arg3: object) -> Any: ...
    def GetMutedLayers(self) -> list[str]: ...
    def GetObjectAtPath(self, path: pxr.Sdf.Path | str) -> Object: ...
    def GetPathResolverContext(self) -> pxr.Ar.ResolverContext: ...
    def GetPopulationMask(self) -> StagePopulationMask: ...
    def GetPrimAtPath(self, path: pxr.Sdf.Path | str) -> Prim: ...
    def GetPropertyAtPath(self, path: pxr.Sdf.Path | str) -> Property: ...
    def GetPrototypes(self) -> list[Prim]: ...
    def GetPseudoRoot(self) -> Prim: ...
    def GetRelationshipAtPath(self, path: pxr.Sdf.Path | str) -> Relationship: ...
    def GetRootLayer(self) -> pxr.Sdf.Layer: ...
    def GetSessionLayer(self) -> pxr.Sdf.Layer: ...
    def GetStartTimeCode(self) -> float: ...
    def GetTimeCodesPerSecond(self) -> float: ...
    def GetUsedLayers(self, includeClipLayers: bool = ...) -> list[pxr.Sdf.Layer]: ...
    def HasAuthoredMetadata(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredMetadataDictKey(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredTimeCodeRange(self) -> bool: ...
    def HasDefaultPrim(self) -> bool: ...
    def HasLocalLayer(self, layer: pxr.Sdf.Layer) -> bool: ...
    def HasMetadata(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasMetadataDictKey(self, arg2: str | pxr.Ar.ResolvedPath, arg3: str | pxr.Ar.ResolvedPath) -> bool: ...
    def IsLayerMuted(self, layerIdentifier: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsSupportedFile(cls, filePath: str | pxr.Ar.ResolvedPath) -> bool: ...
    def Load(self, path: pxr.Sdf.Path | str = ..., policy: LoadPolicy = ...) -> Prim: ...
    def LoadAndUnload(self, loadSet: typing.Iterable[pxr.Sdf.Path | str], unloadSet: typing.Iterable[pxr.Sdf.Path | str], policy: LoadPolicy = ...) -> None: ...
    def MuteAndUnmuteLayers(self, muteLayers: typing.Iterable[str | pxr.Ar.ResolvedPath], unmuteLayers: typing.Iterable[str | pxr.Ar.ResolvedPath]) -> None: ...
    def MuteLayer(self, layerIdentifier: str | pxr.Ar.ResolvedPath) -> None: ...
    @overload
    @classmethod
    def Open(cls, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def Open(cls, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def Open(cls, rootLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def Open(cls, filePath: str | pxr.Ar.ResolvedPath, pathResolverContext: pxr.Ar.ResolverContext, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def Open(cls, rootLayer: pxr.Sdf.Layer, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def Open(cls, filePath: str | pxr.Ar.ResolvedPath, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def OpenMasked(cls, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext, mask: StagePopulationMask, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def OpenMasked(cls, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, mask: StagePopulationMask, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def OpenMasked(cls, rootLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext, mask: StagePopulationMask, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def OpenMasked(cls, filePath: str | pxr.Ar.ResolvedPath, pathResolverContext: pxr.Ar.ResolverContext, mask: StagePopulationMask, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def OpenMasked(cls, rootLayer: pxr.Sdf.Layer, mask: StagePopulationMask, load: Stage.InitialLoadSet = ...) -> Stage: ...
    @overload
    @classmethod
    def OpenMasked(cls, filePath: str | pxr.Ar.ResolvedPath, mask: StagePopulationMask, load: Stage.InitialLoadSet = ...) -> Stage: ...
    def OverridePrim(self, path: pxr.Sdf.Path | str) -> Prim: ...
    def Reload(self) -> None: ...
    def RemovePrim(self, path: pxr.Sdf.Path | str) -> bool: ...
    def ResolveIdentifierToEditTarget(self, identifier: str | pxr.Ar.ResolvedPath) -> str: ...
    def Save(self) -> None: ...
    def SaveSessionLayers(self) -> None: ...
    @classmethod
    def SetColorConfigFallbacks(cls, colorConfiguration: pxr.Sdf.AssetPath | str = ..., colorManagementSystem: str | pxr.Ar.ResolvedPath = ...) -> None: ...
    def SetColorConfiguration(self, arg2: pxr.Sdf.AssetPath | str) -> None: ...
    def SetColorManagementSystem(self, arg2: str | pxr.Ar.ResolvedPath) -> None: ...
    def SetDefaultPrim(self, prim: Prim) -> None: ...
    def SetEditTarget(self, editTarget: EditTarget | pxr.Sdf.Layer) -> None: ...
    def SetEndTimeCode(self, arg2: float) -> None: ...
    def SetFramesPerSecond(self, arg2: float) -> None: ...
    @classmethod
    def SetGlobalVariantFallbacks(cls, arg1: dict) -> None: ...
    def SetInterpolationType(self, arg2: InterpolationType) -> None: ...
    def SetLoadRules(self, rules: StageLoadRules) -> None: ...
    def SetMetadata(self, arg2: object, arg3: object) -> bool: ...
    def SetMetadataByDictKey(self, arg2: object, arg3: object, arg4: object) -> bool: ...
    def SetPopulationMask(self, mask: StagePopulationMask) -> None: ...
    def SetStartTimeCode(self, arg2: float) -> None: ...
    def SetTimeCodesPerSecond(self, arg2: float) -> None: ...
    @overload
    def Traverse(self, predicate: _PrimFlagsPredicate | _Term) -> PrimRange: ...
    @overload
    def Traverse(self) -> PrimRange: ...
    def TraverseAll(self) -> PrimRange: ...
    def Unload(self, path: pxr.Sdf.Path | str = ...) -> None: ...
    def UnmuteLayer(self, layerIdentifier: str | pxr.Ar.ResolvedPath) -> None: ...
    def WriteFallbackPrimTypes(self) -> None: ...
    def _GetPcpCache(self) -> Cache: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def expired(self): ...

class StageCache(Boost.Python.instance):
    class Id(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        def __init__(self) -> None: ...
        def FromLongInt(self, val: int) -> StageCache.Id: ...
        def FromString(self, s: object) -> StageCache.Id: ...
        def IsValid(self) -> bool: ...
        def ToLongInt(self) -> int: ...
        def ToString(self) -> str: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: StageCache) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Clear(self) -> None: ...
    @overload
    def Contains(self, stage: Stage) -> bool: ...
    @overload
    def Contains(self, id: StageCache.Id) -> bool: ...
    @overload
    def Erase(self, stage: Stage) -> bool: ...
    @overload
    def Erase(self, id: StageCache.Id) -> bool: ...
    @overload
    def EraseAll(self, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext) -> int: ...
    @overload
    def EraseAll(self, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer) -> int: ...
    @overload
    def EraseAll(self, rootLayer: pxr.Sdf.Layer) -> int: ...
    def Find(self, id: StageCache.Id) -> Stage: ...
    @overload
    def FindAllMatching(self, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext) -> list[Stage]: ...
    @overload
    def FindAllMatching(self, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer) -> list[Stage]: ...
    @overload
    def FindAllMatching(self, rootLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext) -> list[Stage]: ...
    @overload
    def FindAllMatching(self, rootLayer: pxr.Sdf.Layer) -> list[Stage]: ...
    @overload
    def FindOneMatching(self, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext) -> Stage: ...
    @overload
    def FindOneMatching(self, rootLayer: pxr.Sdf.Layer, sessionLayer: pxr.Sdf.Layer) -> Stage: ...
    @overload
    def FindOneMatching(self, rootLayer: pxr.Sdf.Layer, pathResolverContext: pxr.Ar.ResolverContext) -> Stage: ...
    @overload
    def FindOneMatching(self, rootLayer: pxr.Sdf.Layer) -> Stage: ...
    def GetAllStages(self) -> list[Stage]: ...
    def GetDebugName(self) -> str: ...
    def GetId(self, stage: Stage) -> StageCache.Id: ...
    def Insert(self, stage: Stage) -> StageCache.Id: ...
    def IsEmpty(self) -> bool: ...
    def SetDebugName(self, arg2: str | pxr.Ar.ResolvedPath) -> None: ...
    def Size(self) -> int: ...
    def swap(self, arg2: StageCache) -> None: ...

class StageCacheContext(Boost.Python.instance):
    @overload
    def __init__(self, arg2: _NonPopulatingStageCacheWrapper) -> None: ...
    @overload
    def __init__(self, arg2: StageCache) -> None: ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class StageCacheContextBlockType(pxr.Tf.Tf_PyEnumWrapper):
    _baseName: ClassVar[str] = ...
    allValues: ClassVar[tuple] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetValueFromName(self, name: object) -> Any: ...

class StageLoadRules(Boost.Python.instance):
    class Rule(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
    AllRule: ClassVar[StageLoadRules.Rule] = ...
    NoneRule: ClassVar[StageLoadRules.Rule] = ...
    OnlyRule: ClassVar[StageLoadRules.Rule] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: StageLoadRules) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def AddRule(self, path: pxr.Sdf.Path | str, rule: StageLoadRules.Rule) -> None: ...
    def GetEffectiveRuleForPath(self, path: pxr.Sdf.Path | str) -> StageLoadRules.Rule: ...
    def GetRules(self) -> list[tuple[pxr.Sdf.Path, StageLoadRules.Rule]]: ...
    def IsLoaded(self, path: pxr.Sdf.Path | str) -> bool: ...
    def IsLoadedWithAllDescendants(self, path: pxr.Sdf.Path | str) -> bool: ...
    def IsLoadedWithNoDescendants(self, path: pxr.Sdf.Path | str) -> bool: ...
    @classmethod
    def LoadAll(cls) -> StageLoadRules: ...
    def LoadAndUnload(self, loadSet: typing.Iterable[pxr.Sdf.Path | str], unloadSet: typing.Iterable[pxr.Sdf.Path | str], policy: LoadPolicy) -> None: ...
    @classmethod
    def LoadNone(cls) -> StageLoadRules: ...
    def LoadWithDescendants(self, path: pxr.Sdf.Path | str) -> None: ...
    def LoadWithoutDescendants(self, path: pxr.Sdf.Path | str) -> None: ...
    def Minimize(self) -> None: ...
    def SetRules(self, rules: object) -> None: ...
    def Unload(self, path: pxr.Sdf.Path | str) -> None: ...
    def swap(self, other: StageLoadRules) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class StagePopulationMask(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: object) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def Add(self, arg2: StagePopulationMask) -> StagePopulationMask: ...
    @overload
    def Add(self, arg2: pxr.Sdf.Path | str) -> StagePopulationMask: ...
    @classmethod
    def All(cls) -> StagePopulationMask: ...
    def GetIncludedChildNames(self, path: pxr.Sdf.Path | str) -> tuple: ...
    def GetIntersection(self, other: StagePopulationMask) -> StagePopulationMask: ...
    def GetPaths(self) -> list[pxr.Sdf.Path]: ...
    @overload
    def GetUnion(self, path: pxr.Sdf.Path | str) -> StagePopulationMask: ...
    @overload
    def GetUnion(self, other: StagePopulationMask) -> StagePopulationMask: ...
    @overload
    def Includes(self, path: pxr.Sdf.Path | str) -> bool: ...
    @overload
    def Includes(self, other: StagePopulationMask) -> bool: ...
    def IncludesSubtree(self, path: pxr.Sdf.Path | str) -> bool: ...
    @classmethod
    def Intersection(cls, arg1: StagePopulationMask, arg2: StagePopulationMask) -> StagePopulationMask: ...
    def IsEmpty(self) -> bool: ...
    @classmethod
    def Union(cls, arg1: StagePopulationMask, arg2: StagePopulationMask) -> StagePopulationMask: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class TimeCode(Boost.Python.instance):
    class Tokens(Boost.Python.instance):
        DEFAULT: ClassVar[str] = ...  # read-only
        EARLIEST: ClassVar[str] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, arg2: float) -> None: ...
    @overload
    def __init__(self, arg2: TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Default(cls) -> TimeCode: ...
    @classmethod
    def EarliestTime(cls) -> TimeCode: ...
    def GetValue(self) -> float: ...
    def IsDefault(self) -> bool: ...
    def IsEarliestTime(self) -> bool: ...
    def IsNumeric(self) -> bool: ...
    @classmethod
    def SafeStep(cls, maxValue: float = ..., maxCompression: float = ...) -> float: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Tokens(Boost.Python.instance):
    APISchemaBase: ClassVar[str] = ...  # read-only
    ClipsAPI: ClassVar[str] = ...  # read-only
    CollectionAPI: ClassVar[str] = ...  # read-only
    ModelAPI: ClassVar[str] = ...  # read-only
    Typed: ClassVar[str] = ...  # read-only
    apiSchemas: ClassVar[str] = ...  # read-only
    clipSets: ClassVar[str] = ...  # read-only
    clips: ClassVar[str] = ...  # read-only
    collection: ClassVar[str] = ...  # read-only
    collection_MultipleApplyTemplate_: ClassVar[str] = ...  # read-only
    collection_MultipleApplyTemplate_Excludes: ClassVar[str] = ...  # read-only
    collection_MultipleApplyTemplate_ExpansionRule: ClassVar[str] = ...  # read-only
    collection_MultipleApplyTemplate_IncludeRoot: ClassVar[str] = ...  # read-only
    collection_MultipleApplyTemplate_Includes: ClassVar[str] = ...  # read-only
    exclude: ClassVar[str] = ...  # read-only
    expandPrims: ClassVar[str] = ...  # read-only
    expandPrimsAndProperties: ClassVar[str] = ...  # read-only
    explicitOnly: ClassVar[str] = ...  # read-only
    fallbackPrimTypes: ClassVar[str] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...

class Typed(SchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, schemaObj: SchemaBase) -> None: ...
    @overload
    def __init__(self, prim: Prim) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Get(cls, stage: Stage, path: pxr.Sdf.Path | str) -> Typed: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...

class UsdCollectionMembershipQuery(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self) -> None: ...
    def GetAsPathExpansionRuleMap(self) -> dict: ...
    def GetIncludedCollections(self) -> list: ...
    def HasExcludes(self) -> bool: ...
    @overload
    def IsPathIncluded(self, path: pxr.Sdf.Path | str, parentExpansionRule: object) -> bool: ...
    @overload
    def IsPathIncluded(self, path: pxr.Sdf.Path | str) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class UsdFileFormat(pxr.Sdf.FileFormat):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def GetUnderlyingFormatForLayer(cls, arg1: pxr.Sdf.Layer) -> str: ...

class VariantSet(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddVariant(self, variantName: str | pxr.Ar.ResolvedPath, position: ListPosition = ...) -> bool: ...
    def BlockVariantSelection(self) -> bool: ...
    def ClearVariantSelection(self) -> bool: ...
    def GetName(self) -> str: ...
    def GetPrim(self) -> Prim: ...
    def GetVariantEditContext(self, layer: pxr.Sdf.Layer = ...) -> EditContext: ...
    def GetVariantEditTarget(self, layer: pxr.Sdf.Layer = ...) -> EditTarget: ...
    def GetVariantNames(self) -> list[str]: ...
    def GetVariantSelection(self) -> str: ...
    def HasAuthoredVariant(self, arg2: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasAuthoredVariantSelection(self) -> str: ...
    def IsValid(self) -> bool: ...
    def SetVariantSelection(self, variantName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def __bool__(self) -> bool: ...

class VariantSets(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddVariantSet(self, variantSetName: str | pxr.Ar.ResolvedPath, position: ListPosition = ...) -> VariantSet: ...
    def GetAllVariantSelections(self) -> dict: ...
    def GetNames(self) -> list: ...
    def GetVariantSelection(self, variantSetName: str | pxr.Ar.ResolvedPath) -> str: ...
    def GetVariantSet(self, variantSetName: str | pxr.Ar.ResolvedPath) -> VariantSet: ...
    def HasVariantSet(self, variantSetName: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetSelection(self, variantSetName: str | pxr.Ar.ResolvedPath, variantName: str | pxr.Ar.ResolvedPath) -> bool: ...

class ZipFile(Boost.Python.instance):
    class FileInfo(Boost.Python.instance):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def compressionMethod(self): ...
        @property
        def dataOffset(self): ...
        @property
        def encrypted(self): ...
        @property
        def size(self): ...
        @property
        def uncompressedSize(self): ...
    def __init__(self, *args, **kwargs) -> None: ...
    def DumpContents(self) -> None: ...
    def GetFile(self, path: object) -> Any: ...
    def GetFileInfo(self, path: object) -> Any: ...
    def GetFileNames(self) -> list: ...
    @classmethod
    def Open(cls, filePath: object) -> Any: ...

class ZipFileWriter(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def AddFile(self, filePath: str | pxr.Ar.ResolvedPath, filePathInArchive: str | pxr.Ar.ResolvedPath = ...) -> str: ...
    @classmethod
    def CreateNew(cls, filePath: str | pxr.Ar.ResolvedPath) -> ZipFileWriter: ...
    def Discard(self) -> None: ...
    def Save(self) -> bool: ...
    def __enter__(self) -> ZipFileWriter: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class _CanApplyAPIResult(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, arg2: bool, arg3: object) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> typing.Iterator[Any]: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def whyNot(self): ...

class _CanApplyResult(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, arg2: bool, arg3: object) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> typing.Iterator[Any]: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def whyNot(self): ...

class _NonPopulatingStageCacheWrapper(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...

class _PrimFlagsConjunction(_PrimFlagsPredicate):
    def __init__(self, *args, **kwargs) -> None: ...
    def __and__(self, arg2: _Term) -> Any: ...
    def __iand__(self, arg2: _Term) -> Any: ...
    def __invert__(self) -> Any: ...
    def __rand__(self, arg2: _Term) -> Any: ...

class _PrimFlagsDisjunction(_PrimFlagsPredicate):
    def __init__(self, *args, **kwargs) -> None: ...
    def __invert__(self) -> Any: ...
    def __ior__(self, arg2: _Term) -> Any: ...
    def __or__(self, arg2: _Term) -> Any: ...
    def __ror__(self, arg2: _Term) -> Any: ...

class _PrimFlagsPredicate(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def Contradiction(self) -> _PrimFlagsPredicate: ...
    def Tautology(self) -> _PrimFlagsPredicate: ...
    def __call__(self, arg2: Prim) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...

class _Term(Boost.Python.instance):
    def __init__(self, *args, **kwargs) -> None: ...
    def __and__(self, arg2: _Term) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __invert__(self) -> Any: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, arg2: _Term) -> Any: ...

def ComputeIncludedObjectsFromCollection(query: UsdCollectionMembershipQuery, stage: Stage, predicate: _PrimFlagsPredicate | _Term = ...) -> list[Object]: ...
def ComputeIncludedPathsFromCollection(query: UsdCollectionMembershipQuery, stage: Stage, predicate: _PrimFlagsPredicate | _Term = ...) -> list[pxr.Sdf.Path]: ...
@overload
def Describe(arg1: Object | pxr.UsdGeom.XformOp) -> str: ...
@overload
def Describe(arg1: Stage) -> str: ...
@overload
def Describe(arg1: StageCache) -> str: ...
@overload
def FlattenLayerStack(layerStack: pxr.Pcp.LayerStack, resolveAssetPathFn: FlattenResolveAssetPathFn, tag: str | pxr.Ar.ResolvedPath = ...) -> pxr.Sdf.Layer: ...
@overload
def FlattenLayerStack(layerStack: pxr.Pcp.LayerStack, tag: str | pxr.Ar.ResolvedPath = ...) -> pxr.Sdf.Layer: ...
def FlattenLayerStackResolveAssetPath(sourceLayer: pxr.Sdf.Layer, assetPath: str | pxr.Ar.ResolvedPath) -> str: ...
def GetMajorVersion() -> int: ...
def GetMinorVersion() -> int: ...
def GetPatchVersion() -> int: ...
def GetVersion() -> tuple: ...
@overload
def TraverseInstanceProxies(predicate: _PrimFlagsPredicate | _Term) -> _PrimFlagsPredicate: ...
@overload
def TraverseInstanceProxies() -> _PrimFlagsPredicate: ...
def UseButDoNotPopulateCache(arg1: StageCache) -> _NonPopulatingStageCacheWrapper: ...
def _TestPrimRangeRoundTrip(arg1: object) -> Any: ...
def _UnsafeGetStageForTesting(arg1: Object | pxr.UsdGeom.XformOp) -> Stage: ...
