# coding: utf-8

"""
    ETAPI

    External Trilium API  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: zadam.apps@gmail.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import date

from pydantic import Field, StrictInt, StrictStr, constr, validator

from typing import Optional

from trilium_client.models.app_info import AppInfo
from trilium_client.models.attribute import Attribute
from trilium_client.models.branch import Branch
from trilium_client.models.create_note_def import CreateNoteDef
from trilium_client.models.login201_response import Login201Response
from trilium_client.models.login_request import LoginRequest
from trilium_client.models.note import Note
from trilium_client.models.note_with_branch import NoteWithBranch
from trilium_client.models.search_response import SearchResponse

from trilium_client.api_client import ApiClient
from trilium_client.exceptions import ApiTypeError, ApiValueError  # noqa: F401


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def create_backup(
        self,
        backup_name: Annotated[
            constr(strict=True),
            Field(
                ...,
                description='If the backupName is e.g. "now", then the backup will be written to "backup-now.db" file',
            ),
        ],
        **kwargs
    ) -> None:  # noqa: E501
        """create_backup  # noqa: E501

        Create a database backup under a given name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_backup(backup_name, async_req=True)
        >>> result = thread.get()

        :param backup_name: If the backupName is e.g. \"now\", then the backup will be written to \"backup-now.db\" file (required)
        :type backup_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.create_backup_with_http_info(
            backup_name, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_backup_with_http_info(
        self,
        backup_name: Annotated[
            constr(strict=True),
            Field(
                ...,
                description='If the backupName is e.g. "now", then the backup will be written to "backup-now.db" file',
            ),
        ],
        **kwargs
    ):  # noqa: E501
        """create_backup  # noqa: E501

        Create a database backup under a given name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_backup_with_http_info(backup_name, async_req=True)
        >>> result = thread.get()

        :param backup_name: If the backupName is e.g. \"now\", then the backup will be written to \"backup-now.db\" file (required)
        :type backup_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["backup_name"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_backup" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["backup_name"]:
            _path_params["backupName"] = _params["backup_name"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/backup/{backupName}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_note(
        self, create_note_def: CreateNoteDef, **kwargs
    ) -> NoteWithBranch:  # noqa: E501
        """create_note  # noqa: E501

        Create a note and place it into the note tree  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_note(create_note_def, async_req=True)
        >>> result = thread.get()

        :param create_note_def: (required)
        :type create_note_def: CreateNoteDef
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NoteWithBranch
        """
        kwargs["_return_http_data_only"] = True
        return self.create_note_with_http_info(
            create_note_def, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_note_with_http_info(
        self, create_note_def: CreateNoteDef, **kwargs
    ):  # noqa: E501
        """create_note  # noqa: E501

        Create a note and place it into the note tree  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_note_with_http_info(create_note_def, async_req=True)
        >>> result = thread.get()

        :param create_note_def: (required)
        :type create_note_def: CreateNoteDef
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NoteWithBranch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["create_note_def"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["create_note_def"]:
            _body_params = _params["create_note_def"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "201": "NoteWithBranch",
        }

        return self.api_client.call_api(
            "/create-note",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_revision(
        self,
        note_id: constr(strict=True),
        format: Optional[StrictStr] = None,
        **kwargs
    ) -> None:  # noqa: E501
        """create_revision  # noqa: E501

        Create a note revision for the given note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_revision(note_id, format, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param format:
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.create_revision_with_http_info(
            note_id, format, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_revision_with_http_info(
        self,
        note_id: constr(strict=True),
        format: Optional[StrictStr] = None,
        **kwargs
    ):  # noqa: E501
        """create_revision  # noqa: E501

        Create a note revision for the given note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_revision_with_http_info(note_id, format, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param format:
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["note_id", "format"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_revision" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []
        if _params.get("format") is not None:  # noqa: E501
            _query_params.append(("format", _params["format"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/notes/{noteId}/revision",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_attribute_by_id(
        self, attribute_id: constr(strict=True), **kwargs
    ) -> None:  # noqa: E501
        """delete_attribute_by_id  # noqa: E501

        deletes a attribute based on the attributeId supplied.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_attribute_by_id(attribute_id, async_req=True)
        >>> result = thread.get()

        :param attribute_id: (required)
        :type attribute_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.delete_attribute_by_id_with_http_info(
            attribute_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_attribute_by_id_with_http_info(
        self, attribute_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """delete_attribute_by_id  # noqa: E501

        deletes a attribute based on the attributeId supplied.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_attribute_by_id_with_http_info(attribute_id, async_req=True)
        >>> result = thread.get()

        :param attribute_id: (required)
        :type attribute_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["attribute_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_attribute_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["attribute_id"]:
            _path_params["attributeId"] = _params["attribute_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/attributes/{attributeId}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_branch_by_id(
        self, branch_id: constr(strict=True), **kwargs
    ) -> None:  # noqa: E501
        """delete_branch_by_id  # noqa: E501

        deletes a branch based on the branchId supplied. If this is the last branch of the (child) note,  then the note is deleted as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_branch_by_id(branch_id, async_req=True)
        >>> result = thread.get()

        :param branch_id: (required)
        :type branch_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.delete_branch_by_id_with_http_info(
            branch_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_branch_by_id_with_http_info(
        self, branch_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """delete_branch_by_id  # noqa: E501

        deletes a branch based on the branchId supplied. If this is the last branch of the (child) note,  then the note is deleted as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_branch_by_id_with_http_info(branch_id, async_req=True)
        >>> result = thread.get()

        :param branch_id: (required)
        :type branch_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["branch_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_branch_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["branch_id"]:
            _path_params["branchId"] = _params["branch_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/branches/{branchId}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_note_by_id(
        self, note_id: constr(strict=True), **kwargs
    ) -> None:  # noqa: E501
        """delete_note_by_id  # noqa: E501

        deletes a single note based on the noteId supplied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_note_by_id(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.delete_note_by_id_with_http_info(
            note_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_note_by_id_with_http_info(
        self, note_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """delete_note_by_id  # noqa: E501

        deletes a single note based on the noteId supplied  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_note_by_id_with_http_info(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["note_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_note_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/notes/{noteId}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def export_note_subtree(
        self,
        note_id: constr(strict=True),
        format: Optional[StrictStr] = None,
        **kwargs
    ) -> str:  # noqa: E501
        """export_note_subtree  # noqa: E501

        Exports ZIP file export of a given note subtree. To export whole document, use \"root\" for noteId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_note_subtree(note_id, format, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param format:
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs["_return_http_data_only"] = True
        return self.export_note_subtree_with_http_info(
            note_id, format, **kwargs
        )  # noqa: E501

    @validate_arguments
    def export_note_subtree_with_http_info(
        self,
        note_id: constr(strict=True),
        format: Optional[StrictStr] = None,
        **kwargs
    ):  # noqa: E501
        """export_note_subtree  # noqa: E501

        Exports ZIP file export of a given note subtree. To export whole document, use \"root\" for noteId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_note_subtree_with_http_info(note_id, format, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param format:
        :type format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["note_id", "format"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_note_subtree" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []
        if _params.get("format") is not None:  # noqa: E501
            _query_params.append(("format", _params["format"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/zip", "application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "str",
        }

        return self.api_client.call_api(
            "/notes/{noteId}/export",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_app_info(self, **kwargs) -> AppInfo:  # noqa: E501
        """get_app_info  # noqa: E501

        returns information about the running Trilium instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_app_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AppInfo
        """
        kwargs["_return_http_data_only"] = True
        return self.get_app_info_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_app_info_with_http_info(self, **kwargs):  # noqa: E501
        """get_app_info  # noqa: E501

        returns information about the running Trilium instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_app_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AppInfo, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = []
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_app_info" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "AppInfo",
        }

        return self.api_client.call_api(
            "/app-info",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_attribute_by_id(
        self, attribute_id: constr(strict=True), **kwargs
    ) -> Attribute:  # noqa: E501
        """get_attribute_by_id  # noqa: E501

        Returns an attribute identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attribute_by_id(attribute_id, async_req=True)
        >>> result = thread.get()

        :param attribute_id: (required)
        :type attribute_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attribute
        """
        kwargs["_return_http_data_only"] = True
        return self.get_attribute_by_id_with_http_info(
            attribute_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_attribute_by_id_with_http_info(
        self, attribute_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """get_attribute_by_id  # noqa: E501

        Returns an attribute identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_attribute_by_id_with_http_info(attribute_id, async_req=True)
        >>> result = thread.get()

        :param attribute_id: (required)
        :type attribute_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attribute, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["attribute_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attribute_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["attribute_id"]:
            _path_params["attributeId"] = _params["attribute_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Attribute",
        }

        return self.api_client.call_api(
            "/attributes/{attributeId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_branch_by_id(
        self, branch_id: constr(strict=True), **kwargs
    ) -> Branch:  # noqa: E501
        """get_branch_by_id  # noqa: E501

        Returns a branch identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_branch_by_id(branch_id, async_req=True)
        >>> result = thread.get()

        :param branch_id: (required)
        :type branch_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs["_return_http_data_only"] = True
        return self.get_branch_by_id_with_http_info(
            branch_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_branch_by_id_with_http_info(
        self, branch_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """get_branch_by_id  # noqa: E501

        Returns a branch identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_branch_by_id_with_http_info(branch_id, async_req=True)
        >>> result = thread.get()

        :param branch_id: (required)
        :type branch_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["branch_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_branch_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["branch_id"]:
            _path_params["branchId"] = _params["branch_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Branch",
        }

        return self.api_client.call_api(
            "/branches/{branchId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_day_note(self, var_date: date, **kwargs) -> Note:  # noqa: E501
        """get_day_note  # noqa: E501

        returns a day note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_day_note(var_date, async_req=True)
        >>> result = thread.get()

        :param var_date: (required)
        :type var_date: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.get_day_note_with_http_info(
            var_date, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_day_note_with_http_info(
        self, var_date: date, **kwargs
    ):  # noqa: E501
        """get_day_note  # noqa: E501

        returns a day note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_day_note_with_http_info(var_date, async_req=True)
        >>> result = thread.get()

        :param var_date: (required)
        :type var_date: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["var_date"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_day_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["var_date"]:
            _path_params["date"] = _params["var_date"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/calendar/days/{date}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_inbox_note(self, var_date: date, **kwargs) -> Note:  # noqa: E501
        """get_inbox_note  # noqa: E501

        returns an \"inbox\" note, into which note can be created. Date will be used depending on whether the inbox is a fixed note (identified with #inbox label) or a day note in a journal.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_inbox_note(var_date, async_req=True)
        >>> result = thread.get()

        :param var_date: (required)
        :type var_date: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.get_inbox_note_with_http_info(
            var_date, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_inbox_note_with_http_info(
        self, var_date: date, **kwargs
    ):  # noqa: E501
        """get_inbox_note  # noqa: E501

        returns an \"inbox\" note, into which note can be created. Date will be used depending on whether the inbox is a fixed note (identified with #inbox label) or a day note in a journal.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_inbox_note_with_http_info(var_date, async_req=True)
        >>> result = thread.get()

        :param var_date: (required)
        :type var_date: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["var_date"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inbox_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["var_date"]:
            _path_params["date"] = _params["var_date"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/inbox/{date}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_month_note(
        self, month: constr(strict=True), **kwargs
    ) -> Note:  # noqa: E501
        """get_month_note  # noqa: E501

        returns a week note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_month_note(month, async_req=True)
        >>> result = thread.get()

        :param month: (required)
        :type month: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.get_month_note_with_http_info(month, **kwargs)  # noqa: E501

    @validate_arguments
    def get_month_note_with_http_info(
        self, month: constr(strict=True), **kwargs
    ):  # noqa: E501
        """get_month_note  # noqa: E501

        returns a week note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_month_note_with_http_info(month, async_req=True)
        >>> result = thread.get()

        :param month: (required)
        :type month: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["month"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_month_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["month"]:
            _path_params["month"] = _params["month"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/calendar/months/{month}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_note_by_id(
        self, note_id: constr(strict=True), **kwargs
    ) -> Note:  # noqa: E501
        """get_note_by_id  # noqa: E501

        Returns a note identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_note_by_id(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.get_note_by_id_with_http_info(
            note_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_note_by_id_with_http_info(
        self, note_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """get_note_by_id  # noqa: E501

        Returns a note identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_note_by_id_with_http_info(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["note_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_note_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/notes/{noteId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_note_content(
        self, note_id: constr(strict=True), **kwargs
    ) -> str:  # noqa: E501
        """get_note_content  # noqa: E501

        Returns note content identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_note_content(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs["_return_http_data_only"] = True
        return self.get_note_content_with_http_info(
            note_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_note_content_with_http_info(
        self, note_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """get_note_content  # noqa: E501

        Returns note content identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_note_content_with_http_info(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["note_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_note_content" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["text/html"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "str",
        }

        return self.api_client.call_api(
            "/notes/{noteId}/content",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_week_note(self, var_date: date, **kwargs) -> Note:  # noqa: E501
        """get_week_note  # noqa: E501

        returns a week note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_week_note(var_date, async_req=True)
        >>> result = thread.get()

        :param var_date: (required)
        :type var_date: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.get_week_note_with_http_info(
            var_date, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_week_note_with_http_info(
        self, var_date: date, **kwargs
    ):  # noqa: E501
        """get_week_note  # noqa: E501

        returns a week note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_week_note_with_http_info(var_date, async_req=True)
        >>> result = thread.get()

        :param var_date: (required)
        :type var_date: date
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["var_date"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_week_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["var_date"]:
            _path_params["date"] = _params["var_date"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/calendar/weeks/{date}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_year_note(
        self, year: constr(strict=True), **kwargs
    ) -> Note:  # noqa: E501
        """get_year_note  # noqa: E501

        returns a week note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_year_note(year, async_req=True)
        >>> result = thread.get()

        :param year: (required)
        :type year: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.get_year_note_with_http_info(year, **kwargs)  # noqa: E501

    @validate_arguments
    def get_year_note_with_http_info(
        self, year: constr(strict=True), **kwargs
    ):  # noqa: E501
        """get_year_note  # noqa: E501

        returns a week note for a given date. Gets created if doesn't exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_year_note_with_http_info(year, async_req=True)
        >>> result = thread.get()

        :param year: (required)
        :type year: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["year"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_year_note" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["year"]:
            _path_params["year"] = _params["year"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/calendar/years/{year}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def import_zip(
        self, note_id: constr(strict=True), **kwargs
    ) -> NoteWithBranch:  # noqa: E501
        """import_zip  # noqa: E501

        Imports ZIP file into a given note.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.import_zip(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NoteWithBranch
        """
        kwargs["_return_http_data_only"] = True
        return self.import_zip_with_http_info(note_id, **kwargs)  # noqa: E501

    @validate_arguments
    def import_zip_with_http_info(
        self, note_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """import_zip  # noqa: E501

        Imports ZIP file into a given note.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.import_zip_with_http_info(note_id, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NoteWithBranch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["note_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_zip" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "201": "NoteWithBranch",
        }

        return self.api_client.call_api(
            "/notes/{noteId}/import",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def login(
        self, login_request: LoginRequest, **kwargs
    ) -> Login201Response:  # noqa: E501
        """login  # noqa: E501

        get an ETAPI token based on password for further use with ETAPI  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.login(login_request, async_req=True)
        >>> result = thread.get()

        :param login_request: (required)
        :type login_request: LoginRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Login201Response
        """
        kwargs["_return_http_data_only"] = True
        return self.login_with_http_info(login_request, **kwargs)  # noqa: E501

    @validate_arguments
    def login_with_http_info(
        self, login_request: LoginRequest, **kwargs
    ):  # noqa: E501
        """login  # noqa: E501

        get an ETAPI token based on password for further use with ETAPI  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.login_with_http_info(login_request, async_req=True)
        >>> result = thread.get()

        :param login_request: (required)
        :type login_request: LoginRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Login201Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["login_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["login_request"]:
            _body_params = _params["login_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "201": "Login201Response",
            "429": None,
        }

        return self.api_client.call_api(
            "/auth/login",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def logout(self, **kwargs) -> None:  # noqa: E501
        """logout  # noqa: E501

        logout (delete/deactivate) an ETAPI token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.logout(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.logout_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def logout_with_http_info(self, **kwargs):  # noqa: E501
        """logout  # noqa: E501

        logout (delete/deactivate) an ETAPI token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.logout_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = []
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/auth/logout",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def patch_attribute_by_id(
        self, attribute_id: constr(strict=True), attribute: Attribute, **kwargs
    ) -> Attribute:  # noqa: E501
        """patch_attribute_by_id  # noqa: E501

        patch a attribute identified by the attributeId with changes in the body. For labels, only value and position can be updated. For relations, only position can be updated. If you want to modify other properties, you need to delete the old attribute and create a new one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_attribute_by_id(attribute_id, attribute, async_req=True)
        >>> result = thread.get()

        :param attribute_id: (required)
        :type attribute_id: str
        :param attribute: (required)
        :type attribute: Attribute
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attribute
        """
        kwargs["_return_http_data_only"] = True
        return self.patch_attribute_by_id_with_http_info(
            attribute_id, attribute, **kwargs
        )  # noqa: E501

    @validate_arguments
    def patch_attribute_by_id_with_http_info(
        self, attribute_id: constr(strict=True), attribute: Attribute, **kwargs
    ):  # noqa: E501
        """patch_attribute_by_id  # noqa: E501

        patch a attribute identified by the attributeId with changes in the body. For labels, only value and position can be updated. For relations, only position can be updated. If you want to modify other properties, you need to delete the old attribute and create a new one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_attribute_by_id_with_http_info(attribute_id, attribute, async_req=True)
        >>> result = thread.get()

        :param attribute_id: (required)
        :type attribute_id: str
        :param attribute: (required)
        :type attribute: Attribute
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attribute, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["attribute_id", "attribute"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_attribute_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["attribute_id"]:
            _path_params["attributeId"] = _params["attribute_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["attribute"]:
            _body_params = _params["attribute"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Attribute",
        }

        return self.api_client.call_api(
            "/attributes/{attributeId}",
            "PATCH",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def patch_branch_by_id(
        self, branch_id: constr(strict=True), branch: Branch, **kwargs
    ) -> Branch:  # noqa: E501
        """patch_branch_by_id  # noqa: E501

        patch a branch identified by the branchId with changes in the body. Only prefix and notePosition can be updated. If you want to update other properties, you need to delete the old branch and create a new one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_branch_by_id(branch_id, branch, async_req=True)
        >>> result = thread.get()

        :param branch_id: (required)
        :type branch_id: str
        :param branch: (required)
        :type branch: Branch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs["_return_http_data_only"] = True
        return self.patch_branch_by_id_with_http_info(
            branch_id, branch, **kwargs
        )  # noqa: E501

    @validate_arguments
    def patch_branch_by_id_with_http_info(
        self, branch_id: constr(strict=True), branch: Branch, **kwargs
    ):  # noqa: E501
        """patch_branch_by_id  # noqa: E501

        patch a branch identified by the branchId with changes in the body. Only prefix and notePosition can be updated. If you want to update other properties, you need to delete the old branch and create a new one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_branch_by_id_with_http_info(branch_id, branch, async_req=True)
        >>> result = thread.get()

        :param branch_id: (required)
        :type branch_id: str
        :param branch: (required)
        :type branch: Branch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["branch_id", "branch"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_branch_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["branch_id"]:
            _path_params["branchId"] = _params["branch_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["branch"]:
            _body_params = _params["branch"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Branch",
        }

        return self.api_client.call_api(
            "/branches/{branchId}",
            "PATCH",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def patch_note_by_id(
        self, note_id: constr(strict=True), note: Note, **kwargs
    ) -> Note:  # noqa: E501
        """patch_note_by_id  # noqa: E501

        patch a note identified by the noteId with changes in the body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_note_by_id(note_id, note, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param note: (required)
        :type note: Note
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Note
        """
        kwargs["_return_http_data_only"] = True
        return self.patch_note_by_id_with_http_info(
            note_id, note, **kwargs
        )  # noqa: E501

    @validate_arguments
    def patch_note_by_id_with_http_info(
        self, note_id: constr(strict=True), note: Note, **kwargs
    ):  # noqa: E501
        """patch_note_by_id  # noqa: E501

        patch a note identified by the noteId with changes in the body  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_note_by_id_with_http_info(note_id, note, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param note: (required)
        :type note: Note
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Note, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["note_id", "note"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_note_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["note"]:
            _body_params = _params["note"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Note",
        }

        return self.api_client.call_api(
            "/notes/{noteId}",
            "PATCH",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def post_attribute(
        self, attribute: Attribute, **kwargs
    ) -> Attribute:  # noqa: E501
        """post_attribute  # noqa: E501

        create an attribute for a given note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_attribute(attribute, async_req=True)
        >>> result = thread.get()

        :param attribute: (required)
        :type attribute: Attribute
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Attribute
        """
        kwargs["_return_http_data_only"] = True
        return self.post_attribute_with_http_info(
            attribute, **kwargs
        )  # noqa: E501

    @validate_arguments
    def post_attribute_with_http_info(
        self, attribute: Attribute, **kwargs
    ):  # noqa: E501
        """post_attribute  # noqa: E501

        create an attribute for a given note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_attribute_with_http_info(attribute, async_req=True)
        >>> result = thread.get()

        :param attribute: (required)
        :type attribute: Attribute
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Attribute, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["attribute"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_attribute" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["attribute"]:
            _body_params = _params["attribute"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "201": "Attribute",
        }

        return self.api_client.call_api(
            "/attributes",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def post_branch(self, branch: Branch, **kwargs) -> Branch:  # noqa: E501
        """post_branch  # noqa: E501

        Create a branch (clone a note to a different location in the tree). In case there is a branch between parent note and child note already,  then this will update the existing branch with prefix, notePosition and isExpanded.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_branch(branch, async_req=True)
        >>> result = thread.get()

        :param branch: (required)
        :type branch: Branch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Branch
        """
        kwargs["_return_http_data_only"] = True
        return self.post_branch_with_http_info(branch, **kwargs)  # noqa: E501

    @validate_arguments
    def post_branch_with_http_info(
        self, branch: Branch, **kwargs
    ):  # noqa: E501
        """post_branch  # noqa: E501

        Create a branch (clone a note to a different location in the tree). In case there is a branch between parent note and child note already,  then this will update the existing branch with prefix, notePosition and isExpanded.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_branch_with_http_info(branch, async_req=True)
        >>> result = thread.get()

        :param branch: (required)
        :type branch: Branch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Branch, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["branch"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_branch" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["branch"]:
            _body_params = _params["branch"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "Branch",
            "201": "Branch",
        }

        return self.api_client.call_api(
            "/branches",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def post_refresh_note_ordering(
        self, parent_note_id: constr(strict=True), **kwargs
    ) -> None:  # noqa: E501
        """post_refresh_note_ordering  # noqa: E501

        notePositions in branches are not automatically pushed to connected clients and need a specific instruction.  If you want your changes to be in effect immediately, call this service after setting branches' notePosition.  Note that you need to supply \"parentNoteId\" of branch(es) with changed positions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_refresh_note_ordering(parent_note_id, async_req=True)
        >>> result = thread.get()

        :param parent_note_id: (required)
        :type parent_note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.post_refresh_note_ordering_with_http_info(
            parent_note_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def post_refresh_note_ordering_with_http_info(
        self, parent_note_id: constr(strict=True), **kwargs
    ):  # noqa: E501
        """post_refresh_note_ordering  # noqa: E501

        notePositions in branches are not automatically pushed to connected clients and need a specific instruction.  If you want your changes to be in effect immediately, call this service after setting branches' notePosition.  Note that you need to supply \"parentNoteId\" of branch(es) with changed positions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_refresh_note_ordering_with_http_info(parent_note_id, async_req=True)
        >>> result = thread.get()

        :param parent_note_id: (required)
        :type parent_note_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["parent_note_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_refresh_note_ordering" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["parent_note_id"]:
            _path_params["parentNoteId"] = _params["parent_note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/refresh-note-ordering/{parentNoteId}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def put_note_content_by_id(
        self,
        note_id: constr(strict=True),
        body: Annotated[
            StrictStr, Field(..., description="html content of note")
        ],
        **kwargs
    ) -> None:  # noqa: E501
        """put_note_content_by_id  # noqa: E501

        Updates note content identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_note_content_by_id(note_id, body, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param body: html content of note (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.put_note_content_by_id_with_http_info(
            note_id, body, **kwargs
        )  # noqa: E501

    @validate_arguments
    def put_note_content_by_id_with_http_info(
        self,
        note_id: constr(strict=True),
        body: Annotated[
            StrictStr, Field(..., description="html content of note")
        ],
        **kwargs
    ):  # noqa: E501
        """put_note_content_by_id  # noqa: E501

        Updates note content identified by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_note_content_by_id_with_http_info(note_id, body, async_req=True)
        >>> result = thread.get()

        :param note_id: (required)
        :type note_id: str
        :param body: html content of note (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["note_id", "body"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_note_content_by_id" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["note_id"]:
            _path_params["noteId"] = _params["note_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["body"]:
            _body_params = _params["body"]

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["text/plain"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/notes/{noteId}/content",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def search_notes(
        self,
        search: Annotated[
            StrictStr,
            Field(
                ...,
                description="search query string as described in https://github.com/zadam/trilium/wiki/Search",
            ),
        ],
        fast_search: Annotated[
            Optional[StrictStr],
            Field(
                description="enable fast search (fulltext doesn't look into content)"
            ),
        ] = None,
        include_archived_notes: Annotated[
            Optional[StrictStr],
            Field(
                description="search by default ignores archived notes. Set to 'true' to includes archived notes into search results."
            ),
        ] = None,
        ancestor_note_id: Annotated[
            Optional[constr(strict=True)],
            Field(
                description="search only in a subtree identified by the subtree noteId. By default whole tree is searched."
            ),
        ] = None,
        ancestor_depth: Annotated[
            Optional[StrictStr],
            Field(
                description="define how deep in the tree should the notes be searched"
            ),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr],
            Field(
                description="name of the property/label to order search results by"
            ),
        ] = None,
        order_direction: Annotated[
            Optional[StrictStr],
            Field(description="order direction, ascending or descending"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="limit the number of results you want to receive"
            ),
        ] = None,
        debug: Annotated[
            Optional[StrictStr],
            Field(
                description="set to true to get debug information in the response (search query parsing)"
            ),
        ] = None,
        **kwargs
    ) -> SearchResponse:  # noqa: E501
        """search_notes  # noqa: E501

        Search notes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_notes(search, fast_search, include_archived_notes, ancestor_note_id, ancestor_depth, order_by, order_direction, limit, debug, async_req=True)
        >>> result = thread.get()

        :param search: search query string as described in https://github.com/zadam/trilium/wiki/Search (required)
        :type search: str
        :param fast_search: enable fast search (fulltext doesn't look into content)
        :type fast_search: str
        :param include_archived_notes: search by default ignores archived notes. Set to 'true' to includes archived notes into search results.
        :type include_archived_notes: str
        :param ancestor_note_id: search only in a subtree identified by the subtree noteId. By default whole tree is searched.
        :type ancestor_note_id: str
        :param ancestor_depth: define how deep in the tree should the notes be searched
        :type ancestor_depth: str
        :param order_by: name of the property/label to order search results by
        :type order_by: str
        :param order_direction: order direction, ascending or descending
        :type order_direction: str
        :param limit: limit the number of results you want to receive
        :type limit: int
        :param debug: set to true to get debug information in the response (search query parsing)
        :type debug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.search_notes_with_http_info(
            search,
            fast_search,
            include_archived_notes,
            ancestor_note_id,
            ancestor_depth,
            order_by,
            order_direction,
            limit,
            debug,
            **kwargs
        )  # noqa: E501

    @validate_arguments
    def search_notes_with_http_info(
        self,
        search: Annotated[
            StrictStr,
            Field(
                ...,
                description="search query string as described in https://github.com/zadam/trilium/wiki/Search",
            ),
        ],
        fast_search: Annotated[
            Optional[StrictStr],
            Field(
                description="enable fast search (fulltext doesn't look into content)"
            ),
        ] = None,
        include_archived_notes: Annotated[
            Optional[StrictStr],
            Field(
                description="search by default ignores archived notes. Set to 'true' to includes archived notes into search results."
            ),
        ] = None,
        ancestor_note_id: Annotated[
            Optional[constr(strict=True)],
            Field(
                description="search only in a subtree identified by the subtree noteId. By default whole tree is searched."
            ),
        ] = None,
        ancestor_depth: Annotated[
            Optional[StrictStr],
            Field(
                description="define how deep in the tree should the notes be searched"
            ),
        ] = None,
        order_by: Annotated[
            Optional[StrictStr],
            Field(
                description="name of the property/label to order search results by"
            ),
        ] = None,
        order_direction: Annotated[
            Optional[StrictStr],
            Field(description="order direction, ascending or descending"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="limit the number of results you want to receive"
            ),
        ] = None,
        debug: Annotated[
            Optional[StrictStr],
            Field(
                description="set to true to get debug information in the response (search query parsing)"
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """search_notes  # noqa: E501

        Search notes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_notes_with_http_info(search, fast_search, include_archived_notes, ancestor_note_id, ancestor_depth, order_by, order_direction, limit, debug, async_req=True)
        >>> result = thread.get()

        :param search: search query string as described in https://github.com/zadam/trilium/wiki/Search (required)
        :type search: str
        :param fast_search: enable fast search (fulltext doesn't look into content)
        :type fast_search: str
        :param include_archived_notes: search by default ignores archived notes. Set to 'true' to includes archived notes into search results.
        :type include_archived_notes: str
        :param ancestor_note_id: search only in a subtree identified by the subtree noteId. By default whole tree is searched.
        :type ancestor_note_id: str
        :param ancestor_depth: define how deep in the tree should the notes be searched
        :type ancestor_depth: str
        :param order_by: name of the property/label to order search results by
        :type order_by: str
        :param order_direction: order direction, ascending or descending
        :type order_direction: str
        :param limit: limit the number of results you want to receive
        :type limit: int
        :param debug: set to true to get debug information in the response (search query parsing)
        :type debug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "search",
            "fast_search",
            "include_archived_notes",
            "ancestor_note_id",
            "ancestor_depth",
            "order_by",
            "order_direction",
            "limit",
            "debug",
        ]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_notes" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("search") is not None:  # noqa: E501
            _query_params.append(("search", _params["search"]))
        if _params.get("fast_search") is not None:  # noqa: E501
            _query_params.append(("fastSearch", _params["fast_search"]))
        if _params.get("include_archived_notes") is not None:  # noqa: E501
            _query_params.append(
                ("includeArchivedNotes", _params["include_archived_notes"])
            )
        if _params.get("ancestor_note_id") is not None:  # noqa: E501
            _query_params.append(
                ("ancestorNoteId", _params["ancestor_note_id"])
            )
        if _params.get("ancestor_depth") is not None:  # noqa: E501
            _query_params.append(("ancestorDepth", _params["ancestor_depth"]))
        if _params.get("order_by") is not None:  # noqa: E501
            _query_params.append(("orderBy", _params["order_by"]))
        if _params.get("order_direction") is not None:  # noqa: E501
            _query_params.append(("orderDirection", _params["order_direction"]))
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))
        if _params.get("debug") is not None:  # noqa: E501
            _query_params.append(("debug", _params["debug"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json; charset=utf-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["EtapiTokenAuth", "EtapiBasicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "SearchResponse",
        }

        return self.api_client.call_api(
            "/notes",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get(
                "_return_http_data_only"
            ),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
