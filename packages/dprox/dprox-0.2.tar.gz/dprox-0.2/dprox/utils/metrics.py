import numpy as np
from skimage.metrics import structural_similarity, peak_signal_noise_ratio
import functools

from . import to_ndarray

# Data format: H W C

__all__ = [
    'psnr',
    'ssim',
    'sam',
    'ergas',
    'mpsnr',
    'mssim',
    'mpsnr_max'
]

# helper


def autoconvert(func):
    """
    a decorator that automatically converts the input arguments `output`
    and `target` to numpy arrays before passing them to the decorated function.

    :param func: The function that will be decorated with the `autoconvert` functionality
    :return: a decorated version of the input function `func`. The `wrapped` function takes 
    in two arguments `output` and `target`, and any additional arguments and keyword arguments 
    that `func` may take. It first converts `output` and `target` to numpy arrays using 
    the `to_ndarray` function with the `debatch=True` argument
    """
    @functools.wraps(func)
    def warpped(output, target, *args, **kwargs):
        output = to_ndarray(output, debatch=True)
        target = to_ndarray(target, debatch=True)
        return func(output, target, *args, **kwargs)
    return warpped


def bandwise(func):
    """
    take a function as input and return a wrapped version of that function
    that applies the input function to each color band of the input arrays and returns the average of
    the results.

    :param func: A function that takes in two arrays (output and target) and any additional arguments,
    and returns a scalar value representing the loss or metric value
    :return: The function `wrapped` is being returned, which takes in `output`, `target`, `*args`, and
    `**kwargs` as arguments and applies the `func` function to each channel of the `output` and `target`
    arrays. The final output is the average of the results obtained from applying `func` to each
    channel. The `@functools.wraps(func)` decorator
    """
    @functools.wraps(func)
    def warpped(output, target, *args, **kwargs):
        C = output.shape[-1]
        total = 0
        for ch in range(C):
            x = output[:, :, ch]
            y = target[:, :, ch]
            total += func(x, y, *args, **kwargs)
        return total / C
    return warpped


# metrics

@autoconvert
def psnr(output, target, data_range=1):
    return peak_signal_noise_ratio(target, output, data_range=data_range)


@autoconvert
def ssim(img1, img2, **kwargs):
    return structural_similarity(img1, img2, channel_axis=2, **kwargs)


@autoconvert
def sam(img1, img2, eps=1e-8):
    """
    Spectral Angle Mapper (SAM) which defines the spectral similarity between two spectra
    """
    tmp1 = np.sum(img1 * img2, axis=2) + eps
    tmp2 = np.sqrt(np.sum(img1**2, axis=2)) + eps
    tmp3 = np.sqrt(np.sum(img2**2, axis=2)) + eps
    tmp4 = tmp1 / tmp2 / tmp3
    angle = np.arccos(tmp4.clip(-1, 1))
    return np.mean(np.real(angle))


@autoconvert
def ergas(output, target, r=1):
    """
    calculate the ERGAS (Error Relative Global Average Squared) metric between the output
    and target images.

    :param output: This is a numpy array representing the output image generated by a remote sensing
    algorithm
    :param target: The target parameter is a numpy array representing the true or desired output of a
    model or system. It has a shape of (height, width, bands), where height and width represent the
    dimensions of the image and bands represent the number of spectral bands in the image
    :param r: The parameter "r" is a scaling factor used to adjust the magnitude of the ERGAS value. It
    is set to 1 by default, defaults to 1 (optional)
    :return: the ERGAS (Error Relative Global Accuracy Squared) value calculated using the input
    parameters output, target, and r.
    """
    b = target.shape[-1]
    ergas = 0
    for i in range(b):
        ergas += np.mean((target[:, :, i] - output[:, :, i])**2) / (np.mean(target[:, :, i])**2)
    ergas = 100 * r * np.sqrt(ergas / b)
    return ergas


# bandwise metrics

@bandwise
@autoconvert
def mpsnr(output, target, data_range=1):
    return psnr(target, output, data_range=data_range)


@autoconvert
def mssim(img1, img2, **kwargs):
    return ssim(img1, img2, **kwargs)


@autoconvert
def mpsnr_max(output, target):
    """ Different from mpsnr, this function use max value of 
        each channel (instead of 1 or 255) as the peak signal.
    """
    total = 0.
    for k in range(target.shape[-1]):
        peak = np.amax(target[:, :, k])**2
        mse = np.mean((output[:, :, k] - target[:, :, k])**2)
        total += 10 * np.log10(peak / mse)
    return total / target.shape[-1]
