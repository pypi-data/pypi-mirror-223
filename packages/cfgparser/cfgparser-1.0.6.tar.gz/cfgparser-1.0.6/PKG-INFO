Metadata-Version: 2.1
Name: cfgparser
Version: 1.0.6
Summary: Python package that allows to parse typed configs defined by python dataclasses
Home-page: https://github.com/CaRniFeXeR/PythonConfigParser
Author: Florian Kowarsch
Author-email: flo.kowarsch@yahoo.de
License: UNKNOWN
Project-URL: Bug Reports, https://github.com/CaRniFeXeR/PythonConfigParser/issues
Project-URL: Source, https://github.com/CaRniFeXeR/PythonConfigParser/
Description: # PythonConfigParser
        
        
        easy, light-weight fully-typed python configs.
        not more, not less.
            
        [![PyPI version](https://badge.fury.io/py/cfgparser.svg)](https://badge.fury.io/py/cfgparser)
        ![Badge Name](https://github.com/CaRniFeXeR/PythonConfigParser/actions/workflows/unittests.yml/badge.svg?branch=main&event=push)
        [![codecov](https://codecov.io/gh/CaRniFeXeR/PythonConfigParser/main/graph/badge.svg)](https://codecov.io/gh/CaRniFeXeR/PythonConfigParser)
        
        
        ## Usage
        
        define your config stucture in a dataclass like
        
        ```python
        from dataclasses import dataclass
        from typing import List
        
        @dataclass
        class DummyConfigElement:
            name: str
            list: List[int]
            another_list: List[float]
        
        ```
        
        ### from file 
        
        First initialize the config parser with the path to the module with the config definitions.
        
        ```python
        
        parser = ConfigParser(datastructure_module_name="mysrc.datastructures.configs")
        # Then parse the config from file.
        my_config = parser.parse_from_file("myconfig.json")
        
        ```
        
        ### from dictionary
        
        ```python
        
        my_config_dict = {"type_name" : "mysrc.datastructures.configs.a"}
        my_config = ConfigParser().parse(my_config_dict)
        
        ```
        
        
        #### type definition
        There are two ways to define the configs type:
        - specified in the config itself
            - e.g in the code example above
            - path to the config class must be specified as str in the config as key "type_name"
        - specified when parsing the config
            - if the config has no key "typed_config" set, the type can be specified when parsing the config
            
        ```python
        from mysrc.datastructures.configs import a
        my_config_dict = {"some_key" : "some_value"}
        my_config = ConfigParser().parse_typed(my_config_dict,a)
        
        ```
        
        By default every field can be explicitly set to None. If you don't what this behaviour you can set the flag "allow_none" to False.
        
        ```python
            cfgparser.settings.allow_none = False
        ```
        
        ## Features
        
        - fully typed json and yaml configs
        - nested configs
        - complex union and optional types
        - dict object into typed dataclass
        
        ## Installation
        
        ```
        pip install cfgparser
        ```
        
        ## Features Roadmap
        
        - specify config from cli
        - post hock
        - distributed configs
        
Keywords: config,parser,YAML,JSON,typed-parsing,dataclass,lightweight
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Build Tools
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3 :: Only
Requires-Python: >=3.7, <4
Description-Content-Type: text/markdown
