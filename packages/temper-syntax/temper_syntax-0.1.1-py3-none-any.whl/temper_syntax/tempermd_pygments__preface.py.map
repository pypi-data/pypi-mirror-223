{ "version": 3, "file": "OUTPUT_ROOT/temper-syntax/py/temper_syntax/tempermd_pygments__preface.py", "sources": [ "-work/temper-syntax/tempermd-pygments.temper.md" ], "sourcesContent": [ "# Temper Markdown Pygments Lexer Info\n\nThere's less to do here than for the core Temper lexer, but keeping core\nmetadata central to the Temper Syntax library is still nice.\n\n    export class TemperMdLexer {\n      public name: String = \u0022TemperMarkdown\u0022;\n      public aliases: List\u003cString\u003e = [\u0022temper.md\u0022, \u0022tempermd\u0022];\n      public filenames: List\u003cString\u003e = [\u0022*.temper.md\u0022, \u0022*.tempermd\u0022];\n\n      public tokens: Map\u003cString, List\u003cRuleOption\u003e\u003e = new Map([\n        new Pair(\u0022root\u0022, [\n\nTo find indentation, use relatively simple 4 spaces from start for now. I don't\nthink Pygment's MarkdownLexer even recognizing indented code blocks at all right\nnow, so we get it to ourselves.\n\nTODO Recognize indentation relative to previous, such as outlines.\n\n          new Rule(raw\u0022^\\s*\\n {4}\u0022, Whitespace, \u0022indented\u0022),\n          inherit,\n        ].as\u003cList\u003cRuleOption\u003e\u003e()),\n\n        new Pair(\u0022indented\u0022, [\n          new Rule(\n\nThis seems to recognize the end of indented sections ok for the moment, limited\nto 4-space indentation from line start for now.\n\n            raw\u0022(?s)(.*?)(?=\\Z|\\n(?: {1,3}[^ ]|[^ ]|\u0024))\u0022,\n            bygroups([using(\u0022Temper\u0022)]),\n            \u0022#pop\u0022,\n          ),\n        ].as\u003cList\u003cRuleOption\u003e\u003e()),\n      ]);\n    }\n\n    let { ... } = import(\u0022./pygments\u0022);\n" ], "names": [ "return" ], "mappings": "AAAAA,SAAA;AAAA,SAAAA" }