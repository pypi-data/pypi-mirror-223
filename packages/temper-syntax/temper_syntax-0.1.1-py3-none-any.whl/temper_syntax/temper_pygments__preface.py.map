{ "version": 3, "file": "OUTPUT_ROOT/temper-syntax/py/temper_syntax/temper_pygments__preface.py", "sources": [ "-work/temper-syntax/temper-pygments.temper.md" ], "sourcesContent": [ "# Temper Pygments Lexer\n\n## Lexer class\n\nWe can't easily access backend classes, so we can't subclass\n`pygments.lexer.RegexLexer`, but we can define a separate class that can then\nbe subclassed in Python or elsewhere.\n\nTODO Maybe define an independent Lexer type and just create an instance here?\n\n    export class TemperLexer {\n\nThese indicators seems somewhat redundant to me, but they follow the examples in\nthe [Pygments documentation][pygments-lexer-docs].\n\n      public name: String = \u0022Temper\u0022;\n      public aliases: List\u003cString\u003e = [\u0022temper\u0022];\n      public filenames: List\u003cString\u003e = [\u0022*.temper\u0022];\n\n### Token rules\n\nMain thing, though, is the list of rules for definition tokens.\n\n      public tokens: Map\u003cString, List\u003cRuleOption\u003e\u003e = new Map([\n\n#### Root\n\n        new Pair(\u0022root\u0022, [\n          new Rule(raw\u0022\\s+\u0022, Whitespace),\n          new Rule(\u0022//.*?\u0024\u0022, CommentSingleline),\n          new Rule(raw\u0022/\\*\u0022, CommentMultiline, \u0022nestedcomment\u0022),\n          new Rule(\n            words(\u0022false\u0022, \u0022NaN\u0022, \u0022null\u0022, \u0022true\u0022, \u0022void\u0022),\n            KeywordConstant,\n          ),\n          new Rule(\n            words(\n              \u0022class\u0022, \u0022interface\u0022, \u0022let\u0022, \u0022private\u0022, \u0022public\u0022, \u0022sealed\u0022, \u0022var\u0022,\n            ),\n            KeywordDeclaration,\n          ),\n          new Rule(\n            words(\n              \u0022do\u0022, \u0022else\u0022, \u0022export\u0022, \u0022extends\u0022, \u0022fn\u0022, \u0022if\u0022, \u0022import\u0022, \u0022is\u0022,\n              \u0022match\u0022, \u0022new\u0022, \u0022orelse\u0022,\n            ),\n            Keyword,\n          ),\n          new Rule(\n            words(\n              \u0022AnyValue\u0022, \u0022Boolean\u0022, \u0022Float64\u0022, \u0022Function\u0022, \u0022Int\u0022, \u0022List\u0022,\n              \u0022ListBuilder\u0022, \u0022Listed\u0022, \u0022Map\u0022, \u0022MapBuilder\u0022, \u0022MapKey\u0022, \u0022Mapped\u0022,\n              \u0022NoResult\u0022, \u0022Null\u0022, \u0022String\u0022, \u0022StringSlice\u0022, \u0022Void\u0022,\n            ),\n            NameBuiltin,\n          ),\n          new Rule(\u0022\\\u0022\u0022, StringKind, \u0022string\u0022),\n          new Rule(\u0022[-=+*\u0026|\u003c\u003e]+|/=?\u0022, Operator),\n          new Rule(\u0022[{}();:.,]\u0022, Punctuation),\n          new Rule(raw\u0022\\d+\\.?\\d*|\\.\\d+\u0022, Number),\n          new Rule(\u0022@\u0024{nameRegex}\u0022, NameDecorator),\n          new Rule(nameRegex, Name),\n        ].as\u003cList\u003cRuleOption\u003e\u003e()),\n\n#### Multiline/Nested Comments\n\nWe plan to support nested comments soon, so just implement that already here.\nThe technique here is based on the `nestedcomment` for the [D Language lexer for\nPygments][dlang-nestedcomment].\n\n        new Pair(\u0022nestedcomment\u0022, [\n          new Rule(raw\u0022[^*/]+\u0022, CommentMultiline),\n          new Rule(raw\u0022/\\*\u0022, CommentMultiline, \u0022#push\u0022),\n          new Rule(raw\u0022\\*/\u0022, CommentMultiline, \u0022#pop\u0022),\n          new Rule(raw\u0022[*/]\u0022, CommentMultiline),\n        ].as\u003cList\u003cRuleOption\u003e\u003e()),\n\n#### Strings\n\n        new Pair(\u0022interpolation\u0022, [\n          new Rule(\u0022}\u0022, StringInterpol, \u0022#pop\u0022),\n          include(\u0022root\u0022),\n        ].as\u003cList\u003cRuleOption\u003e\u003e()),\n\nI'm not sure if order matters here. Seems simpler, but if I don't exclude `\u0024{`\nfrom core string chars, I don't get interp.\n\n        new Pair(\u0022string\u0022, [\n          new Rule(\u0022\\\u0022\u0022, StringKind, \u0022#pop\u0022),\n          new Rule(raw\u0022\\\u0024\\{\u0022, StringInterpol, \u0022interpolation\u0022),\n          new Rule(\u0022(?:[^\\\u0022\u0024]|\\\\\u0024[^{])+\u0022, StringKind),\n        ].as\u003cList\u003cRuleOption\u003e\u003e()),\n\n      ]);\n\n    }\n\n## Helper functions and values\n\nBe sloppy with names for now. TODO More complete Unicode support.\n\n    let nameRegex = \u0022[_\u003c\u003cLu\u003e\u003e\u003c\u003cLl\u003e\u003e][_\u003c\u003cLu\u003e\u003e\u003c\u003cLl\u003e\u003e0-9]*\u0022;\n\n    let words(...names: List\u003cString\u003e): String {\n      \u0022\\\\b(?:\u0024{names.join(\u0022|\u0022) { (x);; x }})\\\\b\u0022\n    }\n\n## Imports and links\n\n    let { ... } = import(\u0022./pygments\u0022);\n\n[dlang-nestedcomment]: https://github.com/pygments/pygments/blob/d0acfff1121f9ee3696b01a9077ebe9990216634/pygments/lexers/d.py#L242\n[issue1631]: https://github.com/temper-lang/temper/issues/1631\n[pygments-lexer-docs]: https://pygments.org/docs/lexerdevelopment/\n" ], "names": [ "return" ], "mappings": "AAAAA,SAAA;AAAA,SAAAA" }